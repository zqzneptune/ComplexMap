[{"path":"https://zqzneptune.github.io/ComplexMap/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2025 Qingzhou Zhang Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_00-perp-input.html","id":"the-complexmap-philosophy-identifier-matching","dir":"Articles","previous_headings":"","what":"The ComplexMap Philosophy: Identifier Matching","title":"Preparing Input Data","text":"ComplexMap package designed powerful, flexible, species-agnostic. contain hard-coded assumptions Homo sapiens model organism. entire workflow depends one simple principle: identifiers used input lists must match. means package’s functions can support organism identifier type (e.g., Gene Symbols, Entrez IDs, Ensembl IDs, UniProt IDs), long consistent. three key inputs identifiers must consistent: Complex List: list protein/gene members complex want analyze. Functional Gene Sets (GMT): database used enrichment analysis. Reference Complex List: “gold standard” list used benchmarking evaluateComplexes(). (required benchmarking, functional analysis.) example, complex list uses Gene Symbols, GMT file must also use Gene Symbols. complex list uses Entrez IDs, GMT must use Entrez IDs. vignette demonstrates prepare functional gene sets (GMT) various sources , crucially, handle convert identifiers ensure match input data.","code":"library(ComplexMap) library(dplyr)  # For this tutorial, we will assume our input complex list uses Gene Symbols. myComplexes <- list(   CPLX1 = c(\"POLR2A\", \"POLR2B\", \"POLR2C\"),   CPLX2 = c(\"CDK1\", \"CCNB1\", \"CCNB2\") )"},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_00-perp-input.html","id":"preparing-functional-gene-sets-gmt","dir":"Articles","previous_headings":"","what":"Preparing Functional Gene Sets (GMT)","title":"Preparing Input Data","text":"ComplexMap provides several helper functions obtain GMT files. Let’s explore one, paying close attention identifier type returns.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_00-perp-input.html","id":"method-1-from-a-user-provided-local-file","dir":"Articles","previous_headings":"Preparing Functional Gene Sets (GMT)","what":"Method 1: From a User-Provided Local File","title":"Preparing Input Data","text":"direct method. GMT file, can load getGmtFromFile(). First, get path example GMT file included package. file uses Gene Symbols. Load GMT file path Let’s inspect identifiers Identifier Match: example GMT file uses Gene Symbols. Since hypothetical myComplexes list also uses Gene Symbols, directly compatible ready analysis.","code":"gmtPath <- getExampleGmt() gmtFromFile <- getGmtFromFile(gmtPath) ## Fetching gene sets from local file: /private/var/folders/gb/q0_2jm654r9_t3r2hb11v3tm0000gn/T/Rtmpx4UtqW/temp_libpath4393b14db1b/ComplexMap/extdata/c2.cp.biocarta.v2025.1.Hs.symbols.gmt # Name of the first gene set: names(gmtFromFile)[1:5] ## [1] \"BIOCARTA_41BB_PATHWAY\"          \"BIOCARTA_ACE2_PATHWAY\"          ## [3] \"BIOCARTA_ACETAMINOPHEN_PATHWAY\" \"BIOCARTA_ACH_PATHWAY\"           ## [5] \"BIOCARTA_ACTINY_PATHWAY\" # First 5 genes in that set: gmtFromFile[1] ## $BIOCARTA_41BB_PATHWAY ##  [1] \"ATF2\"    \"CHUK\"    \"IFNG\"    \"IKBKB\"   \"IL2\"     \"IL4\"     \"JUN\"     ##  [8] \"MAP3K1\"  \"MAP3K5\"  \"MAP4K5\"  \"MAPK14\"  \"MAPK8\"   \"NFKB1\"   \"NFKBIA\"  ## [15] \"RELA\"    \"TNFRSF9\" \"TNFSF9\"  \"TRAF2\""},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_00-perp-input.html","id":"method-2-from-the-molecular-signatures-database-msigdb","dir":"Articles","previous_headings":"Preparing Functional Gene Sets (GMT)","what":"Method 2: From the Molecular Signatures Database (MSigDB)","title":"Preparing Input Data","text":"msigdbr package provides powerful --date interface MSigDB collections. getMsigdbGmt() function simplifies process. Identifier Match: default, msigdbr also returns Gene Symbols. directly compatible myComplexes list.","code":"# Fetch the Hallmark gene sets for Human # This requires the `msigdbr` package if (requireNamespace(\"msigdbr\", quietly = TRUE)) {   h_gmt <- getMsigdbGmt(species = \"Homo sapiens\", collection = \"H\")    # Inspect the identifiers   h_gmt[1] } ## Fetching MSigDB sets (Species: Homo sapiens, Cat: H) ## $HALLMARK_ADIPOGENESIS ##   [1] \"ABCA1\"    \"ABCB8\"    \"ACAA2\"    \"ACADL\"    \"ACADM\"    \"ACADS\"    ##   [7] \"ACLY\"     \"ACO2\"     \"ACOX1\"    \"ADCY6\"    \"ADIG\"     \"ADIPOQ\"   ##  [13] \"ADIPOR2\"  \"AGPAT3\"   \"AIFM1\"    \"AK2\"      \"ALDH2\"    \"ALDOA\"    ##  [19] \"ANGPT1\"   \"ANGPTL4\"  \"APLP2\"    \"APOE\"     \"ARAF\"     \"ARL4A\"    ##  [25] \"ATL2\"     \"ATP1B3\"   \"ATP5PO\"   \"BAZ2A\"    \"BCKDHA\"   \"BCL2L13\"  ##  [31] \"BCL6\"     \"C3\"       \"CAT\"      \"CAVIN1\"   \"CAVIN2\"   \"CCNG2\"    ##  [37] \"CD151\"    \"CD302\"    \"CD36\"     \"CDKN2C\"   \"CHCHD10\"  \"CHUK\"     ##  [43] \"CIDEA\"    \"CMBL\"     \"CMPK1\"    \"COL15A1\"  \"COL4A1\"   \"COQ3\"     ##  [49] \"COQ5\"     \"COQ9\"     \"COX6A1\"   \"COX7B\"    \"COX8A\"    \"CPT2\"     ##  [55] \"CRAT\"     \"CS\"       \"CYC1\"     \"CYP4B1\"   \"DBT\"      \"DDT\"      ##  [61] \"DECR1\"    \"DGAT1\"    \"DHCR7\"    \"DHRS7\"    \"DHRS7B\"   \"DLAT\"     ##  [67] \"DLD\"      \"DNAJB9\"   \"DNAJC15\"  \"DRAM2\"    \"ECH1\"     \"ECHS1\"    ##  [73] \"ELMOD3\"   \"ELOVL6\"   \"ENPP2\"    \"EPHX2\"    \"ESRRA\"    \"ESYT1\"    ##  [79] \"ETFB\"     \"FABP4\"    \"FAH\"      \"FZD4\"     \"G3BP2\"    \"GADD45A\"  ##  [85] \"GBE1\"     \"GHITM\"    \"GPAM\"     \"GPAT4\"    \"GPD2\"     \"GPHN\"     ##  [91] \"GPX3\"     \"GPX4\"     \"GRPEL1\"   \"HADH\"     \"HIBCH\"    \"HSPB8\"    ##  [97] \"IDH1\"     \"IDH3A\"    \"IDH3G\"    \"IFNGR1\"   \"IMMT\"     \"ITGA7\"    ## [103] \"ITIH5\"    \"ITSN1\"    \"JAGN1\"    \"LAMA4\"    \"LEP\"      \"LIFR\"     ## [109] \"LIPE\"     \"LPCAT3\"   \"LPL\"      \"LTC4S\"    \"MAP4K3\"   \"MCCC1\"    ## [115] \"MDH2\"     \"ME1\"      \"MGLL\"     \"MGST3\"    \"MIGA2\"    \"MRAP\"     ## [121] \"MRPL15\"   \"MTARC2\"   \"MTCH2\"    \"MYLK\"     \"NABP1\"    \"NDUFA5\"   ## [127] \"NDUFAB1\"  \"NDUFB7\"   \"NDUFS3\"   \"NKIRAS1\"  \"NMT1\"     \"OMD\"      ## [133] \"ORM1\"     \"PDCD4\"    \"PEMT\"     \"PEX14\"    \"PFKFB3\"   \"PFKL\"     ## [139] \"PGM1\"     \"PHLDB1\"   \"PHYH\"     \"PIM3\"     \"PLIN2\"    \"POR\"      ## [145] \"PPARG\"    \"PPM1B\"    \"PPP1R15B\" \"PRDX3\"    \"PREB\"     \"PTCD3\"    ## [151] \"PTGER3\"   \"QDPR\"     \"RAB34\"    \"REEP5\"    \"REEP6\"    \"RETN\"     ## [157] \"RETSAT\"   \"RIOK3\"    \"RMDN3\"    \"RNF11\"    \"RREB1\"    \"RTN3\"     ## [163] \"SAMM50\"   \"SCARB1\"   \"SCP2\"     \"SDHB\"     \"SDHC\"     \"SLC19A1\"  ## [169] \"SLC1A5\"   \"SLC25A1\"  \"SLC25A10\" \"SLC27A1\"  \"SLC5A6\"   \"SLC66A3\"  ## [175] \"SNCG\"     \"SOD1\"     \"SORBS1\"   \"SOWAHC\"   \"SPARCL1\"  \"SQOR\"     ## [181] \"SSPN\"     \"STAT5A\"   \"STOM\"     \"SUCLG1\"   \"SULT1A1\"  \"TALDO1\"   ## [187] \"TANK\"     \"TKT\"      \"TOB1\"     \"TST\"      \"UBC\"      \"UBQLN1\"   ## [193] \"UCK1\"     \"UCP2\"     \"UQCR10\"   \"UQCR11\"   \"UQCRC1\"   \"UQCRQ\"    ## [199] \"VEGFB\"    \"YWHAG\""},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_00-perp-input.html","id":"method-3-from-gene-ontology-go-via-bioconductor","dir":"Articles","previous_headings":"Preparing Functional Gene Sets (GMT)","what":"Method 3: From Gene Ontology (GO) via Bioconductor","title":"Preparing Input Data","text":"Using official Bioconductor annotation packages highly reproducible way get functional annotations. databases, however, typically use stable database identifiers, gene symbols. Identifier Mismatch! getGoGmt function returns list genes Entrez IDs (e.g., “5594”, “5595”). match Gene Symbols myComplexes list (e.g., “POLR2A”). Solution: Convert Complex List Identifiers recommended approach convert input complex identifiers match stable IDs annotation database. AnnotationDbi::mapIds function perfect . Now, myComplexesEntrez list directly compatible goGmt generated Bioconductor.","code":"# This requires an organism annotation package, e.g., org.Hs.eg.db for human if (requireNamespace(\"org.Hs.eg.db\", quietly = TRUE)) {   suppressPackageStartupMessages(library(org.Hs.eg.db))   # Fetch Biological Process (BP) terms   goGmt <- getGoGmt(speciesDb = org.Hs.eg.db, ontology = \"BP\")    # Inspect the identifiers   goGmt[1] } ## ## Fetching GO (BP) gene sets from Bioconductor... ## 'select()' returned 1:many mapping between keys and columns ## ## 'select()' returned 1:1 mapping between keys and columns ## Retained 2942 GO terms (size 10-500) out of 12173 ## $`2-oxoglutarate metabolic process` ##  [1] \"1291\"   \"1738\"   \"1743\"   \"2805\"   \"2806\"   \"3417\"   \"3418\"   \"4967\"   ##  [9] \"5264\"   \"6898\"   \"51166\"  \"55753\"  \"56267\"  \"79944\"  \"84706\"  \"92259\"  ## [17] \"137872\" \"728294\" if (requireNamespace(\"org.Hs.eg.db\", quietly = TRUE)) {   suppressPackageStartupMessages(library(org.Hs.eg.db))   # Get all unique symbols from our complex list   allSymbols <- unique(unlist(myComplexes))    # Map symbols to Entrez IDs   symbolToEntrez <- AnnotationDbi::mapIds(org.Hs.eg.db,                                            keys = allSymbols,                                            keytype = \"SYMBOL\",                                            column = \"ENTREZID\",                                            multiVals = \"first\")      # Remove any symbols that could not be mapped   symbolToEntrez <- symbolToEntrez[!is.na(symbolToEntrez)]    # Now, create a new complex list with Entrez IDs   myComplexesEntrez <- lapply(myComplexes, function(complex) {     # Look up the Entrez ID for each symbol and keep only those that were mapped     unname(symbolToEntrez[as.character(complex)])   })      # Clean out any NAs that resulted from unmapped symbols   myComplexesEntrez <- lapply(myComplexesEntrez, function(x) x[!is.na(x)])    # Inspect the result   print(myComplexesEntrez) } ## 'select()' returned 1:1 mapping between keys and columns ## $CPLX1 ## [1] \"5430\" \"5431\" \"5432\" ##  ## $CPLX2 ## [1] \"983\"  \"891\"  \"9133\""},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_00-perp-input.html","id":"method-4-from-reactome-pathways-via-bioconductor","dir":"Articles","previous_headings":"Preparing Functional Gene Sets (GMT)","what":"Method 4: From Reactome Pathways via Bioconductor","title":"Preparing Input Data","text":"Similarly, reactome.db package provides pathway annotations, also use Entrez IDs. Identifier Mismatch! Like GO example, reactome.db provides Entrez IDs. Solution: solution Gene Ontology. use myComplexesEntrez list created previous step, identifiers match identifiers reactomeGmt.","code":"if (requireNamespace(\"reactome.db\", quietly = TRUE) &&      requireNamespace(\"org.Hs.eg.db\", quietly = TRUE)) {   suppressPackageStartupMessages(library(reactome.db))   suppressPackageStartupMessages(library(org.Hs.eg.db))   reactomeGmt <- getReactomeGmt(speciesDb = org.Hs.eg.db)    # Inspect the identifiers   reactomeGmt[1] } ## Fetching Reactome pathway gene sets from Bioconductor... ## $`Homo sapiens: Hemostasis` ##   [1] \"1\"      \"10019\"  \"10112\"  \"10125\"  \"10125\"  \"1017\"   \"10184\"  \"1020\"   ##   [9] \"10235\"  \"10235\"  \"10242\"  \"10257\"  \"10335\"  \"10362\"  \"10376\"  \"10381\"  ##  [17] \"10382\"  \"10383\"  \"10411\"  \"10447\"  \"10451\"  \"10451\"  \"10461\"  \"1048\"   ##  [25] \"10487\"  \"10490\"  \"10544\"  \"10603\"  \"1062\"   \"10630\"  \"10672\"  \"10672\"  ##  [33] \"10681\"  \"10681\"  \"1072\"   \"10749\"  \"1084\"   \"10846\"  \"1088\"   \"10916\"  ##  [41] \"10938\"  \"11004\"  \"11069\"  \"11093\"  \"11127\"  \"11127\"  \"11136\"  \"11216\"  ##  [49] \"112714\" \"11311\"  \"113220\" \"11343\"  \"113457\" \"1191\"   \"12\"     \"120425\" ##  [57] \"124602\" \"126961\" \"1277\"   \"1277\"   \"1278\"   \"1278\"   \"135228\" \"139189\" ##  [65] \"139322\" \"1398\"   \"139818\" \"14\"     \"140628\" \"140885\" \"1432\"   \"1445\"   ##  [73] \"146850\" \"146909\" \"147700\" \"150\"    \"151\"    \"152\"    \"1521\"   \"1525\"   ##  [81] \"1606\"   \"1607\"   \"1608\"   \"160851\" \"1609\"   \"161882\" \"1675\"   \"1793\"   ##  [89] \"1794\"   \"1795\"   \"1893\"   \"1950\"   \"197\"    \"2\"      \"207\"    \"213\"    ##  [97] \"2147\"   \"2149\"   \"2151\"   \"2151\"   \"2152\"   \"2153\"   \"2155\"   \"2157\"   ## [105] \"2158\"   \"2159\"   \"2160\"   \"2161\"   \"2162\"   \"2165\"   \"2207\"   \"221037\" ## [113] \"221458\" \"221955\" \"2243\"   \"2244\"   \"226\"    \"2266\"   \"2268\"   \"2277\"   ## [121] \"22915\"  \"22920\"  \"22920\"  \"22927\"  \"22953\"  \"23028\"  \"23046\"  \"23052\"  ## [129] \"23095\"  \"2316\"   \"23186\"  \"23303\"  \"23348\"  \"2335\"   \"23414\"  \"23428\"  ## [137] \"23468\"  \"23533\"  \"23539\"  \"23657\"  \"23759\"  \"23764\"  \"23764\"  \"24137\"  ## [145] \"25\"     \"2534\"   \"259215\" \"25942\"  \"25970\"  \"26090\"  \"26153\"  \"2621\"   ## [153] \"2623\"   \"2624\"   \"2625\"   \"2626\"   \"2627\"   \"27040\"  \"27094\"  \"27154\"  ## [161] \"2734\"   \"27345\"  \"2767\"   \"2767\"   \"2768\"   \"2768\"   \"2769\"   \"2769\"   ## [169] \"2770\"   \"2771\"   \"2773\"   \"2776\"   \"2776\"   \"2778\"   \"2778\"   \"2782\"   ## [177] \"2782\"   \"2783\"   \"2783\"   \"2784\"   \"2784\"   \"2785\"   \"2785\"   \"2786\"   ## [185] \"2786\"   \"2787\"   \"2787\"   \"2788\"   \"2788\"   \"2790\"   \"2790\"   \"2791\"   ## [193] \"2791\"   \"2792\"   \"2792\"   \"2793\"   \"2793\"   \"2811\"   \"2812\"   \"2814\"   ## [201] \"2815\"   \"2817\"   \"284\"    \"284\"    \"285\"    \"285643\" \"2885\"   \"2886\"   ## [209] \"2888\"   \"29106\"  \"29127\"  \"2977\"   \"29789\"  \"29802\"  \"2982\"   \"2983\"   ## [217] \"2993\"   \"2994\"   \"2995\"   \"302\"    \"3020\"   \"3021\"   \"3043\"   \"3045\"   ## [225] \"3046\"   \"3047\"   \"3048\"   \"3053\"   \"3065\"   \"3066\"   \"308\"    \"3082\"   ## [233] \"30845\"  \"30846\"  \"3265\"   \"3273\"   \"3309\"   \"333932\" \"334\"    \"335\"    ## [241] \"338\"    \"3439\"   \"3440\"   \"3441\"   \"3442\"   \"3443\"   \"3444\"   \"3445\"   ## [249] \"3446\"   \"3447\"   \"3448\"   \"3449\"   \"3451\"   \"3452\"   \"3456\"   \"346562\" ## [257] \"347688\" \"347733\" \"3479\"   \"3481\"   \"350\"    \"351\"    \"3512\"   \"3543\"   ## [265] \"3635\"   \"3655\"   \"3659\"   \"3660\"   \"3671\"   \"3672\"   \"3673\"   \"3674\"   ## [273] \"3675\"   \"3676\"   \"3678\"   \"3683\"   \"3684\"   \"3685\"   \"3687\"   \"3688\"   ## [281] \"3688\"   \"3689\"   \"3690\"   \"3699\"   \"3700\"   \"3705\"   \"3708\"   \"3709\"   ## [289] \"3710\"   \"3717\"   \"374354\" \"3778\"   \"3779\"   \"3796\"   \"3797\"   \"3797\"   ## [297] \"3798\"   \"3799\"   \"3818\"   \"3827\"   \"3831\"   \"3832\"   \"3833\"   \"3833\"   ## [305] \"3834\"   \"3835\"   \"3845\"   \"387\"    \"388\"    \"3897\"   \"391\"    \"3920\"   ## [313] \"3932\"   \"3937\"   \"3959\"   \"4067\"   \"4072\"   \"408\"    \"409\"    \"4097\"   ## [321] \"4097\"   \"4099\"   \"4267\"   \"4282\"   \"4312\"   \"4352\"   \"440533\" \"4602\"   ## [329] \"462\"    \"4680\"   \"4778\"   \"4778\"   \"481\"    \"482\"    \"483\"    \"4842\"   ## [337] \"4843\"   \"4846\"   \"487\"    \"488\"    \"489\"    \"4893\"   \"490\"    \"491\"    ## [345] \"492\"    \"493\"    \"4973\"   \"5004\"   \"5005\"   \"5023\"   \"5024\"   \"5025\"   ## [353] \"5026\"   \"5027\"   \"5028\"   \"5028\"   \"5051\"   \"5054\"   \"5055\"   \"50808\"  ## [361] \"50848\"  \"50940\"  \"5099\"   \"5104\"   \"51097\"  \"51206\"  \"51266\"  \"51317\"  ## [369] \"5136\"   \"51368\"  \"51378\"  \"5138\"   \"5152\"   \"5153\"   \"5154\"   \"5155\"   ## [377] \"51571\"  \"5170\"   \"5170\"   \"51706\"  \"51744\"  \"5175\"   \"51764\"  \"51764\"  ## [385] \"51807\"  \"5196\"   \"5197\"   \"5216\"   \"5265\"   \"5267\"   \"5269\"   \"5270\"   ## [393] \"5271\"   \"5290\"   \"5291\"   \"5294\"   \"5295\"   \"5296\"   \"5321\"   \"5327\"   ## [401] \"5328\"   \"5329\"   \"5335\"   \"5336\"   \"5340\"   \"5341\"   \"5345\"   \"54210\"  ## [409] \"54331\"  \"54331\"  \"54495\"  \"54518\"  \"54676\"  \"547\"    \"5473\"   \"5478\"   ## [417] \"5478\"   \"54863\"  \"55083\"  \"5515\"   \"5516\"   \"5518\"   \"5519\"   \"5525\"   ## [425] \"5526\"   \"5527\"   \"5528\"   \"5529\"   \"55423\"  \"5547\"   \"5552\"   \"55582\"  ## [433] \"55604\"  \"55605\"  \"55614\"  \"55619\"  \"5566\"   \"55664\"  \"55669\"  \"5567\"   ## [441] \"5568\"   \"5573\"   \"5575\"   \"5576\"   \"5577\"   \"5578\"   \"5579\"   \"5580\"   ## [449] \"5581\"   \"5582\"   \"5583\"   \"5590\"   \"5592\"   \"5592\"   \"5593\"   \"5593\"   ## [457] \"5594\"   \"5595\"   \"55970\"  \"55970\"  \"5624\"   \"5627\"   \"56301\"  \"5657\"   ## [465] \"5660\"   \"5669\"   \"5670\"   \"5671\"   \"5672\"   \"5673\"   \"5675\"   \"5676\"   ## [473] \"5678\"   \"5680\"   \"56992\"  \"56992\"  \"57113\"  \"57126\"  \"5739\"   \"5739\"   ## [481] \"57406\"  \"5747\"   \"57572\"  \"5768\"   \"5770\"   \"5777\"   \"5781\"   \"58494\"  ## [489] \"5868\"   \"5874\"   \"5879\"   \"5880\"   \"5889\"   \"5890\"   \"5894\"   \"5906\"   ## [497] \"5908\"   \"5919\"   \"59345\"  \"59345\"  \"60\"     \"6281\"   \"634\"    \"6382\"   ## [505] \"6383\"   \"6385\"   \"6401\"   \"6402\"   \"6403\"   \"6404\"   \"6414\"   \"64145\"  ## [513] \"64147\"  \"64147\"  \"6464\"   \"64780\"  \"64805\"  \"64837\"  \"6520\"   \"653604\" ## [521] \"6543\"   \"6546\"   \"6547\"   \"6566\"   \"66005\"  \"6647\"   \"6654\"   \"6678\"   ## [529] \"6693\"   \"6694\"   \"6714\"   \"6717\"   \"6786\"   \"6810\"   \"6813\"   \"6814\"   ## [537] \"682\"    \"6850\"   \"6850\"   \"6915\"   \"7010\"   \"7010\"   \"7018\"   \"7035\"   ## [545] \"7040\"   \"7042\"   \"7043\"   \"7044\"   \"7056\"   \"7057\"   \"7066\"   \"7076\"   ## [553] \"7078\"   \"708\"    \"7094\"   \"710\"    \"7102\"   \"7114\"   \"7123\"   \"7157\"   ## [561] \"7222\"   \"7225\"   \"7273\"   \"7277\"   \"7278\"   \"7280\"   \"7409\"   \"7409\"   ## [569] \"7410\"   \"7410\"   \"7414\"   \"7422\"   \"7423\"   \"7424\"   \"7441\"   \"7450\"   ## [577] \"7465\"   \"747\"    \"7525\"   \"7534\"   \"7804\"   \"7846\"   \"7873\"   \"78991\"  ## [585] \"7975\"   \"7975\"   \"79861\"  \"80005\"  \"801\"    \"80228\"  \"805\"    \"80739\"  ## [593] \"808\"    \"81\"     \"81027\"  \"813\"    \"813949\" \"8140\"   \"8165\"   \"81704\"  ## [601] \"81928\"  \"81930\"  \"81930\"  \"829\"    \"829\"    \"830\"    \"830\"    \"832\"    ## [609] \"832\"    \"8350\"   \"8351\"   \"8352\"   \"8353\"   \"8354\"   \"8355\"   \"8356\"   ## [617] \"8357\"   \"8358\"   \"83692\"  \"83700\"  \"83706\"  \"83953\"  \"8407\"   \"84617\"  ## [625] \"84643\"  \"84790\"  \"84876\"  \"8503\"   \"8515\"   \"8525\"   \"8526\"   \"8527\"   ## [633] \"85440\"  \"857\"    \"8654\"   \"87\"     \"8793\"   \"8795\"   \"8797\"   \"88\"     ## [641] \"8832\"   \"8968\"   \"89953\"  \"9002\"   \"9002\"   \"9046\"   \"9056\"   \"9057\"   ## [649] \"90952\"  \"90990\"  \"9123\"   \"9127\"   \"914\"    \"9162\"   \"91768\"  \"928\"    ## [657] \"9371\"   \"9371\"   \"94121\"  \"94235\"  \"94235\"  \"9463\"   \"948\"    \"9493\"   ## [665] \"9564\"   \"9585\"   \"960\"    \"961\"    \"962\"    \"9630\"   \"9630\"   \"965\"    ## [673] \"967\"    \"9672\"   \"972\"    \"9732\"   \"9749\"   \"9927\"   \"9948\"   \"998\""},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_00-perp-input.html","id":"conclusion","dir":"Articles","previous_headings":"","what":"Conclusion","title":"Preparing Input Data","text":"vignette demonstrated core philosophy ComplexMap: flexibility identifier consistency. understanding identifier types returned different sources knowing convert data match, can apply ComplexMap workflow virtually organism complex annotation data. Always check identifiers running main analysis functions ensure smooth successful workflow.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_01-workflow.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Analyzing a Human Protein Complex Map","text":"Protein complexes functional machinery cell. High-throughput experimental methods, co-fractionation followed mass spectrometry (CF-MS), can identify hundreds putative protein complexes single experiment. ComplexMap package provides comprehensive workflow process, analyze, annotate, visualize dataset. vignette demonstrates typical workflow using dataset human soluble protein complexes identified via co-fractionation, originally published 2012 census human soluble protein complexes. perform quality control, refine list, perform functional enrichment, build network-based “map” functional landscape complexes. First, let’s load ComplexMap package, along dplyr data manipulation.","code":"library(ComplexMap) library(dplyr)"},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_01-workflow.html","id":"step-1-loading-data","dir":"Articles","previous_headings":"","what":"Step 1: Loading Data","title":"Analyzing a Human Protein Complex Map","text":"ComplexMap package includes two key example datasets: demoComplexes referenceComplexes. demoComplexes: dataset containing list 622 putative protein complexes identified study using integrative global proteomic profiling approach. referenceComplexes: reference dataset containing 324 merged CORUM protein complexes used training protein-protein interaction scoring clustering optimization procedures study. complexes curated CORUM database merged reduce redundancy benchmarking purposes. load datasets directly.","code":"# Load the example datasets shipped with the package data(\"demoComplexes\") data(\"referenceComplexes\")"},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_01-workflow.html","id":"step-2-quality-control","dir":"Articles","previous_headings":"","what":"Step 2: Quality Control","title":"Analyzing a Human Protein Complex Map","text":"analysis, ’s crucial assess quality input complex list. qcComplexList() function provides summary basic statistics, complex sizes, pairwise redundancy. QC report tells us 622 complexes composed 2649 unique proteins. also warns complexes highly redundant (Jaccard similarity >= 0.8), suggesting next step, refinement, necessary.","code":"qcComplexList(demoComplexes) ##  ## --- Running Quality Control on Complex List --- ##  ## [1] Basic Statistics: ##     - Total number of complexes: 622 ##     - Total number of unique proteins: 2649 ##  ## [2] Complex Size Distribution: ##        Min. 1st Qu.  Median    Mean 3rd Qu.    Max. ##       1.000   3.000   4.000   5.183   5.000 102.000 ## Warning in qcComplexList(demoComplexes): 112 complexes have fewer than 3 ## members. ##  ## [3] Redundancy Analysis: ##     - Distribution of Jaccard similarity scores: ##          Min.   1st Qu.    Median      Mean   3rd Qu.      Max. ##     0.0000000 0.0000000 0.0000000 0.0003226 0.0000000 0.5000000 ##     - No highly redundant complex pairs detected. ##  ## --- QC Complete ---"},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_01-workflow.html","id":"step-3-refining-the-complex-list","dir":"Articles","previous_headings":"","what":"Step 3: Refining the Complex List","title":"Analyzing a Human Protein Complex Map","text":"initial list complexes may contain small complexes highly overlapping ones represent slight variations biological entity. refineComplexList() function addresses filtering size merging redundant complexes. , merge complexes Jaccard similarity 0.75 higher. refinement, list consolidated 510 complexes, provides cleaner basis downstream analysis.","code":"# We use a slightly lower mergeThreshold to be more aggressive for this demo refinedComplexes <- refineComplexList(demoComplexes, mergeThreshold = 0.75) ##  ## --- Refining Input Complex List --- ## Filtered 112 complexes by size. Retaining 510. ## Identifying merge groups with Jaccard >= 0.75... ## Found 0 merge groups. Merging 0 complexes into 510. ## Merging complete. Final list has 510 complexes. ##  ## --- Refinement Complete --- # Let's see how many complexes we have now length(refinedComplexes) ## [1] 510"},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_01-workflow.html","id":"step-4-functional-enrichment","dir":"Articles","previous_headings":"","what":"Step 4: Functional Enrichment","title":"Analyzing a Human Protein Complex Map","text":"understand biological role complex, can perform functional enrichment analysis. first need gene set database, BioCarta pathways. package includes helper function access example GMT file. analysis found significant terms 239 refined complexes. output list element data frame significant functional terms corresponding complex.","code":"# Get the path to the example GMT file gmtPath <- getExampleGmt() biocartaGmt <- getGmtFromFile(gmtPath) ## Fetching gene sets from local file: /private/var/folders/gb/q0_2jm654r9_t3r2hb11v3tm0000gn/T/Rtmpx4UtqW/temp_libpath4393b14db1b/ComplexMap/extdata/c2.cp.biocarta.v2025.1.Hs.symbols.gmt # Run enrichment analysis on the refined complex list enrichments <- runComplexEnrichment(refinedComplexes, biocartaGmt) ## Running enrichment for 510 complexes... ## Annotation complete. Found terms for 239 complexes. # View the enrichment results for the first complex with significant terms if (length(enrichments) > 0) {   head(enrichments[]) } ## $CpxMap_0006 ##                            ID                 Description   p.adjust Count ## 1 BIOCARTA_EICOSANOID_PATHWAY BIOCARTA_EICOSANOID_PATHWAY 0.01457919     1 ##   Ratio     Fold ## 1     1 68.59091 ##  ## $CpxMap_0008 ##                         ID              Description   p.adjust Count Ratio ## 1     BIOCARTA_EPO_PATHWAY     BIOCARTA_EPO_PATHWAY 0.02208968     1     1 ## 2      BIOCARTA_GH_PATHWAY      BIOCARTA_GH_PATHWAY 0.02236581     1     1 ## 3   BIOCARTA_IL2RB_PATHWAY   BIOCARTA_IL2RB_PATHWAY 0.02451955     1     1 ## 4     BIOCARTA_IL3_PATHWAY     BIOCARTA_IL3_PATHWAY 0.02208968     1     1 ## 5 BIOCARTA_NKCELLS_PATHWAY BIOCARTA_NKCELLS_PATHWAY 0.02208968     1     1 ##        Fold ## 1  79.42105 ## 2  55.88889 ## 3  40.78378 ## 4 100.60000 ## 5  75.45000 ##  ## $CpxMap_0011 ##                     ID          Description    p.adjust Count Ratio     Fold ## 1 BIOCARTA_RAB_PATHWAY BIOCARTA_RAB_PATHWAY 0.008614977     1     1 116.0769 ##  ## $CpxMap_0012 ##                    ID         Description   p.adjust Count Ratio   Fold ## 1 BIOCARTA_G2_PATHWAY BIOCARTA_G2_PATHWAY 0.01590457     1     1 62.875 ##  ## $CpxMap_0017 ##                              ID                   Description   p.adjust Count ## 1      BIOCARTA_CASPASE_PATHWAY      BIOCARTA_CASPASE_PATHWAY 0.04430150     1 ## 2        BIOCARTA_DEATH_PATHWAY        BIOCARTA_DEATH_PATHWAY 0.04430150     1 ## 3  BIOCARTA_DNAFRAGMENT_PATHWAY  BIOCARTA_DNAFRAGMENT_PATHWAY 0.03964278     1 ## 4          BIOCARTA_FAS_PATHWAY          BIOCARTA_FAS_PATHWAY 0.04430150     1 ## 5 BIOCARTA_MITOCHONDRIA_PATHWAY BIOCARTA_MITOCHONDRIA_PATHWAY 0.04430150     1 ## 6       BIOCARTA_PARKIN_PATHWAY       BIOCARTA_PARKIN_PATHWAY 0.03964278     1 ## 7          BIOCARTA_SET_PATHWAY          BIOCARTA_SET_PATHWAY 0.03964278     1 ## 8        BIOCARTA_TNFR1_PATHWAY        BIOCARTA_TNFR1_PATHWAY 0.04430150     1 ##   Ratio     Fold ## 1   0.5 34.29545 ## 2   0.5 26.01724 ## 3   0.5 75.45000 ## 4   0.5 25.15000 ## 5   0.5 39.71053 ## 6   0.5 94.31250 ## 7   0.5 75.45000 ## 8   0.5 26.01724 ##  ## $CpxMap_0020 ##                     ID          Description   p.adjust Count Ratio     Fold ## 1 BIOCARTA_TEL_PATHWAY BIOCARTA_TEL_PATHWAY 0.01126574     1     1 88.76471"},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_01-workflow.html","id":"step-5-building-the-complex-network","dir":"Articles","previous_headings":"","what":"Step 5: Building the Complex Network","title":"Analyzing a Human Protein Complex Map","text":"visualize relationships complexes, build similarity network. edge drawn two complexes similar, either sharing proteins (compositional similarity) sharing functions (functional similarity). buildComplexNetwork() function calculates similarities creates edge list. ’ll use “combined” mode, creates weighted average similarity types. resulting tibble contains 1390 edges, calculated similarity scores final weight used visualization.","code":"networkEdges <- buildComplexNetwork(   complexes = refinedComplexes,   enrichments = enrichments,   mode = \"combined\",   similarityMethod = \"jaccard\" ) ## Building complex network using 'jaccard' similarity... ## Using 7 cores for parallel processing. ## Processing 129795 complex pairs... ## Split into 130 chunks of up to 1000 pairs each. ## Combining results from chunks... ## Calculating final weights and filtering... ## Network construction complete: 1390 edges retained. glimpse(networkEdges) ## Rows: 1,390 ## Columns: 8 ## $ source_complex_id <chr> \"CpxMap_0005\", \"CpxMap_0006\", \"CpxMap_0008\", \"CpxMap… ## $ target_complex_id <chr> \"CpxMap_0453\", \"CpxMap_0356\", \"CpxMap_0090\", \"CpxMap… ## $ compSim           <dbl> 0.09090909, 0.00000000, 0.00000000, 0.00000000, 0.00… ## $ funcSim           <dbl> 0.00000000, 0.05555556, 0.04166667, 0.20000000, 0.36… ## $ sharedProt        <int> 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0… ## $ sharedFunc        <int> 0, 1, 1, 1, 4, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1… ## $ weight            <dbl> 0.04545455, 0.02777778, 0.02083333, 0.10000000, 0.18… ## $ similarity_mode   <chr> \"combined\", \"combined\", \"combined\", \"combined\", \"com…"},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_01-workflow.html","id":"step-6-generating-node-attributes-for-visualization","dir":"Articles","previous_headings":"","what":"Step 6: Generating Node Attributes for Visualization","title":"Analyzing a Human Protein Complex Map","text":"plotting, need generate attributes node (complex) network, size, color, primary functional label. generateNodeAttributes() function designed . clusters enriched terms “functional domains” calculates unique “blended” color complex based functional profile.","code":"nodeAttributes <- generateNodeAttributes(   complexes = refinedComplexes,   enrichments = enrichments ) ## Generating core node attributes (function and color)... ##     -> Clustering terms using 'jaccard' similarity. ## Metric: 'jaccard' with unit: 'log'; comparing: 231 vectors glimpse(nodeAttributes) ## Rows: 510 ## Columns: 7 ## $ complexId               <chr> \"CpxMap_0001\", \"CpxMap_0002\", \"CpxMap_0003\", \"… ## $ proteinCount            <int> 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3… ## $ proteins                <chr> \"WDR82,ULK3,UCHL1\", \"PPP1R8,PPP1CC,NF2\", \"IFT8… ## $ primaryFunctionalDomain <chr> \"Unenriched\", \"Unenriched\", \"Unenriched\", \"Une… ## $ topEnrichedFunctions    <chr> NA, NA, NA, NA, NA, \"BIOCARTA_EICOSANOID_PATHW… ## $ colorHex                <chr> \"#CCCCCC\", \"#CCCCCC\", \"#CCCCCC\", \"#CCCCCC\", \"#… ## $ sizeMapping             <dbl> 1.584963, 1.584963, 1.584963, 1.584963, 1.5849…"},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_01-workflow.html","id":"step-7-computing-network-topology","dir":"Articles","previous_headings":"","what":"Step 7: Computing Network Topology","title":"Analyzing a Human Protein Complex Map","text":"nodes edges defined, final step plotting calculate network layout. computeMapTopology() function uses force-directed algorithm determine (x, y) coordinates node calculates centrality metrics like degree betweenness. mapLayout data frame now “master” table, containing information needed plotting.","code":"mapLayout <- computeMapTopology(nodeAttributes, networkEdges) ## Computing map topology (layout and centrality)... ## Topology computation complete. glimpse(mapLayout) ## Rows: 510 ## Columns: 11 ## $ complexId               <chr> \"CpxMap_0359\", \"CpxMap_0414\", \"CpxMap_0508\", \"… ## $ proteinCount            <int> 5, 8, 42, 6, 102, 4, 40, 40, 4, 9, 4, 20, 15, … ## $ proteins                <chr> \"PRKACB,PRKACA,PRKAR2A,CIRBP,CAPRIN1\", \"WDR3,R… ## $ primaryFunctionalDomain <chr> \"BIOCARTA_EICOSANOID_PATHWAY\", \"BIOCARTA_EICOS… ## $ topEnrichedFunctions    <chr> \"BIOCARTA_AGPCR_PATHWAY, BIOCARTA_AKAP13_PATHW… ## $ colorHex                <chr> \"#E41A1C\", \"#E41A1C\", \"#CCCCCC\", \"#E41A1C\", \"#… ## $ sizeMapping             <dbl> 2.321928, 3.000000, 5.392317, 2.584963, 6.6724… ## $ x                       <dbl> 7.9898939, 6.7094059, -3.2063886, 10.0283948, … ## $ y                       <dbl> 6.1280771, 5.0562320, 2.5393381, 4.6364274, -0… ## $ betweenness             <dbl> 0.15447148, 0.13644942, 0.11128815, 0.10030088… ## $ degree                  <dbl> 33, 45, 20, 28, 22, 41, 19, 7, 26, 13, 22, 27,…"},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_01-workflow.html","id":"step-8-visualization","dir":"Articles","previous_headings":"","what":"Step 8: Visualization","title":"Analyzing a Human Protein Complex Map","text":"ComplexMap provides three ways visualize final network.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_01-workflow.html","id":"static-plot-with-direct-labels","dir":"Articles","previous_headings":"Step 8: Visualization","what":"8.1 Static Plot with Direct Labels","title":"Analyzing a Human Protein Complex Map","text":"plot excellent publications, labels placed directly onto plot.","code":"# ggrepel is required for this plot if (requireNamespace(\"ggrepel\", quietly = TRUE)) {   visualizeMapDirectLabels(mapLayout, networkEdges) } ## Visualizing ComplexMap with direct labels..."},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_01-workflow.html","id":"static-plot-with-a-legend","dir":"Articles","previous_headings":"Step 8: Visualization","what":"8.2 Static Plot with a Legend","title":"Analyzing a Human Protein Complex Map","text":"version useful direct labels cluttered. uses discrete color legend represent functional domains.","code":"visualizeMapWithLegend(mapLayout, networkEdges) ## Visualizing ComplexMap with a color legend..."},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_01-workflow.html","id":"interactive-plot","dir":"Articles","previous_headings":"Step 8: Visualization","what":"8.3 Interactive Plot","title":"Analyzing a Human Protein Complex Map","text":"deep exploration, interactive HTML widget ideal. can zoom, pan, hover nodes see detailed tooltips.","code":"# visNetwork is required for this plot if (requireNamespace(\"visNetwork\", quietly = TRUE)) {   visualizeMapInteractive(mapLayout, networkEdges) } ## Generating interactive visNetwork plot..."},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_01-workflow.html","id":"conclusion","dir":"Articles","previous_headings":"","what":"Conclusion","title":"Analyzing a Human Protein Complex Map","text":"vignette demonstrated full workflow ComplexMap package, raw complex list insightful, publication-quality visualizations. integrating quality control, refinement, enrichment, network analysis, ComplexMap provides powerful user-friendly platform exploring landscape protein complexes.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Qingzhou Zhang. Author, maintainer.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Zhang Q (2025). ComplexMap: Toolset Functional Analysis Visualization Protein Complex Data. R package version 0.99.0, https://zqzneptune.github.io/ComplexMap.","code":"@Manual{,   title = {ComplexMap: A Toolset for the Functional Analysis and Visualization of Protein Complex Data},   author = {Qingzhou Zhang},   year = {2025},   note = {R package version 0.99.0},   url = {https://zqzneptune.github.io/ComplexMap}, }"},{"path":"https://zqzneptune.github.io/ComplexMap/index.html","id":"complexmap-","dir":"","previous_headings":"","what":"A Toolset for the Functional Analysis and Visualization of Protein Complex Data","title":"A Toolset for the Functional Analysis and Visualization of Protein Complex Data","text":"ComplexMap provides comprehensive workflow quality control, refinement, functional enrichment, network-based analysis protein complex datasets. allows quantitative evaluation predicted complexes reference provides powerful static interactive visualization methods explore functional landscape protein complex map. package designed guide user raw list putative protein complexes functionally annotated, publication-quality network visualization.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"A Toolset for the Functional Analysis and Visualization of Protein Complex Data","text":"can install development version ComplexMap GitHub.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/index.html","id":"id_1-prerequisite-dependencies","dir":"","previous_headings":"Installation","what":"1. Prerequisite Dependencies","title":"A Toolset for the Functional Analysis and Visualization of Protein Complex Data","text":"installing ComplexMap, must first install dependencies CRAN Bioconductor.","code":"# Install dependencies from CRAN install.packages(c(     \"dplyr\", \"tibble\", \"magrittr\", \"rlang\", \"stringr\", \"Matrix\",      \"igraph\", \"ggraph\", \"tidygraph\", \"ggplot2\", \"ggrepel\",      \"RColorBrewer\", \"scales\", \"clue\", \"future\", \"future.apply\",      \"philentropy\", \"visNetwork\", \"devtools\" ))  # Install dependencies from Bioconductor if (!require(\"BiocManager\", quietly = TRUE))     install.packages(\"BiocManager\")  BiocManager::install(c(     \"msigdbr\", \"AnnotationDbi\", \"GO.db\", \"reactome.db\",      \"org.Hs.eg.db\" # Example organism database ))"},{"path":"https://zqzneptune.github.io/ComplexMap/index.html","id":"id_2-main-package-installation","dir":"","previous_headings":"Installation","what":"2. Main Package Installation","title":"A Toolset for the Functional Analysis and Visualization of Protein Complex Data","text":"dependencies installed, can install ComplexMap directly zqzneptune GitHub repository.","code":"devtools::install_github(\"zqzneptune/ComplexMap\")"},{"path":"https://zqzneptune.github.io/ComplexMap/index.html","id":"a-quick-example","dir":"","previous_headings":"","what":"A Quick Example","title":"A Toolset for the Functional Analysis and Visualization of Protein Complex Data","text":"minimal example showing core workflow: list complexes functional network map. detailed walkthrough, please see package vignette: browseVignettes(\"ComplexMap\").","code":"library(ComplexMap)  # 1. Load the example complex list and a GMT for enrichment data(\"demoComplexes\") gmtPath <- getExampleGmt() gmt <- getGmtFromFile(gmtPath)  # 2. Refine the list (merge redundant complexes) refinedComplexes <- refineComplexList(demoComplexes, mergeThreshold = 0.75, verbose = FALSE)  # 3. Perform functional enrichment enrichments <- runComplexEnrichment(refinedComplexes, gmt, verbose = FALSE)  # 4. Build the network networkEdges <- buildComplexNetwork(refinedComplexes, enrichments, verbose = FALSE)  # 5. Generate node attributes and layout for plotting nodeAttributes <- generateNodeAttributes(refinedComplexes, enrichments, verbose = FALSE) mapLayout <- computeMapTopology(nodeAttributes, networkEdges, verbose = FALSE)  # 6. Visualize the final map with a legend  # visualizeMapWithLegend(mapLayout, networkEdges, verbose = FALSE)"},{"path":"https://zqzneptune.github.io/ComplexMap/reference/buildComplexNetwork.html","id":null,"dir":"Reference","previous_headings":"","what":"Build a Complex-Complex Interaction Network — buildComplexNetwork","title":"Build a Complex-Complex Interaction Network — buildComplexNetwork","text":"Constructs network complexes edges represent similarity. similarity can based shared proteins (compositional), shared functional annotations (functional), weighted combination .","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/buildComplexNetwork.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Build a Complex-Complex Interaction Network — buildComplexNetwork","text":"","code":"buildComplexNetwork(   complexes,   enrichments,   mode = \"functional\",   similarityMethod = \"jaccard\",   alpha = 0.5,   nCores = NULL,   chunkSize = 1000,   verbose = TRUE )"},{"path":"https://zqzneptune.github.io/ComplexMap/reference/buildComplexNetwork.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Build a Complex-Complex Interaction Network — buildComplexNetwork","text":"complexes named list protein complexes. enrichments named list enrichment results, corresponding `complexes`. Typically output `runComplexEnrichment`. mode character string specifying calculate final edge weight. One \"functional\", \"compositional\", \"combined\". similarityMethod metric used compositional functional similarity. One \"jaccard\", \"overlap\", \"dice\". alpha numeric value (0-1) used \"combined\" mode weigh compositional similarity score. nCores number CPU cores parallel processing. Defaults one less available. chunkSize number complex pairs process parallel chunk. verbose logical value indicating whether show progress messages progress bar.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/buildComplexNetwork.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Build a Complex-Complex Interaction Network — buildComplexNetwork","text":"`tibble` representing network edges. row includes source target_complex_id  complexes, similarity scores, shared component counts, final calculated `weight`, `similarity_mode`.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/buildComplexNetwork.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Build a Complex-Complex Interaction Network — buildComplexNetwork","text":"function calculates pairwise similarities complexes list. highly optimized large datasets using chunking parallel processing via `future` framework. final edge weight determined `mode`: - `\"compositional\"`: Uses protein similarity score. - `\"functional\"`: Uses functional annotation similarity score. - `\"combined\"`: Uses weighted average:   `alpha * compositional + (1 - alpha) * functional`. `progressr` package installed, progress bar displayed parallel computation `verbose = TRUE`.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/buildComplexNetwork.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Build a Complex-Complex Interaction Network — buildComplexNetwork","text":"Qingzhou Zhang <zqzneptune@hotmail.com>","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/buildComplexNetwork.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Build a Complex-Complex Interaction Network — buildComplexNetwork","text":"","code":"# --- Sample Data (from previous examples) --- complexes <- list(   Cpx1 = c(\"A\", \"B\", \"C\", \"D\"),   Cpx2 = c(\"A\", \"B\", \"C\", \"E\"), # similar to Cpx1   Cpx3 = c(\"F\", \"G\", \"H\") ) enrichments <- list(   Cpx1 = data.frame(ID = c(\"GO:1\", \"GO:2\")),   Cpx2 = data.frame(ID = c(\"GO:1\", \"GO:3\")), # functionally similar to Cpx1   Cpx3 = data.frame(ID = c(\"GO:4\")) )  # --- Build Network (using 2 cores for the example) --- network <- buildComplexNetwork(   complexes, enrichments, mode = \"combined\", nCores = 2 ) #> Building complex network using 'jaccard' similarity... #> Using 2 cores for parallel processing. #> Processing 3 complex pairs... #> Split into 1 chunks of up to 1000 pairs each. #> Combining results from chunks... #> Calculating final weights and filtering... #> Network construction complete: 1 edges retained. print(network) #> # A tibble: 1 × 8 #>   source_complex_id target_complex_id compSim funcSim sharedProt sharedFunc #>   <chr>             <chr>               <dbl>   <dbl>      <int>      <int> #> 1 Cpx1              Cpx2                  0.6   0.333          3          1 #> # ℹ 2 more variables: weight <dbl>, similarity_mode <chr>"},{"path":"https://zqzneptune.github.io/ComplexMap/reference/computeMapTopology.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Network Topology and Layout Coordinates — computeMapTopology","title":"Compute Network Topology and Layout Coordinates — computeMapTopology","text":"Calculates 2D layout coordinates key centrality metrics complex network. function serves final step preparing network data visualization.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/computeMapTopology.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute Network Topology and Layout Coordinates — computeMapTopology","text":"","code":"computeMapTopology(nodeAttributes, network, verbose = TRUE)"},{"path":"https://zqzneptune.github.io/ComplexMap/reference/computeMapTopology.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute Network Topology and Layout Coordinates — computeMapTopology","text":"nodeAttributes `tibble` `data.frame` containing attributes node (complex). Must contain column node identifiers matches source/target columns `network` data. network `tibble` `data.frame` representing network edges. Must contain columns source, target, edge `weight`. verbose logical value indicating whether print progress messages. Defaults `TRUE`.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/computeMapTopology.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute Network Topology and Layout Coordinates — computeMapTopology","text":"`tibble` containing original columns `nodeAttributes` plus four new columns: `x`, `y` (layout coordinates), `betweenness`, `degree`. table arranged descending order betweenness degree.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/computeMapTopology.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute Network Topology and Layout Coordinates — computeMapTopology","text":"function takes node attribute table edge list (network) performs following steps: 1.  Constructs `igraph` graph object provided data. 2.  Computes force-directed layout using Fruchterman-Reingold algorithm     via `ggraph::create_layout`. Edge weights used influence     layout, pulling strongly connected nodes closer together. 3.  Calculates node centrality metrics:     - **Betweenness Centrality:** Measures often node lies       shortest path nodes (normalized).     - **Degree Centrality:** number edges connected node. 4.  Merges layout coordinates centrality scores back original     node attribute table.","code":""},{"path":[]},{"path":"https://zqzneptune.github.io/ComplexMap/reference/computeMapTopology.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Compute Network Topology and Layout Coordinates — computeMapTopology","text":"Qingzhou Zhang <zqzneptune@hotmail.com>","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/computeMapTopology.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute Network Topology and Layout Coordinates — computeMapTopology","text":"","code":"# --- Sample Data --- # 1. Node attributes nodes <- tibble::tibble(   complexId = c(\"Cpx1\", \"Cpx2\", \"Cpx3\"),   proteinCount = c(10, 8, 12) )  # 2. Network edges net <- tibble::tibble(   source = c(\"Cpx1\", \"Cpx2\"),   target = c(\"Cpx2\", \"Cpx3\"),   weight = c(0.8, 0.6) )  # --- Compute Topology --- masterLayout <- computeMapTopology(nodes, net) #> Computing map topology (layout and centrality)... #> Topology computation complete. print(masterLayout) #> # A tibble: 3 × 6 #>   complexId proteinCount     x        y betweenness degree #>   <chr>            <dbl> <dbl>    <dbl>       <dbl>  <dbl> #> 1 Cpx2                 8 -3.25  0.00972           1      2 #> 2 Cpx1                10 -2.42  0.925             0      1 #> 3 Cpx3                12 -4.16 -1.00              0      1"},{"path":"https://zqzneptune.github.io/ComplexMap/reference/demoComplexes.html","id":null,"dir":"Reference","previous_headings":"","what":"Example Protein Complex List — demoComplexes","title":"Example Protein Complex List — demoComplexes","text":"dataset containing list 622 putative protein complexes identified study using integrative global proteomic profiling approach. dataset intended use package examples vignettes.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/demoComplexes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Example Protein Complex List — demoComplexes","text":"","code":"demoComplexes"},{"path":"https://zqzneptune.github.io/ComplexMap/reference/demoComplexes.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Example Protein Complex List — demoComplexes","text":"named list 622 elements. element character vector protein identifiers representing single complex.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/demoComplexes.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Example Protein Complex List — demoComplexes","text":"Supplementary Table 3 (first tab) : Havugimana PC, Hart GT, Nepusz T, Yang H, Turinsky AL, Li Z, Wang PI, Boutz DR, Fong V, Phanse S, Babu M, Craig SA, Hu P, Wan C, Vlasblom J, Dar VU, Bezginov , Clark GW, Wu GC, Wodak SJ, Tillier ER, Paccanaro , Marcotte EM, Emili . *census human soluble protein complexes.* Cell. 2012 Aug 31;150(5):1068-81. doi: 10.1016/j.cell.2012.08.011. PMID: 22939629; PMCID: PMC3477804.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/demoComplexes.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Example Protein Complex List — demoComplexes","text":"complexes derived chromatographic separation cultured human cell extracts one thousand biochemical fractions, followed quantitative tandem mass spectrometry analysis. 622 complexes linked core biological processes include candidate disease genes unannotated proteins.","code":""},{"path":[]},{"path":"https://zqzneptune.github.io/ComplexMap/reference/dot-calculateSimilarity.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate a Similarity Score Between Two Sets — .calculateSimilarity","title":"Calculate a Similarity Score Between Two Sets — .calculateSimilarity","text":"internal helper function computes one three common similarity metrics: Jaccard, Overlap, Dice.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/dot-calculateSimilarity.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate a Similarity Score Between Two Sets — .calculateSimilarity","text":"","code":".calculateSimilarity(set1, set2, method = \"jaccard\")"},{"path":"https://zqzneptune.github.io/ComplexMap/reference/dot-calculateSimilarity.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate a Similarity Score Between Two Sets — .calculateSimilarity","text":"set1 character vector representing first set. set2 character vector representing second set. method similarity metric use. One \"jaccard\", \"overlap\", \"dice\".","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/dot-calculateSimilarity.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate a Similarity Score Between Two Sets — .calculateSimilarity","text":"numeric similarity score 0 1. Returns 0 either   set empty intersection.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/evaluateComplexes.html","id":null,"dir":"Reference","previous_headings":"","what":"Evaluate Predicted Protein Complexes Against a Reference Set — evaluateComplexes","title":"Evaluate Predicted Protein Complexes Against a Reference Set — evaluateComplexes","text":"Calculates four standard metrics evaluating protein complex predictions: Positive Predictive Value (PPV), Sensitivity (Sn), Accuracy (Acc), Maximum Matching Ratio (MMR).","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/evaluateComplexes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Evaluate Predicted Protein Complexes Against a Reference Set — evaluateComplexes","text":"","code":"evaluateComplexes(   predictedComplexes,   referenceComplexes,   nCores = NULL,   verbose = TRUE )"},{"path":"https://zqzneptune.github.io/ComplexMap/reference/evaluateComplexes.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Evaluate Predicted Protein Complexes Against a Reference Set — evaluateComplexes","text":"predictedComplexes list predicted protein complexes. referenceComplexes list reference (gold standard) complexes. nCores number CPU cores use parallel computation. Defaults one less total number detected cores. verbose logical value indicating whether print progress messages. Defaults `TRUE`.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/evaluateComplexes.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Evaluate Predicted Protein Complexes Against a Reference Set — evaluateComplexes","text":"named list containing four numeric values: `PPV`, `Sn`, `Acc`, `MMR`. Returns `NA` metrics either input list empty.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/evaluateComplexes.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Evaluate Predicted Protein Complexes Against a Reference Set — evaluateComplexes","text":"function optimized speed calculating shared intersection matrix predicted reference complexes parallel. matrix used basis four metric calculations. - **PPV, Sn, Acc** calculated based confusion matrix   predicted reference complexes, described literature. - **MMR** calculated first deriving overlap score matrix,   entry `(, j)` `|intersection_ij|^2 / (|pred_i| * |ref_j|)`.   [Hungarian algorithm](https://en.wikipedia.org/wiki/Hungarian_algorithm)   used solve maximum weight bipartite matching problem,   finding optimal one--one mapping predicted reference sets. parallel computation uses `parallel::mclapply`, available Windows. Windows, calculation run sequentially. cross-platform parallel execution package, consider using `BiocParallel` package.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/evaluateComplexes.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Evaluate Predicted Protein Complexes Against a Reference Set — evaluateComplexes","text":"Qingzhou Zhang <zqzneptune@hotmail.com>","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/evaluateComplexes.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Evaluate Predicted Protein Complexes Against a Reference Set — evaluateComplexes","text":"","code":"# --- Sample Data --- # Predicted complexes pred1 <- c(\"A\", \"B\", \"C\") pred2 <- c(\"D\", \"E\", \"F\") pred3 <- c(\"A\", \"G\", \"H\") predicted <- list(P1 = pred1, P2 = pred2, P3 = pred3)  # Reference complexes (gold standard) ref1 <- c(\"A\", \"B\", \"C\", \"X\") # Good match for pred1 ref2 <- c(\"D\", \"E\", \"F\")     # Perfect match for pred2 ref3 <- c(\"I\", \"J\", \"K\")     # Unmatched complex reference <- list(R1 = ref1, R2 = ref2, R3 = ref3)  # --- Evaluation --- # Use 2 cores for the example metrics <- evaluateComplexes(predicted, reference, nCores = 2) #>  #> --- Evaluating Complex Predictions --- #> [1] Calculating intersections using 2 core(s)... #> [2] Calculating PPV, Sensitivity, and Accuracy... #> [3] Calculating Maximum Matching Ratio (MMR)... #>  #> --- Evaluation Complete --- print(metrics) #> $PPV #> [1] 1 #>  #> $Sn #> [1] 0.6 #>  #> $Acc #> [1] 0.7745967 #>  #> $MMR #> [1] 0.5833333 #>"},{"path":"https://zqzneptune.github.io/ComplexMap/reference/generateNodeAttributes.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate Node Attributes for a Complex Network — generateNodeAttributes","title":"Generate Node Attributes for a Complex Network — generateNodeAttributes","text":"Creates detailed attribute table complex, suitable network visualization. Attributes include protein count, primary functional domain, top enriched functions, unique color representing complex's functional profile.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/generateNodeAttributes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate Node Attributes for a Complex Network — generateNodeAttributes","text":"","code":"generateNodeAttributes(   complexes,   enrichments,   similarityMethod = \"jaccard\",   verbose = TRUE )"},{"path":"https://zqzneptune.github.io/ComplexMap/reference/generateNodeAttributes.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate Node Attributes for a Complex Network — generateNodeAttributes","text":"complexes named list protein complexes. enrichments named list enrichment results, typically `runComplexEnrichment`. element data frame least `ID`, `Description`, `p.adjust` columns. similarityMethod distance/similarity method passed `philentropy::distance` clustering terms. Defaults \"jaccard\". verbose logical value indicating whether print progress messages. Defaults `TRUE`.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/generateNodeAttributes.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate Node Attributes for a Complex Network — generateNodeAttributes","text":"`tibble` row corresponds complex. columns include: `complexId`, `proteinCount`, `proteins`, `primaryFunctionalDomain`, `topEnrichedFunctions`, `colorHex`, `sizeMapping`.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/generateNodeAttributes.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate Node Attributes for a Complex Network — generateNodeAttributes","text":"function performs several steps generate rich node attributes: 1.  aggregates enriched terms input `enrichments` list. 2.  term-complex matrix built, terms clustered based     co-occurrence complexes using specified similarity metric.     groups related functional terms \"functional domains\". 3.  unique color assigned functional domain using qualitative     palette `RColorBrewer`. 4.  complex, determines primary functional domain based     significant enriched term. 5.  unique \"blended\" color calculated complex mixing     colors associated domains, weighted significance     (-log10 p-value) enriched terms. 6.  Basic attributes like protein count list proteins also included. Complexes significant enrichments assigned default \"Unenriched\" domain grey color.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/generateNodeAttributes.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Generate Node Attributes for a Complex Network — generateNodeAttributes","text":"Qingzhou Zhang <zqzneptune@hotmail.com>","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/generateNodeAttributes.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate Node Attributes for a Complex Network — generateNodeAttributes","text":"","code":"# --- Sample Data --- complexes <- list(   Cpx1 = c(\"A\", \"B\", \"C\"),   Cpx2 = c(\"C\", \"D\", \"E\"),   Cpx3 = c(\"F\", \"G\") # Unenriched ) enrichments <- list(   Cpx1 = data.frame(ID = \"GO:1\", Description = \"Term A\", p.adjust = 0.01),   Cpx2 = data.frame(ID = \"GO:2\", Description = \"Term B\", p.adjust = 0.02) )  # --- Generate Node Attributes --- nodeAttrs <- generateNodeAttributes(complexes, enrichments) #> Generating core node attributes (function and color)... #>     -> Clustering terms using 'jaccard' similarity. #> Metric: 'jaccard' with unit: 'log'; comparing: 2 vectors print(nodeAttrs) #> # A tibble: 3 × 7 #>   complexId proteinCount proteins primaryFunctionalDomain topEnrichedFunctions #>   <chr>            <int> <chr>    <chr>                   <chr>                #> 1 Cpx1                 3 A,B,C    Term A                  Term A               #> 2 Cpx2                 3 C,D,E    Term B                  Term B               #> 3 Cpx3                 2 F,G      Unenriched              NA                   #> # ℹ 2 more variables: colorHex <chr>, sizeMapping <dbl>"},{"path":"https://zqzneptune.github.io/ComplexMap/reference/getExampleGmt.html","id":null,"dir":"Reference","previous_headings":"","what":"Get the Path to an Example GMT File — getExampleGmt","title":"Get the Path to an Example GMT File — getExampleGmt","text":"Provides full system path example gene set (GMT) file included ComplexMap package.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/getExampleGmt.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get the Path to an Example GMT File — getExampleGmt","text":"","code":"getExampleGmt()"},{"path":"https://zqzneptune.github.io/ComplexMap/reference/getExampleGmt.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get the Path to an Example GMT File — getExampleGmt","text":"character string containing full path example GMT file.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/getExampleGmt.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Get the Path to an Example GMT File — getExampleGmt","text":"included file BioCarta gene set collection Molecular Signatures Database (MSigDB v2025.1). function makes easy access file use examples vignettes.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/getExampleGmt.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get the Path to an Example GMT File — getExampleGmt","text":"","code":"# Get the path gmtPath <- getExampleGmt()  # You can then read the file using the path if (file.exists(gmtPath)) {   exampleGmt <- getGmtFromFile(gmtPath) } #> Fetching gene sets from local file: /private/var/folders/gb/q0_2jm654r9_t3r2hb11v3tm0000gn/T/Rtmpx4UtqW/temp_libpath4393b14db1b/ComplexMap/extdata/c2.cp.biocarta.v2025.1.Hs.symbols.gmt"},{"path":"https://zqzneptune.github.io/ComplexMap/reference/getGmtFromFile.html","id":null,"dir":"Reference","previous_headings":"","what":"Read a GMT File from a Local Path — getGmtFromFile","title":"Read a GMT File from a Local Path — getGmtFromFile","text":"Parses local GMT (Gene Matrix Transposed) file standard named-list format.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/getGmtFromFile.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Read a GMT File from a Local Path — getGmtFromFile","text":"","code":"getGmtFromFile(filepath)"},{"path":"https://zqzneptune.github.io/ComplexMap/reference/getGmtFromFile.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Read a GMT File from a Local Path — getGmtFromFile","text":"filepath path local .gmt file.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/getGmtFromFile.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Read a GMT File from a Local Path — getGmtFromFile","text":"named list names gene set names values character   vectors genes.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/getGoGmt.html","id":null,"dir":"Reference","previous_headings":"","what":"Fetch Gene Ontology (GO) Gene Sets — getGoGmt","title":"Fetch Gene Ontology (GO) Gene Sets — getGoGmt","text":"Fetches GO terms associated genes Bioconductor AnnotationDb package.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/getGoGmt.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fetch Gene Ontology (GO) Gene Sets — getGoGmt","text":"","code":"getGoGmt(speciesDb, ontology = \"BP\", minGmtSize = 10, maxGmtSize = 500)"},{"path":"https://zqzneptune.github.io/ComplexMap/reference/getGoGmt.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fetch Gene Ontology (GO) Gene Sets — getGoGmt","text":"speciesDb AnnotationDb object target species (e.g., `org.Hs.eg.db`). ontology GO ontology fetch. One \"BP\", \"MF\", \"CC\". minGmtSize minimum number genes GO term included. maxGmtSize maximum number genes GO term included.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/getGoGmt.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fetch Gene Ontology (GO) Gene Sets — getGoGmt","text":"named list names GO terms values character   vectors Entrez IDs.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/getMsigdbGmt.html","id":null,"dir":"Reference","previous_headings":"","what":"Fetch Gene Sets from MSigDB — getMsigdbGmt","title":"Fetch Gene Sets from MSigDB — getMsigdbGmt","text":"wrapper `msigdbr::msigdbr` fetch gene sets format named list (GMT format).","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/getMsigdbGmt.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fetch Gene Sets from MSigDB — getMsigdbGmt","text":"","code":"getMsigdbGmt(species = \"Homo sapiens\", collection = \"H\")"},{"path":"https://zqzneptune.github.io/ComplexMap/reference/getMsigdbGmt.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fetch Gene Sets from MSigDB — getMsigdbGmt","text":"species scientific name species (e.g., \"Homo sapiens\"). collection MSigDB collection code (e.g., \"H\" hallmark).","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/getMsigdbGmt.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fetch Gene Sets from MSigDB — getMsigdbGmt","text":"named list names gene set names values character   vectors gene symbols.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/getReactomeGmt.html","id":null,"dir":"Reference","previous_headings":"","what":"Fetch Reactome Pathway Gene Sets — getReactomeGmt","title":"Fetch Reactome Pathway Gene Sets — getReactomeGmt","text":"Fetches Reactome pathways associated genes `reactome.db` Bioconductor annotation package.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/getReactomeGmt.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fetch Reactome Pathway Gene Sets — getReactomeGmt","text":"","code":"getReactomeGmt(speciesDb)"},{"path":"https://zqzneptune.github.io/ComplexMap/reference/getReactomeGmt.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fetch Reactome Pathway Gene Sets — getReactomeGmt","text":"speciesDb AnnotationDb object target species (e.g., `org.Hs.eg.db`). used filter pathways correct species.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/getReactomeGmt.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fetch Reactome Pathway Gene Sets — getReactomeGmt","text":"named list names Reactome pathway names values   character vectors Entrez IDs.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/pipe.html","id":null,"dir":"Reference","previous_headings":"","what":"Pipe operator — %>%","title":"Pipe operator — %>%","text":"See magrittr::%>% details.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/pipe.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pipe operator — %>%","text":"","code":"lhs %>% rhs"},{"path":"https://zqzneptune.github.io/ComplexMap/reference/qcComplexList.html","id":null,"dir":"Reference","previous_headings":"","what":"Perform Quality Control on a List of Protein Complexes — qcComplexList","title":"Perform Quality Control on a List of Protein Complexes — qcComplexList","text":"function performs quality control analysis list protein complexes. provides basic statistics, analyzes distribution complex sizes, calculates pairwise redundancy using Jaccard similarity index.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/qcComplexList.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Perform Quality Control on a List of Protein Complexes — qcComplexList","text":"","code":"qcComplexList(complexList, redundancyThreshold = 0.8, verbose = TRUE)"},{"path":"https://zqzneptune.github.io/ComplexMap/reference/qcComplexList.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Perform Quality Control on a List of Protein Complexes — qcComplexList","text":"complexList list element character vector protein identifiers representing complex. redundancyThreshold numeric value 0 1. warning issued pair complexes Jaccard similarity score greater equal threshold. Defaults 0.8. verbose logical value indicating whether print progress messages summaries console. Defaults `TRUE`.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/qcComplexList.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Perform Quality Control on a List of Protein Complexes — qcComplexList","text":"Invisibly returns original `complexList` object, allowing used pipeline.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/qcComplexList.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Perform Quality Control on a List of Protein Complexes — qcComplexList","text":"QC process involves three main steps: 1.  **Basic Statistics:** Reports total number complexes unique     proteins list. 2.  **Size Distribution:** Provides summary number proteins per     complex warns complexes fewer three members. 3.  **Redundancy Analysis:** sparse binary membership matrix constructed     efficiently calculate Jaccard similarity unique pairs     complexes. warning issued significant portion pairs     exceeds specified `redundancyThreshold`.","code":""},{"path":[]},{"path":"https://zqzneptune.github.io/ComplexMap/reference/qcComplexList.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Perform Quality Control on a List of Protein Complexes — qcComplexList","text":"Qingzhou Zhang <zqzneptune@hotmail.com>","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/qcComplexList.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Perform Quality Control on a List of Protein Complexes — qcComplexList","text":"","code":"# Create a sample list of protein complexes complex1 <- c(\"A\", \"B\", \"C\", \"D\") complex2 <- c(\"A\", \"B\", \"C\", \"E\") # Highly redundant with complex1 complex3 <- c(\"F\", \"G\", \"H\") complex4 <- c(\"I\", \"J\")          # Small complex complex5 <- c(\"X\", \"Y\", \"Z\") sampleList <- list(   C1 = complex1, C2 = complex2, C3 = complex3, C4 = complex4, C5 = complex5 )  # Run the quality control analysis qcComplexList(sampleList) #>  #> --- Running Quality Control on Complex List --- #>  #> [1] Basic Statistics: #>     - Total number of complexes: 5 #>     - Total number of unique proteins: 13 #>  #> [2] Complex Size Distribution: #>        Min. 1st Qu.  Median    Mean 3rd Qu.    Max.  #>         2.0     3.0     3.0     3.2     4.0     4.0  #> Warning: 1 complexes have fewer than 3 members. #>  #> [3] Redundancy Analysis: #>     - Distribution of Jaccard similarity scores: #>        Min. 1st Qu.  Median    Mean 3rd Qu.    Max.  #>        0.00    0.00    0.00    0.06    0.00    0.60  #>     - No highly redundant complex pairs detected. #>  #> --- QC Complete ---"},{"path":"https://zqzneptune.github.io/ComplexMap/reference/referenceComplexes.html","id":null,"dir":"Reference","previous_headings":"","what":"Reference Protein Complex Set (CORUM) — referenceComplexes","title":"Reference Protein Complex Set (CORUM) — referenceComplexes","text":"reference dataset containing 324 merged CORUM protein complexes used training protein-protein interaction scoring clustering optimization procedures study.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/referenceComplexes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Reference Protein Complex Set (CORUM) — referenceComplexes","text":"","code":"referenceComplexes"},{"path":"https://zqzneptune.github.io/ComplexMap/reference/referenceComplexes.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Reference Protein Complex Set (CORUM) — referenceComplexes","text":"named list 324 elements. element character vector protein identifiers.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/referenceComplexes.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Reference Protein Complex Set (CORUM) — referenceComplexes","text":"Supplementary Table 3 (second tab) : Havugimana PC, Hart GT, Nepusz T, Yang H, Turinsky AL, Li Z, Wang PI, Boutz DR, Fong V, Phanse S, Babu M, Craig SA, Hu P, Wan C, Vlasblom J, Dar VU, Bezginov , Clark GW, Wu GC, Wodak SJ, Tillier ER, Paccanaro , Marcotte EM, Emili . *census human soluble protein complexes.* Cell. 2012 Aug 31;150(5):1068-81. doi: 10.1016/j.cell.2012.08.011. PMID: 22939629; PMCID: PMC3477804.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/referenceComplexes.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Reference Protein Complex Set (CORUM) — referenceComplexes","text":"complexes curated CORUM database merged reduce redundancy benchmarking purposes.","code":""},{"path":[]},{"path":"https://zqzneptune.github.io/ComplexMap/reference/refineComplexList.html","id":null,"dir":"Reference","previous_headings":"","what":"Refine a List of Protein Complexes by Size and Redundancy — refineComplexList","title":"Refine a List of Protein Complexes by Size and Redundancy — refineComplexList","text":"function refines list protein complexes first filtering based size merging highly redundant complexes based Jaccard similarity threshold.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/refineComplexList.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Refine a List of Protein Complexes by Size and Redundancy — refineComplexList","text":"","code":"refineComplexList(   complexList,   minSize = 3,   maxSize = 500,   mergeThreshold = 0.9,   verbose = TRUE )"},{"path":"https://zqzneptune.github.io/ComplexMap/reference/refineComplexList.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Refine a List of Protein Complexes by Size and Redundancy — refineComplexList","text":"complexList named list element character vector protein identifiers representing complex. minSize integer specifying minimum number proteins complex must retained. Defaults 3. maxSize integer specifying maximum number proteins complex can retained. Defaults 500. mergeThreshold numeric value (0-1) Jaccard similarity. Complexes score >= value merged. Defaults 0.9. verbose logical value indicating whether print progress messages. Defaults `TRUE`.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/refineComplexList.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Refine a List of Protein Complexes by Size and Redundancy — refineComplexList","text":"refined renamed named list protein complexes.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/refineComplexList.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Refine a List of Protein Complexes by Size and Redundancy — refineComplexList","text":"refinement process consists two main stages: 1.  **Size Filtering:** Complexes smaller `minSize` larger     `maxSize` removed list. 2.  **Redundancy Merging:** Jaccard similarity matrix calculated     remaining pairs complexes. union-find algorithm used     identify clusters (\"merge groups\") complexes members     connected similarity score greater equal     `mergeThreshold`. groups merged single complexes. Finally, complexes refined list renamed standardized format (\"CpxMap_0001\", \"CpxMap_0002\", etc.).","code":""},{"path":[]},{"path":"https://zqzneptune.github.io/ComplexMap/reference/refineComplexList.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Refine a List of Protein Complexes by Size and Redundancy — refineComplexList","text":"Qingzhou Zhang <zqzneptune@hotmail.com>","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/refineComplexList.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Refine a List of Protein Complexes by Size and Redundancy — refineComplexList","text":"","code":"# Create a sample list of protein complexes complex1 <- c(\"A\", \"B\", \"C\", \"D\") complex2 <- c(\"A\", \"B\", \"C\", \"E\") # Highly redundant with complex1 complex3 <- c(\"F\", \"G\", \"H\") complex4 <- c(\"I\", \"J\")          # Too small, will be filtered sampleList <- list(   C1 = complex1, C2 = complex2, C3 = complex3, C4 = complex4 )  # Refine the list using a high similarity threshold refinedList <- refineComplexList(sampleList, mergeThreshold = 0.75) #>  #> --- Refining Input Complex List --- #> Filtered 1 complexes by size. Retaining 3. #> Identifying merge groups with Jaccard >= 0.75... #> Found 0 merge groups. Merging 0 complexes into 3. #> Merging complete. Final list has 3 complexes. #>  #> --- Refinement Complete ---"},{"path":"https://zqzneptune.github.io/ComplexMap/reference/runComplexEnrichment.html","id":null,"dir":"Reference","previous_headings":"","what":"Run Gene Set Enrichment Analysis on a List of Complexes — runComplexEnrichment","title":"Run Gene Set Enrichment Analysis on a List of Complexes — runComplexEnrichment","text":"function performs hypergeometric-based enrichment analysis protein complex list provided gene set matrix (GMT).","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/runComplexEnrichment.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Run Gene Set Enrichment Analysis on a List of Complexes — runComplexEnrichment","text":"","code":"runComplexEnrichment(   complexList,   gmt,   pAdjustMethod = \"Benjamini\",   pValueCutoff = 0.05,   verbose = TRUE )"},{"path":"https://zqzneptune.github.io/ComplexMap/reference/runComplexEnrichment.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Run Gene Set Enrichment Analysis on a List of Complexes — runComplexEnrichment","text":"complexList named list element character vector gene/protein identifiers representing complex. gmt named list element character vector genes, representing functional gene set (e.g., GMT file). pAdjustMethod character string specifying p-value adjustment method use filtering. Must one \"Benjamini\", \"Bonferroni\", \"FDR\". Defaults \"Benjamini\". pValueCutoff numeric value used cutoff significance adjusted p-value. Defaults 0.05. verbose logical value indicating whether print progress messages. Defaults `TRUE`.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/runComplexEnrichment.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Run Gene Set Enrichment Analysis on a List of Complexes — runComplexEnrichment","text":"named list name corresponds `complexId` input. element data frame containing significant enrichment results complex, columns: `ID`, `Description`, `p.adjust`, `Count`, `Ratio`, `Fold`.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/runComplexEnrichment.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Run Gene Set Enrichment Analysis on a List of Complexes — runComplexEnrichment","text":"complex, function calculates -representation functional terms (e.g., GO terms, pathways) GMT file. uses hypergeometric test compute p-value, adjusted multiple testing. terms significant filtering `pValueCutoff` retained final output.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/runComplexEnrichment.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Run Gene Set Enrichment Analysis on a List of Complexes — runComplexEnrichment","text":"Qingzhou Zhang <zqzneptune@hotmail.com>","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/runComplexEnrichment.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Run Gene Set Enrichment Analysis on a List of Complexes — runComplexEnrichment","text":"","code":"# --- Sample Data --- # 1. Complexes to be tested complex1 <- c(\"A\", \"B\", \"C\", \"D\") complex2 <- c(\"F\", \"G\", \"H\") myComplexes <- list(Cpx1 = complex1, Cpx2 = complex2)  # 2. Gene Set Matrix (e.g., GO terms or pathways) term1 <- c(\"A\", \"B\", \"C\", \"X\", \"Y\") # Enriched in Cpx1 term2 <- c(\"F\", \"G\", \"Z\")          # Enriched in Cpx2 term3 <- c(\"L\", \"M\", \"N\")          # Not enriched myGmt <- list(Term1 = term1, Term2 = term2, Term3 = term3)  # --- Run Enrichment --- enrichment <- runComplexEnrichment(myComplexes, myGmt) #> Running enrichment for 2 complexes... #> Annotation complete. Found terms for 0 complexes. print(enrichment) #> list()"},{"path":"https://zqzneptune.github.io/ComplexMap/reference/visualizeMapDirectLabels.html","id":null,"dir":"Reference","previous_headings":"","what":"Visualize a Complex Map with Direct Node Labels — visualizeMapDirectLabels","title":"Visualize a Complex Map with Direct Node Labels — visualizeMapDirectLabels","text":"Creates static visualization complex network using `ggraph`, functional domain labels placed directly plot near nodes.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/visualizeMapDirectLabels.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Visualize a Complex Map with Direct Node Labels — visualizeMapDirectLabels","text":"","code":"visualizeMapDirectLabels(   layoutDf,   edgesDf,   title = \"ComplexMap Functional Landscape\",   subtitle = \"Nodes are protein complexes, colored by function\",   bgColor = \"black\",   edgeColor = \"white\",   nodeSizeRange = c(2, 10),   labelFillColor = alpha(\"white\", 0.7),   fontFamily = \"sans\",   verbose = TRUE )"},{"path":"https://zqzneptune.github.io/ComplexMap/reference/visualizeMapDirectLabels.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Visualize a Complex Map with Direct Node Labels — visualizeMapDirectLabels","text":"layoutDf data frame containing node attributes layout coordinates, typically `computeMapTopology`. edgesDf data frame containing network edges. title main title plot. subtitle subtitle plot. bgColor background color plot. edgeColor color network edges. nodeSizeRange numeric vector length 2 specifying min max node size. labelFillColor background fill color labels. fontFamily base font family plot text. verbose logical value indicating whether print progress messages.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/visualizeMapDirectLabels.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Visualize a Complex Map with Direct Node Labels — visualizeMapDirectLabels","text":"`ggplot` object representing network visualization.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/visualizeMapDirectLabels.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Visualize a Complex Map with Direct Node Labels — visualizeMapDirectLabels","text":"function designed clarity domains distinct. large, dense domains (2 complexes), single label placed domain's centroid. smaller domains, complex labeled individually. uses pre-computed layout `computeMapTopology`.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/visualizeMapDirectLabels.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Visualize a Complex Map with Direct Node Labels — visualizeMapDirectLabels","text":"Qingzhou Zhang <zqzneptune@hotmail.com>","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/visualizeMapDirectLabels.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Visualize a Complex Map with Direct Node Labels — visualizeMapDirectLabels","text":"","code":"# --- Sample Data --- nodes <- tibble::tibble(   complexId = c(\"C1\", \"C2\", \"C3\"), x = c(1, 2, 1.5), y = c(1, 1, 2),   primaryFunctionalDomain = c(\"DNA Repair\", \"DNA Repair\", \"Metabolism\"),   sizeMapping = c(3, 4, 3.5), colorHex = c(\"#FF0000\", \"#FF0000\", \"#0000FF\") ) edges <- tibble::tibble(source_complex_id = \"C1\", target_complex_id = \"C2\", weight = 0.8)  # --- Generate Plot --- if (requireNamespace(\"ggrepel\", quietly = TRUE)) {   visualizeMapDirectLabels(nodes, edges) } #> Visualizing ComplexMap with direct labels..."},{"path":"https://zqzneptune.github.io/ComplexMap/reference/visualizeMapInteractive.html","id":null,"dir":"Reference","previous_headings":"","what":"Visualize a Complex Map Interactively — visualizeMapInteractive","title":"Visualize a Complex Map Interactively — visualizeMapInteractive","text":"Creates dynamic, zoomable, explorable HTML widget complex network using `visNetwork` package.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/visualizeMapInteractive.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Visualize a Complex Map Interactively — visualizeMapInteractive","text":"","code":"visualizeMapInteractive(   layoutDf,   edgesDf,   width = \"100%\",   height = \"90vh\",   title = \"ComplexMap Functional Landscape\",   physicsEnabled = FALSE,   verbose = TRUE )"},{"path":"https://zqzneptune.github.io/ComplexMap/reference/visualizeMapInteractive.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Visualize a Complex Map Interactively — visualizeMapInteractive","text":"layoutDf data frame node attributes `computeMapTopology`. edgesDf data frame network edges. width width HTML widget. height height HTML widget. title main title network visualization. physicsEnabled logical value. `TRUE`, nodes physically react dragging. Defaults `FALSE` stable layout. verbose logical value indicating whether print progress messages.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/visualizeMapInteractive.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Visualize a Complex Map Interactively — visualizeMapInteractive","text":"`visNetwork` HTML widget object.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/visualizeMapInteractive.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Visualize a Complex Map Interactively — visualizeMapInteractive","text":"function ideal data exploration. Nodes can clicked dragged, hovering node reveals detailed tooltip attributes. coordinates static layout rescaled used provide initial, non-random arrangement.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/visualizeMapInteractive.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Visualize a Complex Map Interactively — visualizeMapInteractive","text":"Qingzhou Zhang <zqzneptune@hotmail.com>","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/visualizeMapInteractive.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Visualize a Complex Map Interactively — visualizeMapInteractive","text":"","code":"# --- Sample Data --- nodes <- tibble::tibble(   complexId = c(\"C1\", \"C2\", \"C3\"), x = c(1, 2, 1.5), y = c(1, 1, 2),   primaryFunctionalDomain = c(\"DNA Repair\", \"DNA Repair\", \"Metabolism\"),   sizeMapping = c(3, 4, 3.5), colorHex = c(\"#FF0000\", \"#FF0000\", \"#0000FF\"),   proteinCount = c(10, 8, 12), proteins = c(\"A,B\", \"B,C\", \"D,E\") ) edges <- tibble::tibble(   source_complex_id = \"C1\", target_complex_id = \"C2\", weight = 0.8 )  # --- Generate Plot --- if (requireNamespace(\"visNetwork\", quietly = TRUE)) {   visualizeMapInteractive(nodes, edges) } #> Generating interactive visNetwork plot...  {\"x\":{\"nodes\":{\"complexId\":[\"C1\",\"C2\",\"C3\"],\"x\":[-800,800,0],\"y\":[800,800,-800],\"primaryFunctionalDomain\":[\"DNA Repair\",\"DNA Repair\",\"Metabolism\"],\"sizeMapping\":[3,4,3.5],\"colorHex\":[\"#FF0000\",\"#FF0000\",\"#0000FF\"],\"proteinCount\":[10,8,12],\"proteins\":[\"A,B\",\"B,C\",\"D,E\"],\"id\":[\"C1\",\"C2\",\"C3\"],\"label\":[\"C1\",\"C2\",\"C3\"],\"value\":[3,4,3.5],\"color\":[\"#FF0000\",\"#FF0000\",\"#0000FF\"],\"title\":[\"<div style='font-family:sans-serif; text-align:left;'><b>Complex:<\\/b> C1<br><b>Function:<\\/b> DNA Repair<br><b>Protein Count:<\\/b> 10<hr><b>Members:<\\/b><br>A, B<\\/div>\",\"<div style='font-family:sans-serif; text-align:left;'><b>Complex:<\\/b> C2<br><b>Function:<\\/b> DNA Repair<br><b>Protein Count:<\\/b> 8<hr><b>Members:<\\/b><br>B, C<\\/div>\",\"<div style='font-family:sans-serif; text-align:left;'><b>Complex:<\\/b> C3<br><b>Function:<\\/b> Metabolism<br><b>Protein Count:<\\/b> 12<hr><b>Members:<\\/b><br>D, E<\\/div>\"]},\"edges\":{\"source_complex_id\":[\"C1\"],\"target_complex_id\":[\"C2\"],\"weight\":[0.8],\"from\":[\"C1\"],\"to\":[\"C2\"],\"value\":[0.8]},\"nodesToDataframe\":true,\"edgesToDataframe\":true,\"options\":{\"width\":\"100%\",\"height\":\"100%\",\"nodes\":{\"shape\":\"dot\",\"borderWidth\":2,\"shadow\":true},\"manipulation\":{\"enabled\":false},\"edges\":{\"color\":{\"color\":\"#888888\",\"highlight\":\"#00BFFF\"},\"smooth\":false},\"physics\":{\"enabled\":false},\"interaction\":{\"hover\":true,\"dragNodes\":true,\"dragView\":true,\"navigationButtons\":true,\"tooltipDelay\":200,\"zoomView\":true,\"zoomSpeed\":1},\"layout\":{\"randomSeed\":123}},\"groups\":null,\"width\":\"100%\",\"height\":\"90vh\",\"idselection\":{\"enabled\":true,\"style\":\"width: 150px; height: 26px\",\"useLabels\":true,\"main\":\"Select by id\"},\"byselection\":{\"enabled\":true,\"style\":\"width: 150px; height: 26px\",\"multiple\":false,\"hideColor\":\"rgba(200,200,200,0.5)\",\"highlight\":false,\"variable\":\"primaryFunctionalDomain\",\"main\":\"Select by primaryFunctionalDomain\",\"values\":[\"DNA Repair\",\"Metabolism\"]},\"main\":{\"text\":\"ComplexMap Functional Landscape\",\"style\":\"font-family:Georgia, Times New Roman, Times, serif;font-weight:bold;font-size:20px;text-align:center;\"},\"submain\":null,\"footer\":null,\"background\":\"rgba(0, 0, 0, 0)\",\"highlight\":{\"enabled\":true,\"hoverNearest\":true,\"degree\":1,\"algorithm\":\"all\",\"hideColor\":\"rgba(200,200,200,0.5)\",\"labelOnly\":true},\"collapse\":{\"enabled\":false,\"fit\":false,\"resetHighlight\":true,\"clusterOptions\":null,\"keepCoord\":true,\"labelSuffix\":\"(cluster)\"},\"tooltipStay\":300,\"tooltipStyle\":\"position: fixed;visibility:hidden;padding: 5px;white-space: nowrap;font-family: verdana;font-size:14px;font-color:#000000;background-color: #f5f4ed;-moz-border-radius: 3px;-webkit-border-radius: 3px;border-radius: 3px;border: 1px solid #808074;box-shadow: 3px 3px 10px rgba(0, 0, 0, 0.2);\"},\"evals\":[],\"jsHooks\":[]}"},{"path":"https://zqzneptune.github.io/ComplexMap/reference/visualizeMapWithLegend.html","id":null,"dir":"Reference","previous_headings":"","what":"Visualize a Complex Map with a Color Legend — visualizeMapWithLegend","title":"Visualize a Complex Map with a Color Legend — visualizeMapWithLegend","text":"Creates static visualization complex network using `ggraph`, functional domains represented discrete color scale legend.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/visualizeMapWithLegend.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Visualize a Complex Map with a Color Legend — visualizeMapWithLegend","text":"","code":"visualizeMapWithLegend(   layoutDf,   edgesDf,   title = \"ComplexMap Functional Landscape\",   subtitle = \"Nodes are protein complexes, colored by function\",   bgColor = \"black\",   edgeColor = \"white\",   nodeSizeRange = c(2, 10),   unenrichedColor = \"#CCCCCC\",   fontFamily = \"sans\",   verbose = TRUE )"},{"path":"https://zqzneptune.github.io/ComplexMap/reference/visualizeMapWithLegend.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Visualize a Complex Map with a Color Legend — visualizeMapWithLegend","text":"layoutDf data frame containing node attributes layout coordinates, typically `computeMapTopology`. edgesDf data frame containing network edges. title main title plot. subtitle subtitle plot. bgColor background color plot. edgeColor color network edges. nodeSizeRange numeric vector length 2 specifying min max node size. unenrichedColor color nodes \"Unenriched\" category. fontFamily base font family plot text. verbose logical value indicating whether print progress messages.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/visualizeMapWithLegend.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Visualize a Complex Map with a Color Legend — visualizeMapWithLegend","text":"`ggplot` object representing network visualization.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/visualizeMapWithLegend.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Visualize a Complex Map with a Color Legend — visualizeMapWithLegend","text":"plot useful overviews direct labels cluttered. maps `primaryFunctionalDomain` node color displays legend. uses pre-computed layout `computeMapTopology`.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/visualizeMapWithLegend.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Visualize a Complex Map with a Color Legend — visualizeMapWithLegend","text":"Qingzhou Zhang <zqzneptune@hotmail.com>","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/visualizeMapWithLegend.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Visualize a Complex Map with a Color Legend — visualizeMapWithLegend","text":"","code":"# --- Sample Data --- nodes <- tibble::tibble(   complexId = c(\"C1\", \"C2\", \"C3\"), x = c(1, 2, 1.5), y = c(1, 1, 2),   primaryFunctionalDomain = c(\"DNA Repair\", \"DNA Repair\", \"Unenriched\"),   sizeMapping = c(3, 4, 3.5), colorHex = c(\"#FF0000\", \"#FF0000\", \"#CCCCCC\") ) edges <- tibble::tibble(source_complex_id = \"C1\", target_complex_id = \"C2\", weight = 0.8)  # --- Generate Plot --- visualizeMapWithLegend(nodes, edges) #> Visualizing ComplexMap with a color legend..."}]
