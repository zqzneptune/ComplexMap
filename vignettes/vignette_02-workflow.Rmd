---
title: "2. Start a Typical Workflow"
author: "Qingzhou Zhang"
date: "`r Sys.Date()`"
output: html_document
vignette: >
  %\VetteIndexEntry{Analyzing a Human Protein Complex Map with ComplexMap}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
library(dplyr)
```

# Introduction

Protein complexes are the functional machinery of the cell. High-throughput experimental methods can identify hundreds of putative protein complexes in a single experiment. The `ComplexMap` package provides a comprehensive, end-to-end workflow to process, analyze, annotate, and visualize such a dataset.

This vignette demonstrates the main analysis workflow using the high-level `createComplexMap()` wrapper function. We will use a dataset of human soluble protein complexes, originally published in 2012 [A census of human soluble protein complexes](https://doi.org/10.1016/j.cell.2012.08.011), to perform a complete analysis from start to finish. We will then showcase the downstream analysis functions for interpreting and exploring the results.

# Step 1: Loading Data

The `ComplexMap` package includes the `demoComplexes` dataset, a list of 622 putative human protein complexes. We will also load an example gene set (GMT) file for functional annotation.

```{r load-data}
# Load the example complex list shipped with the package
utils::data("demoComplexes", package = "ComplexMap")

# Get the path to the example GMT file and load it
gmtPath <- ComplexMap::getExampleGmt()
biocartaGmt <- ComplexMap::getGmtFromFile(gmtPath, verbose = FALSE)
```

# Step 2: Running the Main Workflow

The core of the package is the `createComplexMap()` function. This single wrapper function handles all the essential processing steps:

1.  **Quality Control & Refinement**: Filters complexes by size and merges highly redundant ones.

2.  **Functional Enrichment**: Annotates each complex with biological functions.

3.  **Network Construction**: Builds a similarity network based on shared proteins and functions.

4.  **Attribute & Topology Generation**: Calculates node colors, sizes, and layout coordinates for visualization.

We can pass parameters to the underlying functions (like `mergeThreshold` for `refineComplexList`) directly into this wrapper.

```{r create-map, message=TRUE}
# Run the entire workflow with a single command
# We will merge complexes with a Jaccard similarity of 0.75 or higher
complexMapObject <- ComplexMap::createComplexMap(
  complexList = demoComplexes,
  gmt = biocartaGmt,
  mergeThreshold = 0.75
)
```

The output, `complexMapObject`, is a formal `ComplexMap` S3 object that contains the complete results of the analysis. Printing the object gives a high-level summary.

```{r print-object}
# Print the object to see a summary
complexMapObject
```

# Step 3: Summarizing Biological Themes

A key goal of the map is to identify major biological themes. The `summarizeThemes()` function uses community detection algorithms to find densely connected network modules and provides a summary.

```{r summarize-themes}
themeSummary <- ComplexMap::summarizeThemes(complexMapObject)

# Display the top 10 largest themes
themeSummary %>%
  dplyr::arrange(dplyr::desc(nodeCount)) %>%
  utils::head(10)
```
The result is a table listing each theme, its descriptive label (derived from the most common function within the theme), and its size in terms of nodes and edges.

# Step 4: Exploring and Querying the Map

The `queryMap()` function provides a powerful way to programmatically explore the results.

### 4.1 Querying for a Specific Protein

Let's find all complexes that contain the protein "SMAD4".

```{r query-protein}
# To ensure our example is robust, let's find a protein to query
# that is guaranteed to be in our final, refined map.
nodes <- ComplexMap::getNodeTable(complexMapObject)
first_protein_list <- nodes$proteins[1]
query_protein <- strsplit(first_protein_list, ",")[[1]][1]

message("Dynamically querying for a protein found in the map: ", query_protein)

protein_complexes <- ComplexMap::queryMap(
  complexMapObject,
  query = query_protein,
  type = "protein"
)

# Show the primary functional domain of the resulting complexes
protein_complexes %>%
  dplyr::select(complexId, primaryFunctionalDomain, proteins)

```

### 4.2 Querying for a Specific Complex

We can also retrieve the data for a single complex of interest.

```{r query-complex}
# Note: The exact CpxMap ID may vary slightly between runs
# if refinement results change. We query for the first node in the table.
first_complex_id <- ComplexMap::getNodeTable(complexMapObject)$complexId[1]

complex_data <- ComplexMap::queryMap(
  complexMapObject,
  query = first_complex_id,
  type = "complex"
)

dplyr::glimpse(complex_data)
```

# Step 5: Visualization

Finally, we can visualize the entire functional landscape. `ComplexMap` provides three visualization functions that all work directly with the `ComplexMap` object.

First, we extract the final node and edge tables for plotting.

```{r extract-tables}
mapLayout <- ComplexMap::getNodeTable(complexMapObject)
networkEdges <- ComplexMap::getEdgeTable(complexMapObject)
```


### 5.1 Static Plot with a Legend

This version is useful for a clean overview, using a discrete color legend to represent the functional domains.

```{r vis-legend, fig.width=12, fig.height=9, fig.alt="A network plot of protein complexes where node color corresponds to a functional domain listed in a legend."}
ComplexMap::visualizeMapWithLegend(mapLayout, networkEdges)
```

### 5.2 Interactive Plot

For deep exploration, an interactive HTML widget is ideal. You can zoom, pan, and hover over nodes to see detailed tooltips.

```{r vis-interactive}
# visNetwork is required for this plot
if (requireNamespace("visNetwork", quietly = TRUE)) {
  ComplexMap::visualizeMapInteractive(mapLayout, networkEdges)
}
```

# Conclusion

This vignette has demonstrated the power and simplicity of the refactored `ComplexMap` workflow. By using the main `createComplexMap()` wrapper, a complete analysis can be run in a single step. The resulting object can then be easily interpreted, queried, and visualized, providing a user-friendly and powerful platform for exploring the landscape of protein complexes.
