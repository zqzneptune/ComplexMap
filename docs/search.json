[{"path":"https://zqzneptune.github.io/ComplexMap/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2025 Qingzhou Zhang Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_00-perp-input.html","id":"the-complexmap-philosophy-identifier-matching","dir":"Articles","previous_headings":"","what":"The ComplexMap Philosophy: Identifier Matching","title":"Preparing Input","text":"ComplexMap package designed powerful, flexible, species-agnostic. contain hard-coded assumptions Homo sapiens model organism. entire workflow depends one simple principle: identifiers used input lists must match. means package’s functions can support organism identifier type (e.g., Gene Symbols, Entrez IDs, Ensembl IDs, UniProt IDs), long consistent. three key inputs identifiers must consistent: Complex List: list protein/gene members complex want analyze. Functional Gene Sets (GMT): database used enrichment analysis. Reference Complex List: “gold standard” list used benchmarking ComplexMap::evaluateComplexes(). (required benchmarking, functional analysis.) example, complex list uses Gene Symbols, GMT file must also use Gene Symbols. complex list uses Entrez IDs, GMT must use Entrez IDs. vignette demonstrates prepare functional gene sets (GMT) various sources , crucially, handle convert identifiers ensure match input data.","code":"# For this tutorial, we will assume our input complex list uses Gene Symbols. myComplexes <- list(   CPLX1 = c(\"POLR2A\", \"POLR2B\", \"POLR2C\"),   CPLX2 = c(\"CDK1\", \"CCNB1\", \"CCNB2\") )"},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_00-perp-input.html","id":"preparing-functional-gene-sets-gmt","dir":"Articles","previous_headings":"","what":"Preparing Functional Gene Sets (GMT)","title":"Preparing Input","text":"ComplexMap provides several helper functions obtain GMT files. align package’s philosophy clarity avoiding namespace conflicts, call functions explicitly using package::function() syntax (e.g., ComplexMap::getGmtFromFile()) instead using library(). Let’s explore method, paying close attention identifier type returns.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_00-perp-input.html","id":"method-1-from-a-user-provided-local-file","dir":"Articles","previous_headings":"Preparing Functional Gene Sets (GMT)","what":"Method 1: From a User-Provided Local File","title":"Preparing Input","text":"direct method. GMT file, can load ComplexMap::getGmtFromFile(). First, get path example GMT file included package. file uses Gene Symbols. Load GMT file path. Let’s inspect identifiers: Identifier Match: example GMT file uses Gene Symbols. Since hypothetical myComplexes list also uses Gene Symbols, directly compatible ready analysis.","code":"gmtPath <- ComplexMap::getExampleGmt() gmtFromFile <- ComplexMap::getGmtFromFile(gmtPath, verbose = FALSE) # First 5 genes in the first gene set: utils::head(gmtFromFile[[1]], 5) #> [1] \"ATF2\"  \"CHUK\"  \"IFNG\"  \"IKBKB\" \"IL2\""},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_00-perp-input.html","id":"method-2-from-the-molecular-signatures-database-msigdb","dir":"Articles","previous_headings":"Preparing Functional Gene Sets (GMT)","what":"Method 2: From the Molecular Signatures Database (MSigDB)","title":"Preparing Input","text":"msigdbr package provides powerful --date interface MSigDB collections. ComplexMap::getMsigdbGmt() function simplifies process. Identifier Match: default, msigdbr also returns Gene Symbols. directly compatible myComplexes list.","code":"# Fetch the Hallmark gene sets for Human # This requires the `msigdbr` package if (requireNamespace(\"msigdbr\", quietly = TRUE)) {   h_gmt <- ComplexMap::getMsigdbGmt(species = \"Homo sapiens\", collection = \"H\")    # Inspect the identifiers   utils::head(h_gmt[[1]], 5) } #> Fetching MSigDB sets (Species: Homo sapiens, Cat: H) #> [1] \"ABCA1\" \"ABCB8\" \"ACAA2\" \"ACADL\" \"ACADM\""},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_00-perp-input.html","id":"method-3-from-gene-ontology-go-via-bioconductor","dir":"Articles","previous_headings":"Preparing Functional Gene Sets (GMT)","what":"Method 3: From Gene Ontology (GO) via Bioconductor","title":"Preparing Input","text":"Using official Bioconductor annotation packages highly reproducible way get functional annotations. databases, however, typically use stable database identifiers, gene symbols. Identifier Mismatch! getGoGmt function returns list genes Entrez IDs (e.g., “5594”, “5595”). match Gene Symbols myComplexes list (e.g., “POLR2A”). Solution: Convert Complex List Identifiers recommended approach convert input complex identifiers match stable IDs annotation database. AnnotationDbi::mapIds function perfect . Now, myComplexesEntrez list directly compatible goGmt generated Bioconductor.","code":"# This requires an organism annotation package, e.g., org.Hs.eg.db for human if (requireNamespace(\"org.Hs.eg.db\", quietly = TRUE)) {   # Fetch Biological Process (BP) terms   # We pass the database object directly using the `::` operator   goGmt <- ComplexMap::getGoGmt(speciesDb = org.Hs.eg.db::org.Hs.eg.db,                                  ontology = \"BP\",                                 verbose = FALSE)    # Inspect the identifiers   utils::head(goGmt[[1]], 5) } #>  #> 'select()' returned 1:many mapping between keys and columns #>  #> 'select()' returned 1:1 mapping between keys and columns #> [1] \"1291\" \"1738\" \"1743\" \"2805\" \"2806\" if (requireNamespace(\"org.Hs.eg.db\", quietly = TRUE)) {   # Get all unique symbols from our complex list   allSymbols <- unique(unlist(myComplexes))    # Map symbols to Entrez IDs, taking the first ID if multiple exist   symbolToEntrez <- AnnotationDbi::mapIds(       org.Hs.eg.db::org.Hs.eg.db,       keys = allSymbols,       keytype = \"SYMBOL\",       column = \"ENTREZID\",       multiVals = \"first\"   )      # Remove any symbols that could not be mapped   symbolToEntrez <- symbolToEntrez[!is.na(symbolToEntrez)]    # Now, create a new complex list with Entrez IDs   myComplexesEntrez <- lapply(myComplexes, function(complex) {     # Look up the Entrez ID for each symbol     entrez_ids <- symbolToEntrez[complex]     # Return only the successfully mapped IDs, removing any NAs     unname(entrez_ids[!is.na(entrez_ids)])   })    # Inspect the result   print(myComplexesEntrez) } #> 'select()' returned 1:1 mapping between keys and columns #> $CPLX1 #> [1] \"5430\" \"5431\" \"5432\" #>  #> $CPLX2 #> [1] \"983\"  \"891\"  \"9133\""},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_00-perp-input.html","id":"method-4-from-reactome-pathways-via-bioconductor","dir":"Articles","previous_headings":"Preparing Functional Gene Sets (GMT)","what":"Method 4: From Reactome Pathways via Bioconductor","title":"Preparing Input","text":"Similarly, reactome.db package provides pathway annotations, also use Entrez IDs. Identifier Mismatch! Like GO example, reactome.db provides Entrez IDs. Solution: solution Gene Ontology. use myComplexesEntrez list created previous step, identifiers match identifiers reactomeGmt.","code":"if (requireNamespace(\"reactome.db\", quietly = TRUE) &&      requireNamespace(\"org.Hs.eg.db\", quietly = TRUE)) {          reactomeGmt <- ComplexMap::getReactomeGmt(       speciesDb = org.Hs.eg.db::org.Hs.eg.db,       verbose = FALSE   )    # Inspect the identifiers   utils::head(reactomeGmt[[1]], 5) } #> [1] \"1\"     \"10019\" \"10112\" \"10125\" \"10125\""},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_00-perp-input.html","id":"conclusion","dir":"Articles","previous_headings":"","what":"Conclusion","title":"Preparing Input","text":"vignette demonstrated core philosophy ComplexMap: flexibility identifier consistency. understanding identifier types returned different sources knowing convert data match, can apply ComplexMap workflow virtually organism. Always check identifiers running ComplexMap::createComplexMap() ensure smooth successful analysis. explicit package::function() syntax demonstrated recommended best practice writing clean, reproducible, error-free analysis scripts.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_01-prep-input.html","id":"the-complexmap-philosophy-identifier-matching","dir":"Articles","previous_headings":"","what":"The ComplexMap Philosophy: Identifier Matching","title":"1. Preparing Your Input Data","text":"ComplexMap package designed powerful, flexible, species-agnostic. contain hard-coded assumptions Homo sapiens model organism. entire workflow depends one simple principle: identifiers used input lists must match. means package’s functions can support organism identifier type (e.g., Gene Symbols, Entrez IDs, Ensembl IDs, UniProt IDs), long consistent. three key inputs identifiers must consistent: Complex List: list protein/gene members complex want analyze. Functional Gene Sets (GMT): database used enrichment analysis. Reference Complex List: “gold standard” list used benchmarking ComplexMap::evaluateComplexes(). (required benchmarking, functional analysis.) example, complex list uses Gene Symbols, GMT file must also use Gene Symbols. complex list uses Entrez IDs, GMT must use Entrez IDs. vignette demonstrates prepare functional gene sets (GMT) various sources , crucially, handle convert identifiers ensure match input data.","code":"# For this tutorial, we will assume our input complex list uses Gene Symbols. myComplexes <- list(   CPLX1 = c(\"POLR2A\", \"POLR2B\", \"POLR2C\"),   CPLX2 = c(\"CDK1\", \"CCNB1\", \"CCNB2\") )"},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_01-prep-input.html","id":"preparing-functional-gene-sets-gmt","dir":"Articles","previous_headings":"","what":"Preparing Functional Gene Sets (GMT)","title":"1. Preparing Your Input Data","text":"ComplexMap provides several helper functions obtain GMT files. align package’s philosophy clarity avoiding namespace conflicts, call functions explicitly using package::function() syntax (e.g., ComplexMap::getGmtFromFile()) instead using library(). Let’s explore method, paying close attention identifier type returns.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_01-prep-input.html","id":"method-1-from-a-user-provided-local-file","dir":"Articles","previous_headings":"Preparing Functional Gene Sets (GMT)","what":"Method 1: From a User-Provided Local File","title":"1. Preparing Your Input Data","text":"direct method. GMT file, can load ComplexMap::getGmtFromFile(). First, get path example GMT file included package. file uses Gene Symbols. Load GMT file path. Let’s inspect identifiers: Identifier Match: example GMT file uses Gene Symbols. Since hypothetical myComplexes list also uses Gene Symbols, directly compatible ready analysis.","code":"gmtPath <- ComplexMap::getExampleGmt() gmtFromFile <- ComplexMap::getGmtFromFile(gmtPath, verbose = FALSE) # First 5 genes in the first gene set: utils::head(gmtFromFile[[1]], 5) #> [1] \"ATF2\"  \"CHUK\"  \"IFNG\"  \"IKBKB\" \"IL2\""},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_01-prep-input.html","id":"method-2-from-the-molecular-signatures-database-msigdb","dir":"Articles","previous_headings":"Preparing Functional Gene Sets (GMT)","what":"Method 2: From the Molecular Signatures Database (MSigDB)","title":"1. Preparing Your Input Data","text":"msigdbr package provides powerful --date interface MSigDB collections. ComplexMap::getMsigdbGmt() function simplifies process. Identifier Match: default, msigdbr also returns Gene Symbols. directly compatible myComplexes list.","code":"# Fetch the Hallmark gene sets for Human # This requires the `msigdbr` package if (requireNamespace(\"msigdbr\", quietly = TRUE)) {   h_gmt <- ComplexMap::getMsigdbGmt(species = \"Homo sapiens\", collection = \"H\")    # Inspect the identifiers   utils::head(h_gmt[[1]], 5) } #> Fetching MSigDB sets (Species: Homo sapiens, Cat: H) #> [1] \"ABCA1\" \"ABCB8\" \"ACAA2\" \"ACADL\" \"ACADM\""},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_01-prep-input.html","id":"method-3-from-gene-ontology-go-via-bioconductor","dir":"Articles","previous_headings":"Preparing Functional Gene Sets (GMT)","what":"Method 3: From Gene Ontology (GO) via Bioconductor","title":"1. Preparing Your Input Data","text":"Using official Bioconductor annotation packages highly reproducible way get functional annotations. databases, however, typically use stable database identifiers, gene symbols. Identifier Mismatch! getGoGmt function returns list genes Entrez IDs (e.g., “5594”, “5595”). match Gene Symbols myComplexes list (e.g., “POLR2A”). Solution: Convert Complex List Identifiers recommended approach convert input complex identifiers match stable IDs annotation database. AnnotationDbi::mapIds function perfect . Now, myComplexesEntrez list directly compatible goGmt generated Bioconductor.","code":"# This requires an organism annotation package, e.g., org.Hs.eg.db for human if (requireNamespace(\"org.Hs.eg.db\", quietly = TRUE)) {   # Fetch Biological Process (BP) terms   # We pass the database object directly using the `::` operator   goGmt <- ComplexMap::getGoGmt(speciesDb = org.Hs.eg.db::org.Hs.eg.db,                                  ontology = \"BP\",                                 verbose = FALSE)    # Inspect the identifiers   utils::head(goGmt[[1]], 5) } #>  #> 'select()' returned 1:many mapping between keys and columns #>  #> 'select()' returned 1:1 mapping between keys and columns #> [1] \"1291\" \"1738\" \"1743\" \"2805\" \"2806\" if (requireNamespace(\"org.Hs.eg.db\", quietly = TRUE)) {   # Get all unique symbols from our complex list   allSymbols <- unique(unlist(myComplexes))    # Map symbols to Entrez IDs, taking the first ID if multiple exist   symbolToEntrez <- AnnotationDbi::mapIds(       org.Hs.eg.db::org.Hs.eg.db,       keys = allSymbols,       keytype = \"SYMBOL\",       column = \"ENTREZID\",       multiVals = \"first\"   )      # Remove any symbols that could not be mapped   symbolToEntrez <- symbolToEntrez[!is.na(symbolToEntrez)]    # Now, create a new complex list with Entrez IDs   myComplexesEntrez <- lapply(myComplexes, function(complex) {     # Look up the Entrez ID for each symbol     entrez_ids <- symbolToEntrez[complex]     # Return only the successfully mapped IDs, removing any NAs     unname(entrez_ids[!is.na(entrez_ids)])   })    # Inspect the result   print(myComplexesEntrez) } #> 'select()' returned 1:1 mapping between keys and columns #> $CPLX1 #> [1] \"5430\" \"5431\" \"5432\" #>  #> $CPLX2 #> [1] \"983\"  \"891\"  \"9133\""},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_01-prep-input.html","id":"method-4-from-reactome-pathways-via-bioconductor","dir":"Articles","previous_headings":"Preparing Functional Gene Sets (GMT)","what":"Method 4: From Reactome Pathways via Bioconductor","title":"1. Preparing Your Input Data","text":"Similarly, reactome.db package provides pathway annotations, also use Entrez IDs. Identifier Mismatch! Like GO example, reactome.db provides Entrez IDs. Solution: solution Gene Ontology. use myComplexesEntrez list created previous step, identifiers match identifiers reactomeGmt.","code":"if (requireNamespace(\"reactome.db\", quietly = TRUE) &&      requireNamespace(\"org.Hs.eg.db\", quietly = TRUE)) {          reactomeGmt <- ComplexMap::getReactomeGmt(       speciesDb = org.Hs.eg.db::org.Hs.eg.db,       verbose = FALSE   )    # Inspect the identifiers   utils::head(reactomeGmt[[1]], 5) } #> [1] \"1\"     \"10019\" \"10112\" \"10125\" \"10125\""},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_01-prep-input.html","id":"conclusion","dir":"Articles","previous_headings":"","what":"Conclusion","title":"1. Preparing Your Input Data","text":"vignette demonstrated core philosophy ComplexMap: flexibility identifier consistency. understanding identifier types returned different sources knowing convert data match, can apply ComplexMap workflow virtually organism. Always check identifiers running ComplexMap::createComplexMap() ensure smooth successful analysis. explicit package::function() syntax demonstrated recommended best practice writing clean, reproducible, error-free analysis scripts.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_01-workflow.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"A Typical Workflow","text":"Protein complexes functional machinery cell. High-throughput experimental methods can identify hundreds putative protein complexes single experiment. ComplexMap package provides comprehensive, end--end workflow process, analyze, annotate, visualize dataset. vignette demonstrates main analysis workflow using high-level createComplexMap() wrapper function. use dataset human soluble protein complexes, originally published 2012 census human soluble protein complexes, perform complete analysis start finish. showcase downstream analysis functions interpreting exploring results.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_01-workflow.html","id":"step-1-loading-data","dir":"Articles","previous_headings":"","what":"Step 1: Loading Data","title":"A Typical Workflow","text":"ComplexMap package includes demoComplexes dataset, list 622 putative human protein complexes. also load example gene set (GMT) file functional annotation.","code":"# Load the example complex list shipped with the package utils::data(\"demoComplexes\", package = \"ComplexMap\")  # Get the path to the example GMT file and load it gmtPath <- ComplexMap::getExampleGmt() biocartaGmt <- ComplexMap::getGmtFromFile(gmtPath, verbose = FALSE)"},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_01-workflow.html","id":"step-2-running-the-main-workflow","dir":"Articles","previous_headings":"","what":"Step 2: Running the Main Workflow","title":"A Typical Workflow","text":"core package createComplexMap() function. single wrapper function handles essential processing steps: Quality Control & Refinement: Filters complexes size merges highly redundant ones. Functional Enrichment: Annotates complex biological functions. Network Construction: Builds similarity network based shared proteins functions. Attribute & Topology Generation: Calculates node colors, sizes, layout coordinates visualization. can pass parameters underlying functions (like mergeThreshold refineComplexList) directly wrapper. output, complexMapObject, formal ComplexMap S3 object contains complete results analysis. Printing object gives high-level summary.","code":"# Run the entire workflow with a single command # We will merge complexes with a Jaccard similarity of 0.75 or higher complexMapObject <- ComplexMap::createComplexMap(   complexList = demoComplexes,   gmt = biocartaGmt,   mergeThreshold = 0.75 ) #> --- Starting ComplexMap Workflow --- #>  #> Step 1: Refining complex list... #>  #> --- Refining Input Complex List --- #> Filtered 112 complexes by size. Retaining 510. #> Identifying merge groups with Jaccard >= 0.75... #> Found 0 merge groups. Merging 0 complexes into 510. #> Merging complete. Final list has 510 complexes. #>  #> --- Refinement Complete --- #>  #> Step 2: Running enrichment analysis... #> Running enrichment for 510 complexes... #> Annotation complete. Found terms for 239 complexes. #>  #> Step 3: Building complex network... #> Building complex network using 'jaccard' similarity... #> Using 11 cores for parallel processing. #> Processing 129795 complex pairs... #> Split into 130 chunks of up to 1000 pairs each. #> Combining results from chunks... #> Calculating final weights and filtering... #> Network construction complete: 1020 edges retained. #>  #> Step 4: Generating node attributes... #> Generating core node attributes (function and color)... #>     -> Clustering terms using 'jaccard' similarity. #> Metric: 'jaccard' with unit: 'log'; comparing: 231 vectors #>  #> Step 5: Computing map topology... #> Computing map topology (layout and centrality)... #> Topology computation complete. #>  #> --- ComplexMap Workflow Complete --- # Print the object to see a summary complexMapObject #> # A ComplexMap Object #> # ── 510 nodes and 1020 edges #> # ── 15 major biological themes identified. #> # ── Use `getNodeTable()` or `getEdgeTable()` to access data."},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_01-workflow.html","id":"step-3-summarizing-biological-themes","dir":"Articles","previous_headings":"","what":"Step 3: Summarizing Biological Themes","title":"A Typical Workflow","text":"key goal map identify major biological themes. summarizeThemes() function uses community detection algorithms find densely connected network modules provides summary. result table listing theme, descriptive label (derived common function within theme), size terms nodes edges.","code":"themeSummary <- ComplexMap::summarizeThemes(complexMapObject) #> Summarizing themes using the 'louvain' community algorithm... #> Identified 295 distinct themes.  # Display the top 10 largest themes themeSummary %>%   dplyr::arrange(dplyr::desc(nodeCount)) %>%   utils::head(10) #> # A tibble: 10 × 4 #>    themeId    themeLabel                  nodeCount edgeCount #>    <membrshp> <chr>                           <int>     <int> #>  1  2         BIOCARTA_EICOSANOID_PATHWAY        42       167 #>  2  1         BIOCARTA_EICOSANOID_PATHWAY        30        89 #>  3  7         BIOCARTA_EICOSANOID_PATHWAY        23        93 #>  4  5         BIOCARTA_EICOSANOID_PATHWAY        21        98 #>  5  9         BIOCARTA_EICOSANOID_PATHWAY        19        56 #>  6  4         BIOCARTA_EICOSANOID_PATHWAY        16        68 #>  7  6         BIOCARTA_EICOSANOID_PATHWAY        13        29 #>  8 12         BIOCARTA_ETS_PATHWAY               13        24 #>  9 13         BIOCARTA_EICOSANOID_PATHWAY        10        24 #> 10  3         BIOCARTA_EICOSANOID_PATHWAY         8        22"},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_01-workflow.html","id":"step-4-exploring-and-querying-the-map","dir":"Articles","previous_headings":"","what":"Step 4: Exploring and Querying the Map","title":"A Typical Workflow","text":"queryMap() function provides powerful way programmatically explore results.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_01-workflow.html","id":"querying-for-a-specific-protein","dir":"Articles","previous_headings":"Step 4: Exploring and Querying the Map","what":"4.1 Querying for a Specific Protein","title":"A Typical Workflow","text":"Let’s find complexes contain protein “SMAD4”.","code":"# To ensure our example is robust, let's find a protein to query # that is guaranteed to be in our final, refined map. nodes <- ComplexMap::getNodeTable(complexMapObject) first_protein_list <- nodes$proteins[1] query_protein <- strsplit(first_protein_list, \",\")[[1]][1]  message(\"Dynamically querying for a protein found in the map: \", query_protein) #> Dynamically querying for a protein found in the map: WDR3  protein_complexes <- ComplexMap::queryMap(   complexMapObject,   query = query_protein,   type = \"protein\" )  # Show the primary functional domain of the resulting complexes protein_complexes %>%   dplyr::select(complexId, primaryFunctionalDomain, proteins) #> # A tibble: 1 × 3 #>   complexId   primaryFunctionalDomain     proteins                               #>   <chr>       <chr>                       <chr>                                  #> 1 CpxMap_0414 BIOCARTA_EICOSANOID_PATHWAY WDR3,RB1,PNO1,EMG1,CSNK1E,TPTEP2-CSNK…"},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_01-workflow.html","id":"querying-for-a-specific-complex","dir":"Articles","previous_headings":"Step 4: Exploring and Querying the Map","what":"4.2 Querying for a Specific Complex","title":"A Typical Workflow","text":"can also retrieve data single complex interest.","code":"# Note: The exact CpxMap ID may vary slightly between runs # if refinement results change. We query for the first node in the table. first_complex_id <- ComplexMap::getNodeTable(complexMapObject)$complexId[1]  complex_data <- ComplexMap::queryMap(   complexMapObject,   query = first_complex_id,   type = \"complex\" )  dplyr::glimpse(complex_data) #> Rows: 1 #> Columns: 11 #> $ complexId               <chr> \"CpxMap_0414\" #> $ proteinCount            <int> 8 #> $ proteins                <chr> \"WDR3,RB1,PNO1,EMG1,CSNK1E,TPTEP2-CSNK1E,DDX49… #> $ primaryFunctionalDomain <chr> \"BIOCARTA_EICOSANOID_PATHWAY\" #> $ topEnrichedFunctions    <chr> \"BIOCARTA_ARF_PATHWAY, BIOCARTA_BTG2_PATHWAY, … #> $ colorHex                <chr> \"#E41A1C\" #> $ sizeMapping             <dbl> 3 #> $ x                       <dbl> 4.630453 #> $ y                       <dbl> 15.11785 #> $ betweenness             <dbl> 0.05917501 #> $ degree                  <dbl> 45"},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_01-workflow.html","id":"step-5-visualization","dir":"Articles","previous_headings":"","what":"Step 5: Visualization","title":"A Typical Workflow","text":"Finally, can visualize entire functional landscape. ComplexMap provides three visualization functions work directly ComplexMap object. First, extract final node edge tables plotting.","code":"mapLayout <- ComplexMap::getNodeTable(complexMapObject) networkEdges <- ComplexMap::getEdgeTable(complexMapObject)"},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_01-workflow.html","id":"static-plot-with-a-legend","dir":"Articles","previous_headings":"Step 5: Visualization","what":"5.1 Static Plot with a Legend","title":"A Typical Workflow","text":"version useful clean overview, using discrete color legend represent functional domains.","code":"ComplexMap::visualizeMapWithLegend(mapLayout, networkEdges) #> Visualizing ComplexMap with a color legend..."},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_01-workflow.html","id":"interactive-plot","dir":"Articles","previous_headings":"Step 5: Visualization","what":"5.2 Interactive Plot","title":"A Typical Workflow","text":"deep exploration, interactive HTML widget ideal. can zoom, pan, hover nodes see detailed tooltips.","code":"# visNetwork is required for this plot if (requireNamespace(\"visNetwork\", quietly = TRUE)) {   ComplexMap::visualizeMapInteractive(mapLayout, networkEdges) } #> Generating interactive visNetwork plot..."},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_01-workflow.html","id":"conclusion","dir":"Articles","previous_headings":"","what":"Conclusion","title":"A Typical Workflow","text":"vignette demonstrated power simplicity refactored ComplexMap workflow. using main createComplexMap() wrapper, complete analysis can run single step. resulting object can easily interpreted, queried, visualized, providing user-friendly powerful platform exploring landscape protein complexes.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_02-advanced-analysis.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Advanced Analysis","text":"ComplexMap::createComplexMap() function provides seamless, one-step workflow use cases, package also includes suite granular functions users require control, wish benchmark results, need export data tools. vignette covers advanced topics: Granular Workflow Control: Running quality control refinement steps manually inspect intermediate results. Benchmarking Predictions: Using evaluateComplexes() compare experimental complexes reference set like CORUM. Advanced Network Exploration: Adding theme information back ComplexMap object enable powerful, theme-based queries. Interoperability: Exporting final network visualization analysis external software like Cytoscape. use package’s built-datasets demonstration.","code":"# Load the experimental and reference complex lists utils::data(\"demoComplexes\", package = \"ComplexMap\") utils::data(\"referenceComplexes\", package = \"ComplexMap\")"},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_02-advanced-analysis.html","id":"granular-workflow-control","dir":"Articles","previous_headings":"","what":"1. Granular Workflow Control","title":"Advanced Analysis","text":"createComplexMap() function automatically runs quality control refinement. However, can run steps manually using underlying functions better understand tune analysis.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_02-advanced-analysis.html","id":"quality-control","dir":"Articles","previous_headings":"1. Granular Workflow Control","what":"1.1 Quality Control","title":"Advanced Analysis","text":"First, can run qcComplexList() raw input data get detailed report complex sizes redundancy. report provides summary statistics warns us number complex pairs highly redundant (Jaccard similarity >= 0.8). confirms refinement step necessary.","code":"# Run the QC function with verbose output ComplexMap::qcComplexList(demoComplexes) #>  #> --- Running Quality Control on Complex List --- #>  #> [1] Basic Statistics: #>     - Total number of complexes: 622 #>     - Total number of unique proteins: 2649 #>  #> [2] Complex Size Distribution: #>        Min. 1st Qu.  Median    Mean 3rd Qu.    Max. #>       1.000   3.000   4.000   5.183   5.000 102.000 #> Warning in ComplexMap::qcComplexList(demoComplexes): 112 complexes have fewer #> than 3 members. #>  #> [3] Redundancy Analysis: #>     - Distribution of Jaccard similarity scores: #>          Min.   1st Qu.    Median      Mean   3rd Qu.      Max. #>     0.0000000 0.0000000 0.0000000 0.0003226 0.0000000 0.5000000 #>     - No highly redundant complex pairs detected. #>  #> --- QC Complete ---"},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_02-advanced-analysis.html","id":"manual-refinement","dir":"Articles","previous_headings":"1. Granular Workflow Control","what":"1.2 Manual Refinement","title":"Advanced Analysis","text":"Next, can manually run refineComplexList(). allows us inspect set complexes merging functional enrichment, can useful debugging parameter tuning. Running step manually gives us direct access refinedComplexes list inspection proceeding rest workflow.","code":"message(\"Number of complexes before refinement: \", length(demoComplexes)) #> Number of complexes before refinement: 622  # Merge complexes with a Jaccard similarity of 0.75 or higher refinedComplexes <- ComplexMap::refineComplexList(   demoComplexes,   mergeThreshold = 0.75,   verbose = FALSE # Set to TRUE for detailed messages )  message(\"Number of complexes after refinement: \", length(refinedComplexes)) #> Number of complexes after refinement: 510"},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_02-advanced-analysis.html","id":"benchmarking-predictions","dir":"Articles","previous_headings":"","what":"2. Benchmarking Predictions","title":"Advanced Analysis","text":"methods development, essential evaluate well set predicted complexes matches “gold standard” reference. evaluateComplexes() function calculates four standard metrics purpose. compare refinedComplexes referenceComplexes (curated subset CORUM). PPV (Positive Predictive Value): Measures accuracy predictions. Sn (Sensitivity): Measures coverage reference set. Acc (Accuracy): geometric mean PPV Sn. MMR (Maximum Matching Ratio): score based finding best one--one mapping predicted reference complexes. metrics provide quantitative assessment complex prediction quality.","code":"# Evaluate the refined complexes against the reference set evaluationMetrics <- ComplexMap::evaluateComplexes(   predictedComplexes = refinedComplexes,   referenceComplexes = referenceComplexes,   verbose = FALSE )  # Print the resulting metrics print(evaluationMetrics) #> $PPV #> [1] 0.8005051 #>  #> $Sn #> [1] 0.2510583 #>  #> $Acc #> [1] 0.4483006 #>  #> $MMR #> [1] 0.09403458"},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_02-advanced-analysis.html","id":"advanced-network-exploration-querying-by-theme","dir":"Articles","previous_headings":"","what":"3. Advanced Network Exploration: Querying by Theme","title":"Advanced Analysis","text":"main workflow vignette, used summarizeThemes() get table biological themes. powerful advanced technique add theme information back ComplexMap object , enabling direct queries. First, let’s generate ComplexMap object. Now, generate themes add theme assignments node table. prepared object, can now find complexes belonging specific theme, example, “26S Proteasome”. technique provides powerful way programmatically subset analyze biological modules within map.","code":"gmtPath <- ComplexMap::getExampleGmt() gmt <- ComplexMap::getGmtFromFile(gmtPath, verbose = FALSE)  # We use the manually refined list as input cm_obj <- ComplexMap::createComplexMap(   complexList = refinedComplexes,   gmt = gmt,   verbose = FALSE ) #> Metric: 'jaccard' with unit: 'log'; comparing: 231 vectors # Generate the theme summary to get theme labels theme_summary <- ComplexMap::summarizeThemes(cm_obj, verbose = FALSE)  # To get the theme assignment for each node, we must re-run community detection nodes <- ComplexMap::getNodeTable(cm_obj) edges <- ComplexMap::getEdgeTable(cm_obj) graph <- igraph::graph_from_data_frame(d = edges, vertices = nodes, directed = FALSE) communities <- igraph::cluster_louvain(graph)  # Create a mapping from themeId (integer) to themeLabel (character) theme_map <- theme_summary[, c(\"themeId\", \"themeLabel\")]  # Add theme ID and label columns to our node table nodes$themeId <- igraph::membership(communities) nodes <- dplyr::left_join(nodes, theme_map, by = \"themeId\")  # **Crucially, update the object with the new node information** cm_obj$nodes <- nodes # To make the example robust, we query for a theme label that we know # exists because we just generated it in the `theme_summary` table. query_label <- theme_summary$themeLabel  message(\"Dynamically querying for a theme found in the map: \", query_label) #> Dynamically querying for a theme found in the map: BIOCARTA_EICOSANOID_PATHWAYBIOCARTA_EICOSANOID_PATHWAYBIOCARTA_EICOSANOID_PATHWAYBIOCARTA_EICOSANOID_PATHWAYBIOCARTA_EICOSANOID_PATHWAYBIOCARTA_EICOSANOID_PATHWAYBIOCARTA_EICOSANOID_PATHWAYBIOCARTA_EPONFKB_PATHWAYBIOCARTA_EICOSANOID_PATHWAYBIOCARTA_EICOSANOID_PATHWAYBIOCARTA_RAB_PATHWAYBIOCARTA_ETS_PATHWAYBIOCARTA_EICOSANOID_PATHWAYBIOCARTA_MCM_PATHWAYBIOCARTA_EICOSANOID_PATHWAYBIOCARTA_S1P_PATHWAYBIOCARTA_MRP_PATHWAYBIOCARTA_CYTOKINE_PATHWAYBIOCARTA_GABA_PATHWAYBIOCARTA_LDL_PATHWAYBIOCARTA_SAM68_PATHWAYBIOCARTA_NUCLEARRS_PATHWAYMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedBIOCARTA_VITCB_PATHWAYMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedBIOCARTA_ARAP_PATHWAYMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or Unenriched  theme_complexes <- ComplexMap::queryMap(   cm_obj,   query = query_label,   type = \"theme\" ) #> Warning in nodes$themeLabel == query: longer object length is not a multiple of #> shorter object length  # Show the results theme_complexes %>%   dplyr::select(complexId, themeLabel, proteinCount, betweenness) #> # A tibble: 258 × 4 #>    complexId   themeLabel                  proteinCount betweenness #>    <chr>       <chr>                              <int>       <dbl> #>  1 CpxMap_0414 BIOCARTA_EICOSANOID_PATHWAY            8      0.0592 #>  2 CpxMap_0359 BIOCARTA_EICOSANOID_PATHWAY            5      0.0391 #>  3 CpxMap_0501 BIOCARTA_EICOSANOID_PATHWAY           20      0.0326 #>  4 CpxMap_0401 BIOCARTA_EICOSANOID_PATHWAY            6      0.0323 #>  5 CpxMap_0090 BIOCARTA_EICOSANOID_PATHWAY            4      0.0181 #>  6 CpxMap_0491 BIOCARTA_EICOSANOID_PATHWAY           15      0.0181 #>  7 CpxMap_0182 BIOCARTA_EICOSANOID_PATHWAY            4      0.0181 #>  8 CpxMap_0397 BIOCARTA_EICOSANOID_PATHWAY            7      0.0177 #>  9 CpxMap_0177 BIOCARTA_EICOSANOID_PATHWAY            6      0.0177 #> 10 CpxMap_0481 BIOCARTA_EICOSANOID_PATHWAY           10      0.0105 #> # ℹ 248 more rows"},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_02-advanced-analysis.html","id":"interoperability-exporting-to-cytoscape","dir":"Articles","previous_headings":"","what":"4. Interoperability: Exporting to Cytoscape","title":"Advanced Analysis","text":"ComplexMap provides excellent internal visualizations, may want use powerful tools like Cytoscape advanced analysis, network manipulation, creating publication-quality figures. exportNetwork() function writes node edge tables disk tab-separated files (.tsv), can easily imported Cytoscape. use Cytoscape, : Go File > Import > Network File... select _edges.tsv file. mapping dialog, map source_complex_id column “Source Node” target_complex_id “Target Node”. network loaded, go File > Import > Table File... select _nodes.tsv file. Ensure “Key column network” set complexId. import node attributes (colors, sizes, functional domains, etc.) map directly onto network.","code":"# Use a temporary directory for this example temp_dir <- tempdir() file_prefix <- file.path(temp_dir, \"human_complex_map\")  # Export the network ComplexMap::exportNetwork(cm_obj, filePrefix = file_prefix) #> Exporting network in Cytoscape format to: #>  -> /tmp/RtmpDxAzUP/human_complex_map_nodes.tsv #>  -> /tmp/RtmpDxAzUP/human_complex_map_edges.tsv #> Export complete.  # List the files that were created list.files(temp_dir, pattern = \"human_complex_map\") #> [1] \"human_complex_map_edges.tsv\" \"human_complex_map_nodes.tsv\""},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_02-advanced-analysis.html","id":"conclusion","dir":"Articles","previous_headings":"","what":"Conclusion","title":"Advanced Analysis","text":"vignette demonstrated advanced capabilities ComplexMap package. Beyond simple one-step workflow, package provides granular functions quality control, rigorous benchmarking tools methods development, powerful utilities deep, theme-based querying exporting results platforms. layered functionality makes ComplexMap comprehensive toolkit novice expert users.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_02-workflow.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"2. Start a Typical Workflow","text":"Protein complexes functional machinery cell. High-throughput experimental methods can identify hundreds putative protein complexes single experiment. ComplexMap package provides comprehensive, end--end workflow process, analyze, annotate, visualize dataset. vignette demonstrates main analysis workflow using high-level createComplexMap() wrapper function. use dataset human soluble protein complexes, originally published 2012 census human soluble protein complexes, perform complete analysis start finish. showcase downstream analysis functions interpreting exploring results.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_02-workflow.html","id":"step-1-loading-data","dir":"Articles","previous_headings":"","what":"Step 1: Loading Data","title":"2. Start a Typical Workflow","text":"ComplexMap package includes demoComplexes dataset, list 622 putative human protein complexes. also load example gene set (GMT) file functional annotation.","code":"# Load the example complex list shipped with the package utils::data(\"demoComplexes\", package = \"ComplexMap\")  # Get the path to the example GMT file and load it gmtPath <- ComplexMap::getExampleGmt() biocartaGmt <- ComplexMap::getGmtFromFile(gmtPath, verbose = FALSE)"},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_02-workflow.html","id":"step-2-running-the-main-workflow","dir":"Articles","previous_headings":"","what":"Step 2: Running the Main Workflow","title":"2. Start a Typical Workflow","text":"core package createComplexMap() function. single wrapper function handles essential processing steps: Quality Control & Refinement: Filters complexes size merges highly redundant ones. Functional Enrichment: Annotates complex biological functions. Network Construction: Builds similarity network based shared proteins functions. Attribute & Topology Generation: Calculates node colors, sizes, layout coordinates visualization. can pass parameters underlying functions (like mergeThreshold refineComplexList) directly wrapper. output, complexMapObject, formal ComplexMap S3 object contains complete results analysis. Printing object gives high-level summary.","code":"# Run the entire workflow with a single command # We will merge complexes with a Jaccard similarity of 0.75 or higher complexMapObject <- ComplexMap::createComplexMap(   complexList = demoComplexes,   gmt = biocartaGmt,   mergeThreshold = 0.75 ) #> --- Starting ComplexMap Workflow --- #>  #> Step 1: Refining complex list... #>  #> --- Refining Input Complex List --- #> Filtered 112 complexes by size. Retaining 510. #> Identifying merge groups with Jaccard >= 0.75... #> Found 0 merge groups. Merging 0 complexes into 510. #> Merging complete. Final list has 510 complexes. #>  #> --- Refinement Complete --- #>  #> Step 2: Running enrichment analysis... #> Running enrichment for 510 complexes... #> Annotation complete. Found terms for 239 complexes. #>  #> Step 3: Building complex network... #> Building complex network using 'jaccard' similarity... #> Using 11 cores for parallel processing. #> Processing 129795 complex pairs... #> Split into 130 chunks of up to 1000 pairs each. #> Combining results from chunks... #> Calculating final weights and filtering... #> Network construction complete: 1390 edges retained. #>  #> Step 4: Generating node attributes... #> Generating core node attributes (function and color)... #>     -> Clustering terms using 'jaccard' similarity. #> Metric: 'jaccard' with unit: 'log'; comparing: 231 vectors #>  #> Step 5: Computing map topology... #> Computing map topology (layout and centrality)... #> Topology computation complete. #>  #> --- ComplexMap Workflow Complete --- # Print the object to see a summary complexMapObject #> # A ComplexMap Object #> # ── 510 nodes and 1390 edges #> # ── 15 major biological themes identified. #> # ── Use `getNodeTable()` or `getEdgeTable()` to access data."},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_02-workflow.html","id":"step-3-summarizing-biological-themes","dir":"Articles","previous_headings":"","what":"Step 3: Summarizing Biological Themes","title":"2. Start a Typical Workflow","text":"key goal map identify major biological themes. summarizeThemes() function uses community detection algorithms find densely connected network modules provides summary. result table listing theme, descriptive label (derived common function within theme), size terms nodes edges.","code":"themeSummary <- ComplexMap::summarizeThemes(complexMapObject) #> Summarizing themes using the 'louvain' community algorithm... #> Identified 98 distinct themes.  # Display the top 10 largest themes themeSummary %>%   dplyr::arrange(dplyr::desc(nodeCount)) %>%   utils::head(10) #> # A tibble: 10 × 4 #>    themeId    themeLabel                  nodeCount edgeCount #>    <membrshp> <chr>                           <int>     <int> #>  1  1         BIOCARTA_EICOSANOID_PATHWAY        56       180 #>  2  2         BIOCARTA_EICOSANOID_PATHWAY        47        86 #>  3  8         BIOCARTA_ETS_PATHWAY               45        68 #>  4  9         BIOCARTA_EICOSANOID_PATHWAY        31        68 #>  5  6         BIOCARTA_EICOSANOID_PATHWAY        27        47 #>  6  5         BIOCARTA_EICOSANOID_PATHWAY        25        78 #>  7 11         BIOCARTA_EICOSANOID_PATHWAY        25        92 #>  8 12         BIOCARTA_EICOSANOID_PATHWAY        24       101 #>  9  4         BIOCARTA_EICOSANOID_PATHWAY        20        49 #> 10 10         BIOCARTA_EICOSANOID_PATHWAY        20        20"},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_02-workflow.html","id":"step-4-exploring-and-querying-the-map","dir":"Articles","previous_headings":"","what":"Step 4: Exploring and Querying the Map","title":"2. Start a Typical Workflow","text":"queryMap() function provides powerful way programmatically explore results.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_02-workflow.html","id":"querying-for-a-specific-protein","dir":"Articles","previous_headings":"Step 4: Exploring and Querying the Map","what":"4.1 Querying for a Specific Protein","title":"2. Start a Typical Workflow","text":"Let’s find complexes contain protein “SMAD4”.","code":"# To ensure our example is robust, let's find a protein to query # that is guaranteed to be in our final, refined map. nodes <- ComplexMap::getNodeTable(complexMapObject) first_protein_list <- nodes$proteins[1] query_protein <- strsplit(first_protein_list, \",\")[[1]][1]  message(\"Dynamically querying for a protein found in the map: \", query_protein) #> Dynamically querying for a protein found in the map: PRKACB  protein_complexes <- ComplexMap::queryMap(   complexMapObject,   query = query_protein,   type = \"protein\" )  # Show the primary functional domain of the resulting complexes protein_complexes %>%   dplyr::select(complexId, primaryFunctionalDomain, proteins) #> # A tibble: 1 × 3 #>   complexId   primaryFunctionalDomain     proteins                            #>   <chr>       <chr>                       <chr>                               #> 1 CpxMap_0359 BIOCARTA_EICOSANOID_PATHWAY PRKACB,PRKACA,PRKAR2A,CIRBP,CAPRIN1"},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_02-workflow.html","id":"querying-for-a-specific-complex","dir":"Articles","previous_headings":"Step 4: Exploring and Querying the Map","what":"4.2 Querying for a Specific Complex","title":"2. Start a Typical Workflow","text":"can also retrieve data single complex interest.","code":"# Note: The exact CpxMap ID may vary slightly between runs # if refinement results change. We query for the first node in the table. first_complex_id <- ComplexMap::getNodeTable(complexMapObject)$complexId[1]  complex_data <- ComplexMap::queryMap(   complexMapObject,   query = first_complex_id,   type = \"complex\" )  dplyr::glimpse(complex_data) #> Rows: 1 #> Columns: 11 #> $ complexId               <chr> \"CpxMap_0359\" #> $ proteinCount            <int> 5 #> $ proteins                <chr> \"PRKACB,PRKACA,PRKAR2A,CIRBP,CAPRIN1\" #> $ primaryFunctionalDomain <chr> \"BIOCARTA_EICOSANOID_PATHWAY\" #> $ topEnrichedFunctions    <chr> \"BIOCARTA_AGPCR_PATHWAY, BIOCARTA_AKAP13_PATHW… #> $ colorHex                <chr> \"#E41A1B\" #> $ sizeMapping             <dbl> 2.321928 #> $ x                       <dbl> 7.989894 #> $ y                       <dbl> 6.128077 #> $ betweenness             <dbl> 0.1544715 #> $ degree                  <dbl> 33"},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_02-workflow.html","id":"step-5-visualization","dir":"Articles","previous_headings":"","what":"Step 5: Visualization","title":"2. Start a Typical Workflow","text":"Finally, can visualize entire functional landscape. ComplexMap provides three visualization functions work directly ComplexMap object. First, extract final node edge tables plotting.","code":"mapLayout <- ComplexMap::getNodeTable(complexMapObject) networkEdges <- ComplexMap::getEdgeTable(complexMapObject)"},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_02-workflow.html","id":"static-plot-with-a-legend","dir":"Articles","previous_headings":"Step 5: Visualization","what":"5.1 Static Plot with a Legend","title":"2. Start a Typical Workflow","text":"version useful clean overview, using discrete color legend represent functional domains.","code":"ComplexMap::visualizeMapWithLegend(mapLayout, networkEdges) #> Visualizing ComplexMap with a color legend..."},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_02-workflow.html","id":"interactive-plot","dir":"Articles","previous_headings":"Step 5: Visualization","what":"5.2 Interactive Plot","title":"2. Start a Typical Workflow","text":"deep exploration, interactive HTML widget ideal. can zoom, pan, hover nodes see detailed tooltips.","code":"# visNetwork is required for this plot if (requireNamespace(\"visNetwork\", quietly = TRUE)) {   ComplexMap::visualizeMapInteractive(mapLayout, networkEdges) } #> Generating interactive visNetwork plot..."},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_02-workflow.html","id":"conclusion","dir":"Articles","previous_headings":"","what":"Conclusion","title":"2. Start a Typical Workflow","text":"vignette demonstrated power simplicity refactored ComplexMap workflow. using main createComplexMap() wrapper, complete analysis can run single step. resulting object can easily interpreted, queried, visualized, providing user-friendly powerful platform exploring landscape protein complexes.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_03-advanced-analysis.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"3. Explore Advanced Analyses","text":"ComplexMap::createComplexMap() function provides seamless, one-step workflow use cases, package also includes suite granular functions users require control, wish benchmark results, need export data tools. vignette covers advanced topics: Granular Workflow Control: Running quality control refinement steps manually inspect intermediate results. Benchmarking Predictions: Using evaluateComplexes() compare experimental complexes reference set like CORUM. Advanced Network Exploration: Adding theme information back ComplexMap object enable powerful, theme-based queries. Interoperability: Exporting final network visualization analysis external software like Cytoscape. use package’s built-datasets demonstration.","code":"# Load the experimental and reference complex lists utils::data(\"demoComplexes\", package = \"ComplexMap\") utils::data(\"referenceComplexes\", package = \"ComplexMap\")"},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_03-advanced-analysis.html","id":"granular-workflow-control","dir":"Articles","previous_headings":"","what":"1. Granular Workflow Control","title":"3. Explore Advanced Analyses","text":"createComplexMap() function automatically runs quality control refinement. However, can run steps manually using underlying functions better understand tune analysis.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_03-advanced-analysis.html","id":"quality-control","dir":"Articles","previous_headings":"1. Granular Workflow Control","what":"1.1 Quality Control","title":"3. Explore Advanced Analyses","text":"First, can run qcComplexList() raw input data get detailed report complex sizes redundancy. report provides summary statistics warns us number complex pairs highly redundant (Jaccard similarity >= 0.8). confirms refinement step necessary.","code":"# Run the QC function with verbose output ComplexMap::qcComplexList(demoComplexes) #>  #> --- Running Quality Control on Complex List --- #>  #> [1] Basic Statistics: #>     - Total number of complexes: 622 #>     - Total number of unique proteins: 2649 #>  #> [2] Complex Size Distribution: #>        Min. 1st Qu.  Median    Mean 3rd Qu.    Max. #>       1.000   3.000   4.000   5.183   5.000 102.000 #> Warning in ComplexMap::qcComplexList(demoComplexes): 112 complexes have fewer #> than 3 members. #>  #> [3] Redundancy Analysis: #>     - Distribution of Jaccard similarity scores: #>          Min.   1st Qu.    Median      Mean   3rd Qu.      Max. #>     0.0000000 0.0000000 0.0000000 0.0003226 0.0000000 0.5000000 #>     - No highly redundant complex pairs detected. #>  #> --- QC Complete ---"},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_03-advanced-analysis.html","id":"manual-refinement","dir":"Articles","previous_headings":"1. Granular Workflow Control","what":"1.2 Manual Refinement","title":"3. Explore Advanced Analyses","text":"Next, can manually run refineComplexList(). allows us inspect set complexes merging functional enrichment, can useful debugging parameter tuning. Running step manually gives us direct access refinedComplexes list inspection proceeding rest workflow.","code":"message(\"Number of complexes before refinement: \", length(demoComplexes)) #> Number of complexes before refinement: 622  # Merge complexes with a Jaccard similarity of 0.75 or higher refinedComplexes <- ComplexMap::refineComplexList(   demoComplexes,   mergeThreshold = 0.75,   verbose = FALSE # Set to TRUE for detailed messages )  message(\"Number of complexes after refinement: \", length(refinedComplexes)) #> Number of complexes after refinement: 510"},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_03-advanced-analysis.html","id":"benchmarking-predictions","dir":"Articles","previous_headings":"","what":"2. Benchmarking Predictions","title":"3. Explore Advanced Analyses","text":"methods development, essential evaluate well set predicted complexes matches “gold standard” reference. evaluateComplexes() function calculates four standard metrics purpose. compare refinedComplexes referenceComplexes (curated subset CORUM). PPV (Positive Predictive Value): Measures accuracy predictions. Sn (Sensitivity): Measures coverage reference set. Acc (Accuracy): geometric mean PPV Sn. MMR (Maximum Matching Ratio): score based finding best one--one mapping predicted reference complexes. metrics provide quantitative assessment complex prediction quality.","code":"# Evaluate the refined complexes against the reference set evaluationMetrics <- ComplexMap::evaluateComplexes(   predictedComplexes = refinedComplexes,   referenceComplexes = referenceComplexes,   nCores = 2,   verbose = FALSE )  # Print the resulting metrics print(evaluationMetrics) #> $PPV #> [1] 0.8005051 #>  #> $Sn #> [1] 0.2510583 #>  #> $Acc #> [1] 0.4483006 #>  #> $MMR #> [1] 0.09403458"},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_03-advanced-analysis.html","id":"advanced-network-exploration-querying-by-theme","dir":"Articles","previous_headings":"","what":"3. Advanced Network Exploration: Querying by Theme","title":"3. Explore Advanced Analyses","text":"main workflow vignette, used summarizeThemes() get table biological themes. powerful advanced technique add theme information back ComplexMap object , enabling direct queries. First, let’s generate ComplexMap object. Now, generate themes add theme assignments node table. prepared object, can now find complexes belonging specific theme, example, “26S Proteasome”. technique provides powerful way programmatically subset analyze biological modules within map.","code":"gmtPath <- ComplexMap::getExampleGmt() gmt <- ComplexMap::getGmtFromFile(gmtPath, verbose = FALSE)  # We use the manually refined list as input cm_obj <- ComplexMap::createComplexMap(   complexList = refinedComplexes,   gmt = gmt,   verbose = FALSE ) #> Metric: 'jaccard' with unit: 'log'; comparing: 231 vectors # Generate the theme summary to get theme labels theme_summary <- ComplexMap::summarizeThemes(cm_obj, verbose = FALSE)  # To get the theme assignment for each node, we must re-run community detection nodes <- ComplexMap::getNodeTable(cm_obj) edges <- ComplexMap::getEdgeTable(cm_obj) graph <- igraph::graph_from_data_frame(d = edges, vertices = nodes, directed = FALSE) communities <- igraph::cluster_louvain(graph)  # Create a mapping from themeId (integer) to themeLabel (character) theme_map <- theme_summary[, c(\"themeId\", \"themeLabel\")]  # Add theme ID and label columns to our node table nodes$themeId <- igraph::membership(communities) nodes <- dplyr::left_join(nodes, theme_map, by = \"themeId\")  # **Crucially, update the object with the new node information** cm_obj$nodes <- nodes # To make the example robust, we query for a theme label that we know # exists because we just generated it in the `theme_summary` table. query_label <- theme_summary$themeLabel  message(\"Dynamically querying for a theme found in the map: \", query_label) #> Dynamically querying for a theme found in the map: BIOCARTA_EICOSANOID_PATHWAYBIOCARTA_EICOSANOID_PATHWAYBIOCARTA_EICOSANOID_PATHWAYBIOCARTA_EICOSANOID_PATHWAYBIOCARTA_EICOSANOID_PATHWAYBIOCARTA_EICOSANOID_PATHWAYBIOCARTA_SAM68_PATHWAYBIOCARTA_ETS_PATHWAYBIOCARTA_EICOSANOID_PATHWAYBIOCARTA_EICOSANOID_PATHWAYBIOCARTA_EICOSANOID_PATHWAYBIOCARTA_EICOSANOID_PATHWAYBIOCARTA_EPONFKB_PATHWAYBIOCARTA_MRP_PATHWAYBIOCARTA_EICOSANOID_PATHWAYBIOCARTA_EICOSANOID_PATHWAYMixed or UnenrichedMixed or UnenrichedBIOCARTA_MCM_PATHWAYBIOCARTA_RAB_PATHWAYBIOCARTA_EICOSANOID_PATHWAYMixed or UnenrichedBIOCARTA_NUCLEARRS_PATHWAYBIOCARTA_S1P_PATHWAYMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedBIOCARTA_GABA_PATHWAYMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedBIOCARTA_LDL_PATHWAYMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedBIOCARTA_ARAP_PATHWAYMixed or UnenrichedMixed or UnenrichedMixed or Unenriched  theme_complexes <- ComplexMap::queryMap(   cm_obj,   query = query_label,   type = \"theme\" ) #> Warning in nodes$themeLabel == query: longer object length is not a multiple of #> shorter object length  # Show the results theme_complexes %>%   dplyr::select(complexId, themeLabel, proteinCount, betweenness) #> # A tibble: 114 × 4 #>    complexId   themeLabel                  proteinCount betweenness #>    <chr>       <chr>                              <int>       <dbl> #>  1 CpxMap_0359 BIOCARTA_EICOSANOID_PATHWAY            5      0.154  #>  2 CpxMap_0414 BIOCARTA_EICOSANOID_PATHWAY            8      0.136  #>  3 CpxMap_0508 BIOCARTA_EICOSANOID_PATHWAY           42      0.111  #>  4 CpxMap_0401 BIOCARTA_EICOSANOID_PATHWAY            6      0.100  #>  5 CpxMap_0509 BIOCARTA_EICOSANOID_PATHWAY          102      0.0918 #>  6 CpxMap_0090 BIOCARTA_EICOSANOID_PATHWAY            4      0.0888 #>  7 CpxMap_0143 BIOCARTA_EICOSANOID_PATHWAY            4      0.0700 #>  8 CpxMap_0182 BIOCARTA_EICOSANOID_PATHWAY            4      0.0657 #>  9 CpxMap_0501 BIOCARTA_EICOSANOID_PATHWAY           20      0.0598 #> 10 CpxMap_0372 BIOCARTA_EICOSANOID_PATHWAY            6      0.0547 #> # ℹ 104 more rows"},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_03-advanced-analysis.html","id":"interoperability-exporting-to-cytoscape","dir":"Articles","previous_headings":"","what":"4. Interoperability: Exporting to Cytoscape","title":"3. Explore Advanced Analyses","text":"ComplexMap provides excellent internal visualizations, may want use powerful tools like Cytoscape advanced analysis, network manipulation, creating publication-quality figures. exportNetwork() function writes node edge tables disk tab-separated files (.tsv), can easily imported Cytoscape. use Cytoscape, : Go File > Import > Network File... select _edges.tsv file. mapping dialog, map source_complex_id column “Source Node” target_complex_id “Target Node”. network loaded, go File > Import > Table File... select _nodes.tsv file. Ensure “Key column network” set complexId. import node attributes (colors, sizes, functional domains, etc.) map directly onto network.","code":"# Use a temporary directory for this example temp_dir <- tempdir() file_prefix <- file.path(temp_dir, \"human_complex_map\")  # Export the network ComplexMap::exportNetwork(cm_obj, filePrefix = file_prefix) #> Exporting network in Cytoscape format to: #>  -> /var/folders/x8/ngpdbcfd3pj5sf3r9kkxgs740000gn/T//RtmpZDxIxh/human_complex_map_nodes.tsv #>  -> /var/folders/x8/ngpdbcfd3pj5sf3r9kkxgs740000gn/T//RtmpZDxIxh/human_complex_map_edges.tsv #> Export complete.  # List the files that were created list.files(temp_dir, pattern = \"human_complex_map\") #> [1] \"human_complex_map_edges.tsv\" \"human_complex_map_nodes.tsv\""},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_03-advanced-analysis.html","id":"conclusion","dir":"Articles","previous_headings":"","what":"Conclusion","title":"3. Explore Advanced Analyses","text":"vignette demonstrated advanced capabilities ComplexMap package. Beyond simple one-step workflow, package provides granular functions quality control, rigorous benchmarking tools methods development, powerful utilities deep, theme-based querying exporting results platforms. layered functionality makes ComplexMap comprehensive toolkit novice expert users.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Qingzhou Zhang. Author, maintainer.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Zhang Q (2025). ComplexMap: Toolset Functional Analysis Visualization Protein Complex Data. R package version 1.0.0, https://zqzneptune.github.io/ComplexMap.","code":"@Manual{,   title = {ComplexMap: A Toolset for the Functional Analysis and Visualization of Protein Complex Data},   author = {Qingzhou Zhang},   year = {2025},   note = {R package version 1.0.0},   url = {https://zqzneptune.github.io/ComplexMap}, }"},{"path":"https://zqzneptune.github.io/ComplexMap/index.html","id":"complexmap-","dir":"","previous_headings":"","what":"A Toolset for the Functional Analysis and Visualization of Protein Complex Data","title":"A Toolset for the Functional Analysis and Visualization of Protein Complex Data","text":"ComplexMap R package provides complete, end--end workflow analysis protein complex datasets. designed take raw list putative protein complexes transform fully annotated, publication-ready functional map.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/index.html","id":"core-features","dir":"","previous_headings":"","what":"Core Features","title":"A Toolset for the Functional Analysis and Visualization of Protein Complex Data","text":"Integrated Workflow: Go raw complex list final network map single function, createComplexMap(). Quality Control & Refinement: Automatically filter complexes size merge redundant groups create clean, non-redundant dataset. Functional Enrichment: Annotate complexes using gene sets local files, MSigDB, Gene Ontology, Reactome. Powerful Visualizations: Generate static (ggplot2) interactive (visNetwork) plots explore functional landscape. Quantitative Analysis: Summarize biological themes using community detection programmatically query map specific proteins, complexes, themes. Benchmarking: Quantitatively evaluate predicted complexes reference standard like CORUM.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"A Toolset for the Functional Analysis and Visualization of Protein Complex Data","text":"can install stable version ComplexMap GitHub. installer automatically handle required dependencies CRAN Bioconductor.","code":"# If you don't have remotes installed: install.packages(\"remotes\") remotes::install_github(\"zqzneptune/ComplexMap\")"},{"path":"https://zqzneptune.github.io/ComplexMap/index.html","id":"workflow-at-a-glance","dir":"","previous_headings":"","what":"Workflow at a Glance","title":"A Toolset for the Functional Analysis and Visualization of Protein Complex Data","text":"example demonstrates core workflow: analyzing included human protein complex dataset generating functional map single command.","code":"library(ComplexMap)  # 1. Load the example complex list and a gene set file utils::data(\"demoComplexes\") gmt_file <- ComplexMap::getExampleGmt() gmt <- ComplexMap::getGmtFromFile(gmt_file, verbose = FALSE)  # 2. Run the entire workflow # We can pass arguments to underlying functions, like `mergeThreshold`, directly. cm_obj <- ComplexMap::createComplexMap(   complexList = demoComplexes,   gmt = gmt,   mergeThreshold = 0.8,   verbose = FALSE # Set to TRUE to see workflow steps )  # 3. Print the resulting object for a high-level summary cm_obj #> # A ComplexMap Object #> ── 490 nodes and 12931 edges #> ── 15 major biological themes identified. #> ── Use `getNodeTable()` or `getEdgeTable()` to access data.  # 4. Visualize the map node_tbl <- ComplexMap::getNodeTable(cm_obj) edge_tbl <- ComplexMap::getEdgeTable(cm_obj)  ComplexMap::visualizeMapWithLegend(node_tbl, edge_tbl, verbose = FALSE)"},{"path":"https://zqzneptune.github.io/ComplexMap/index.html","id":"exploring-the-results","dir":"","previous_headings":"","what":"Exploring the Results","title":"A Toolset for the Functional Analysis and Visualization of Protein Complex Data","text":"ComplexMap object can easily analyzed downstream functions.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/index.html","id":"summarize-biological-themes","dir":"","previous_headings":"Exploring the Results","what":"Summarize Biological Themes","title":"A Toolset for the Functional Analysis and Visualization of Protein Complex Data","text":"Identify major biological themes (network modules) using community detection.","code":"theme_summary <- ComplexMap::summarizeThemes(cm_obj, verbose = FALSE)  # Show the 10 largest themes dplyr::slice_max(theme_summary, n = 10, order_by = nodeCount)"},{"path":"https://zqzneptune.github.io/ComplexMap/index.html","id":"query-the-map","dir":"","previous_headings":"Exploring the Results","what":"Query the Map","title":"A Toolset for the Functional Analysis and Visualization of Protein Complex Data","text":"Programmatically find specific complexes interest.","code":"# Find the complex with the ID \"CpxMap_0001\" result <- ComplexMap::queryMap(cm_obj, query = \"CpxMap_0001\", type = \"complex\")  # Show some of its key attributes dplyr::select(result, complexId, primaryFunctionalDomain, proteinCount, degree)"},{"path":"https://zqzneptune.github.io/ComplexMap/index.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"A Toolset for the Functional Analysis and Visualization of Protein Complex Data","text":"use ComplexMap research, please cite publication (link added upon publication). now, can cite package : Qingzhou Zhang (2025). ComplexMap: Toolset Functional Analysis Visualization Protein Complex Data. R package version 1.0.0. https://github.com/zqzneptune/ComplexMap","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/index.html","id":"contributing","dir":"","previous_headings":"","what":"Contributing","title":"A Toolset for the Functional Analysis and Visualization of Protein Complex Data","text":"Please note ComplexMap project released Contributor Code Conduct. contributing project, agree abide terms. welcome bug reports, feature requests, pull requests.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/buildComplexNetwork.html","id":null,"dir":"Reference","previous_headings":"","what":"Build a Complex-Complex Interaction Network — buildComplexNetwork","title":"Build a Complex-Complex Interaction Network — buildComplexNetwork","text":"Constructs network complexes edges represent similarity. similarity can based shared proteins (compositional), shared functional annotations (functional), weighted combination .","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/buildComplexNetwork.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Build a Complex-Complex Interaction Network — buildComplexNetwork","text":"","code":"buildComplexNetwork(   complexes,   enrichments,   mode = \"combined\",   similarityMethod = \"jaccard\",   alpha = 0.5,   nCores = NULL,   chunkSize = 1000,   verbose = TRUE )"},{"path":"https://zqzneptune.github.io/ComplexMap/reference/buildComplexNetwork.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Build a Complex-Complex Interaction Network — buildComplexNetwork","text":"complexes named list protein complexes. enrichments named list enrichment results, corresponding `complexes`. Typically output `runComplexEnrichment`. mode character string specifying calculate final edge weight. One \"functional\", \"compositional\", \"combined\". similarityMethod metric used compositional functional similarity. One \"jaccard\", \"overlap\", \"dice\". alpha numeric value (0-1) used \"combined\" mode weigh compositional similarity score. nCores number CPU cores parallel processing. Defaults one less available. chunkSize number complex pairs process parallel chunk. verbose logical value indicating whether show progress messages progress bar.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/buildComplexNetwork.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Build a Complex-Complex Interaction Network — buildComplexNetwork","text":"`tibble` representing network edges. row includes source target_complex_id complexes, similarity scores, shared component counts, final calculated `weight`, `similarity_mode`.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/buildComplexNetwork.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Build a Complex-Complex Interaction Network — buildComplexNetwork","text":"function calculates pairwise similarities complexes list. highly optimized large datasets using chunking parallel processing via `future` framework. final edge weight determined `mode`: - `\"compositional\"`: Uses protein similarity score. - `\"functional\"`: Uses functional annotation similarity score. - `\"combined\"`: Uses weighted average:   `alpha * compositional + (1 - alpha) * functional`. `progressr` package installed, progress bar displayed parallel computation `verbose = TRUE`.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/buildComplexNetwork.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Build a Complex-Complex Interaction Network — buildComplexNetwork","text":"Qingzhou Zhang <zqzneptune@hotmail.com>","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/buildComplexNetwork.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Build a Complex-Complex Interaction Network — buildComplexNetwork","text":"","code":"# --- Sample Data (from previous examples) --- complexes <- list(   Cpx1 = c(\"A\", \"B\", \"C\", \"D\"),   Cpx2 = c(\"A\", \"B\", \"C\", \"E\"), # similar to Cpx1   Cpx3 = c(\"F\", \"G\", \"H\") ) enrichments <- list(   Cpx1 = data.frame(ID = c(\"GO:1\", \"GO:2\")),   Cpx2 = data.frame(ID = c(\"GO:1\", \"GO:3\")), # functionally similar to Cpx1   Cpx3 = data.frame(ID = c(\"GO:4\")) )  # --- Build Network (using 2 cores for the example) --- network <- buildComplexNetwork(   complexes, enrichments, mode = \"combined\", nCores = 2 ) #> Building complex network using 'jaccard' similarity... #> Using 2 cores for parallel processing. #> Processing 3 complex pairs... #> Split into 1 chunks of up to 1000 pairs each. #> Combining results from chunks... #> Calculating final weights and filtering... #> Network construction complete: 1 edges retained. print(network) #> # A tibble: 1 × 8 #>   source_complex_id target_complex_id compSim funcSim sharedProt sharedFunc #>   <chr>             <chr>               <dbl>   <dbl>      <int>      <int> #> 1 Cpx1              Cpx2                  0.6   0.333          3          1 #> # ℹ 2 more variables: weight <dbl>, similarity_mode <chr>"},{"path":"https://zqzneptune.github.io/ComplexMap/reference/computeMapTopology.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Network Topology and Layout Coordinates — computeMapTopology","title":"Compute Network Topology and Layout Coordinates — computeMapTopology","text":"Calculates 2D layout coordinates key centrality metrics complex network. function serves final step preparing network data visualization.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/computeMapTopology.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute Network Topology and Layout Coordinates — computeMapTopology","text":"","code":"computeMapTopology(nodeAttributes, network, verbose = TRUE)"},{"path":"https://zqzneptune.github.io/ComplexMap/reference/computeMapTopology.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute Network Topology and Layout Coordinates — computeMapTopology","text":"nodeAttributes `tibble` `data.frame` containing attributes node (complex). Must contain column node identifiers matches source/target columns `network` data. network `tibble` `data.frame` representing network edges. Must contain columns source, target, edge `weight`. verbose logical value indicating whether print progress messages. Defaults `TRUE`.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/computeMapTopology.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute Network Topology and Layout Coordinates — computeMapTopology","text":"`tibble` containing original columns `nodeAttributes` plus four new columns: `x`, `y` (layout coordinates), `betweenness`, `degree`. table arranged descending order betweenness degree.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/computeMapTopology.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute Network Topology and Layout Coordinates — computeMapTopology","text":"function takes node attribute table edge list (network) performs following steps: 1.  Constructs `igraph` graph object provided data. 2.  Computes force-directed layout using Fruchterman-Reingold algorithm     via `ggraph::create_layout`. Edge weights used influence     layout, pulling strongly connected nodes closer together. 3.  Calculates node centrality metrics:     - **Betweenness Centrality:** Measures often node lies       shortest path nodes (normalized).     - **Degree Centrality:** number edges connected node. 4.  Merges layout coordinates centrality scores back original     node attribute table.","code":""},{"path":[]},{"path":"https://zqzneptune.github.io/ComplexMap/reference/computeMapTopology.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Compute Network Topology and Layout Coordinates — computeMapTopology","text":"Qingzhou Zhang <zqzneptune@hotmail.com>","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/computeMapTopology.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute Network Topology and Layout Coordinates — computeMapTopology","text":"","code":"# --- Sample Data --- # 1. Node attributes nodes <- tibble::tibble(   complexId = c(\"Cpx1\", \"Cpx2\", \"Cpx3\"),   proteinCount = c(10, 8, 12) )  # 2. Network edges net <- tibble::tibble(   source = c(\"Cpx1\", \"Cpx2\"),   target = c(\"Cpx2\", \"Cpx3\"),   weight = c(0.8, 0.6) )  # --- Compute Topology --- masterLayout <- computeMapTopology(nodes, net) #> Computing map topology (layout and centrality)... #> Topology computation complete. print(masterLayout) #> # A tibble: 3 × 6 #>   complexId proteinCount     x        y betweenness degree #>   <chr>            <dbl> <dbl>    <dbl>       <dbl>  <dbl> #> 1 Cpx2                 8 -3.25  0.00972           1      2 #> 2 Cpx1                10 -2.42  0.925             0      1 #> 3 Cpx3                12 -4.16 -1.00              0      1"},{"path":"https://zqzneptune.github.io/ComplexMap/reference/createComplexMap.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a Complete Complex Map Object — createComplexMap","title":"Create a Complete Complex Map Object — createComplexMap","text":"high-level wrapper function executes entire `ComplexMap` workflow. takes list protein complexes gene set matrix (GMT) performs refinement, enrichment, network construction, topology calculation.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/createComplexMap.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a Complete Complex Map Object — createComplexMap","text":"","code":"createComplexMap(complexList, gmt, verbose = TRUE, ...)"},{"path":"https://zqzneptune.github.io/ComplexMap/reference/createComplexMap.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a Complete Complex Map Object — createComplexMap","text":"complexList named list element character vector protein identifiers representing complex. gmt named list element character vector genes, representing functional gene set (e.g., GMT file). verbose logical value indicating whether print progress messages entire workflow. Defaults `TRUE`. ... Additional arguments passed core functions. Common arguments include: - `minSize`, `maxSize`, `mergeThreshold` (`refineComplexList`) - `pAdjustMethod`, `pValueCutoff` (`runComplexEnrichment`) - `mode`, `similarityMethod`, `alpha` (`buildComplexNetwork`)","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/createComplexMap.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a Complete Complex Map Object — createComplexMap","text":"validated `ComplexMap` S3 object containing final node   edge tables.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/createComplexMap.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create a Complete Complex Map Object — createComplexMap","text":"function serves primary entry point analyses. internally calls core workflow following order: 1.  `refineComplexList()` 2.  `runComplexEnrichment()` 3.  `buildComplexNetwork()` 4.  `generateNodeAttributes()` 5.  `computeMapTopology()` Arguments underlying functions can passed directly wrapper via `...` parameter.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/createComplexMap.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Create a Complete Complex Map Object — createComplexMap","text":"Qingzhou Zhang <zqzneptune@hotmail.com>","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/createComplexMap.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a Complete Complex Map Object — createComplexMap","text":"","code":"# Assume 'demoComplexes' and a 'gmt' object are loaded # gmtPath <- getExampleGmt() # gmt <- getGmtFromFile(gmtPath, verbose = FALSE)  # Run the full workflow with custom parameters # complexMapObject <- createComplexMap( #   demoComplexes, #   gmt, #   verbose = TRUE, #   minSize = 5, #   mergeThreshold = 0.8, #   pValueCutoff = 0.01, #   mode = \"combined\" # ) # print(complexMapObject)"},{"path":"https://zqzneptune.github.io/ComplexMap/reference/demoComplexes.html","id":null,"dir":"Reference","previous_headings":"","what":"Example Protein Complex List — demoComplexes","title":"Example Protein Complex List — demoComplexes","text":"dataset containing list 622 putative protein complexes identified study using integrative global proteomic profiling approach. dataset intended use package examples vignettes.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/demoComplexes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Example Protein Complex List — demoComplexes","text":"","code":"demoComplexes"},{"path":"https://zqzneptune.github.io/ComplexMap/reference/demoComplexes.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Example Protein Complex List — demoComplexes","text":"named list 622 elements. element character vector protein identifiers representing single complex.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/demoComplexes.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Example Protein Complex List — demoComplexes","text":"Supplementary Table 3 (first tab) : Havugimana PC, Hart GT, Nepusz T, Yang H, Turinsky AL, Li Z, Wang PI, Boutz DR, Fong V, Phanse S, Babu M, Craig SA, Hu P, Wan C, Vlasblom J, Dar VU, Bezginov , Clark GW, Wu GC, Wodak SJ, Tillier ER, Paccanaro , Marcotte EM, Emili . *census human soluble protein complexes.* Cell. 2012 Aug 31;150(5):1068-81. doi: 10.1016/j.cell.2012.08.011. PMID: 22939629; PMCID: PMC3477804.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/demoComplexes.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Example Protein Complex List — demoComplexes","text":"complexes derived chromatographic separation cultured human cell extracts one thousand biochemical fractions, followed quantitative tandem mass spectrometry analysis. 622 complexes linked core biological processes include candidate disease genes unannotated proteins.","code":""},{"path":[]},{"path":"https://zqzneptune.github.io/ComplexMap/reference/dot-calculateSimilarity.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate a Similarity Score Between Two Sets — .calculateSimilarity","title":"Calculate a Similarity Score Between Two Sets — .calculateSimilarity","text":"internal helper function computes one three common similarity metrics: Jaccard, Overlap, Dice.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/dot-calculateSimilarity.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate a Similarity Score Between Two Sets — .calculateSimilarity","text":"","code":".calculateSimilarity(set1, set2, method = \"jaccard\")"},{"path":"https://zqzneptune.github.io/ComplexMap/reference/dot-calculateSimilarity.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate a Similarity Score Between Two Sets — .calculateSimilarity","text":"set1 character vector representing first set. set2 character vector representing second set. method similarity metric use. One \"jaccard\", \"overlap\", \"dice\".","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/dot-calculateSimilarity.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate a Similarity Score Between Two Sets — .calculateSimilarity","text":"numeric similarity score 0 1. Returns 0 either   set empty intersection.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/evaluateComplexes.html","id":null,"dir":"Reference","previous_headings":"","what":"Evaluate Predicted Protein Complexes Against a Reference Set — evaluateComplexes","title":"Evaluate Predicted Protein Complexes Against a Reference Set — evaluateComplexes","text":"Calculates four standard metrics evaluating protein complex predictions: Positive Predictive Value (PPV), Sensitivity (Sn), Accuracy (Acc), Maximum Matching Ratio (MMR).","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/evaluateComplexes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Evaluate Predicted Protein Complexes Against a Reference Set — evaluateComplexes","text":"","code":"evaluateComplexes(   predictedComplexes,   referenceComplexes,   nCores = NULL,   verbose = TRUE )"},{"path":"https://zqzneptune.github.io/ComplexMap/reference/evaluateComplexes.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Evaluate Predicted Protein Complexes Against a Reference Set — evaluateComplexes","text":"predictedComplexes list predicted protein complexes. referenceComplexes list reference (gold standard) complexes. nCores number CPU cores use parallel computation. Defaults one less total number detected cores. verbose logical value indicating whether print progress messages. Defaults `TRUE`.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/evaluateComplexes.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Evaluate Predicted Protein Complexes Against a Reference Set — evaluateComplexes","text":"named list containing four numeric values: `PPV`, `Sn`, `Acc`, `MMR`. Returns `NA` metrics either input list empty.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/evaluateComplexes.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Evaluate Predicted Protein Complexes Against a Reference Set — evaluateComplexes","text":"function optimized speed calculating shared intersection matrix predicted reference complexes parallel. matrix used basis four metric calculations. - **PPV, Sn, Acc** calculated based confusion matrix   predicted reference complexes, described literature (e.g.,   Zhang et al., 2012). - **MMR** calculated first deriving overlap score matrix,   score predicted complex (P) reference complex (R)   `|P ∩ R|² / (|P| * |R|)`.   [Hungarian algorithm](https://en.wikipedia.org/wiki/Hungarian_algorithm)   used solve maximum weight bipartite matching problem.   approach based method described Nepusz et al. (2012). parallel computation uses `parallel::mclapply`, available Windows. Windows, calculation run sequentially.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/evaluateComplexes.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Evaluate Predicted Protein Complexes Against a Reference Set — evaluateComplexes","text":"Nepusz, T., Yu, H. & Paccanaro, . (2012). Detecting overlapping protein complexes protein-protein interaction networks. *Nature Methods*, 9, 471–472. doi:10.1038/nmeth.1938 Zhang XF, Dai DQ, Ou-Yang L, Wu (2012). Exploring Overlapping Functional Units Various Structure Protein Interaction Networks. *PLOS ONE*, 7(8): e43092. doi:10.1371/journal.pone.0043092","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/evaluateComplexes.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Evaluate Predicted Protein Complexes Against a Reference Set — evaluateComplexes","text":"Qingzhou Zhang <zqzneptune@hotmail.com>","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/evaluateComplexes.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Evaluate Predicted Protein Complexes Against a Reference Set — evaluateComplexes","text":"","code":"# --- Sample Data --- # Predicted complexes pred1 <- c(\"A\", \"B\", \"C\") pred2 <- c(\"D\", \"E\", \"F\") pred3 <- c(\"A\", \"G\", \"H\") predicted <- list(P1 = pred1, P2 = pred2, P3 = pred3)  # Reference complexes (gold standard) ref1 <- c(\"A\", \"B\", \"C\", \"X\") # Good match for pred1 ref2 <- c(\"D\", \"E\", \"F\")     # Perfect match for pred2 ref3 <- c(\"I\", \"J\", \"K\")     # Unmatched complex reference <- list(R1 = ref1, R2 = ref2, R3 = ref3)  # --- Evaluation --- # Use 2 cores for the example metrics <- evaluateComplexes(predicted, reference, nCores = 2) #>  #> --- Evaluating Complex Predictions --- #> [1] Calculating intersections using 2 core(s)... #> [2] Calculating PPV, Sensitivity, and Accuracy... #> [3] Calculating Maximum Matching Ratio (MMR)... #>  #> --- Evaluation Complete --- print(metrics) #> $PPV #> [1] 1 #>  #> $Sn #> [1] 0.6 #>  #> $Acc #> [1] 0.7745967 #>  #> $MMR #> [1] 0.5833333 #>"},{"path":"https://zqzneptune.github.io/ComplexMap/reference/exportNetwork.html","id":null,"dir":"Reference","previous_headings":"","what":"Export a ComplexMap Network for External Tools — exportNetwork","title":"Export a ComplexMap Network for External Tools — exportNetwork","text":"function exports node edge tables `ComplexMap` object format suitable widely used network visualization software, Cytoscape.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/exportNetwork.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Export a ComplexMap Network for External Tools — exportNetwork","text":"","code":"exportNetwork(   complexMapObject,   filePrefix,   format = \"cytoscape\",   verbose = TRUE )"},{"path":"https://zqzneptune.github.io/ComplexMap/reference/exportNetwork.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Export a ComplexMap Network for External Tools — exportNetwork","text":"complexMapObject `ComplexMap` object returned `createComplexMap()`. filePrefix character string used prefix output filenames. example, `filePrefix` \"my_map\" result \"my_map_nodes.tsv\" \"my_map_edges.tsv\". format character string specifying output format. Currently, `\"cytoscape\"` supported. verbose logical value indicating whether print confirmation message upon successful export.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/exportNetwork.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Export a ComplexMap Network for External Tools — exportNetwork","text":"function called side effect writing files disk.   return value.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/exportNetwork.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Export a ComplexMap Network for External Tools — exportNetwork","text":"function currently supports one format: - `\"cytoscape\"`: option generates two separate tab-separated value   (.tsv) files. One file contains node attributes (`<filePrefix>_nodes.tsv`)   contains edge list attributes   (`<filePrefix>_edges.tsv`). files can directly imported   Cytoscape's network attribute tables. function uses `utils::write.table` robust standard-compliant file writing.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/exportNetwork.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Export a ComplexMap Network for External Tools — exportNetwork","text":"Qingzhou Zhang <zqzneptune@hotmail.com>","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/exportNetwork.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Export a ComplexMap Network for External Tools — exportNetwork","text":"","code":"# Assume 'cm_obj' is a valid ComplexMap object # dir <- tempdir() # Use a temporary directory for the example # exportNetwork(cm_obj, filePrefix = file.path(dir, \"myNetwork\"))"},{"path":"https://zqzneptune.github.io/ComplexMap/reference/generateNodeAttributes.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate Node Attributes for a Complex Network — generateNodeAttributes","title":"Generate Node Attributes for a Complex Network — generateNodeAttributes","text":"Creates detailed attribute table complex, suitable network visualization. Attributes include protein count, primary functional domain, top enriched functions, unique color representing complex's functional profile.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/generateNodeAttributes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate Node Attributes for a Complex Network — generateNodeAttributes","text":"","code":"generateNodeAttributes(   complexes,   enrichments,   similarityMethod = \"jaccard\",   verbose = TRUE )"},{"path":"https://zqzneptune.github.io/ComplexMap/reference/generateNodeAttributes.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate Node Attributes for a Complex Network — generateNodeAttributes","text":"complexes named list protein complexes. enrichments named list enrichment results, typically `runComplexEnrichment`. element data frame least `ID`, `Description`, `p.adjust` columns. similarityMethod distance/similarity method passed `philentropy::distance` clustering terms. Defaults \"jaccard\". verbose logical value indicating whether print progress messages. Defaults `TRUE`.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/generateNodeAttributes.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate Node Attributes for a Complex Network — generateNodeAttributes","text":"`tibble` row corresponds complex. columns include: `complexId`, `proteinCount`, `proteins`, `primaryFunctionalDomain`, `topEnrichedFunctions`, `colorHex`, `sizeMapping`.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/generateNodeAttributes.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate Node Attributes for a Complex Network — generateNodeAttributes","text":"function performs several steps generate rich node attributes: 1.  aggregates enriched terms input `enrichments` list. 2.  term-complex matrix built, terms clustered based     co-occurrence complexes using specified similarity metric.     groups related functional terms \"functional domains\". 3.  unique color assigned functional domain using qualitative     palette `RColorBrewer`. 4.  complex, determines primary functional domain based     significant enriched term. 5.  unique \"blended\" color calculated complex mixing     colors associated domains, weighted significance     (-log10 p-value) enriched terms. 6.  Basic attributes like protein count list proteins also included. Complexes significant enrichments assigned default \"Unenriched\" domain grey color.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/generateNodeAttributes.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Generate Node Attributes for a Complex Network — generateNodeAttributes","text":"Qingzhou Zhang <zqzneptune@hotmail.com>","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/generateNodeAttributes.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate Node Attributes for a Complex Network — generateNodeAttributes","text":"","code":"# --- Sample Data --- complexes <- list(   Cpx1 = c(\"A\", \"B\", \"C\"),   Cpx2 = c(\"C\", \"D\", \"E\"),   Cpx3 = c(\"F\", \"G\") # Unenriched ) enrichments <- list(   Cpx1 = data.frame(ID = \"GO:1\", Description = \"Term A\", p.adjust = 0.01),   Cpx2 = data.frame(ID = \"GO:2\", Description = \"Term B\", p.adjust = 0.02) )  # --- Generate Node Attributes --- nodeAttrs <- generateNodeAttributes(complexes, enrichments) #> Generating core node attributes (function and color)... #>     -> Clustering terms using 'jaccard' similarity. #> Metric: 'jaccard' with unit: 'log'; comparing: 2 vectors print(nodeAttrs) #> # A tibble: 3 × 7 #>   complexId proteinCount proteins primaryFunctionalDomain topEnrichedFunctions #>   <chr>            <int> <chr>    <chr>                   <chr>                #> 1 Cpx1                 3 A,B,C    Term A                  Term A               #> 2 Cpx2                 3 C,D,E    Term B                  Term B               #> 3 Cpx3                 2 F,G      Unenriched              NA                   #> # ℹ 2 more variables: colorHex <chr>, sizeMapping <dbl>"},{"path":"https://zqzneptune.github.io/ComplexMap/reference/getEdgeTable.html","id":null,"dir":"Reference","previous_headings":"","what":"Get the Edge Table from a ComplexMap Object — getEdgeTable","title":"Get the Edge Table from a ComplexMap Object — getEdgeTable","text":"simple accessor function extract tibble network edges `ComplexMap` object.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/getEdgeTable.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get the Edge Table from a ComplexMap Object — getEdgeTable","text":"","code":"getEdgeTable(cm)"},{"path":"https://zqzneptune.github.io/ComplexMap/reference/getEdgeTable.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get the Edge Table from a ComplexMap Object — getEdgeTable","text":"cm `ComplexMap` object, typically output `createComplexMap()`.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/getEdgeTable.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get the Edge Table from a ComplexMap Object — getEdgeTable","text":"`tibble` containing edge data.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/getEdgeTable.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get the Edge Table from a ComplexMap Object — getEdgeTable","text":"","code":"# Assuming 'myComplexMap' is a valid ComplexMap object # edgeData <- getEdgeTable(myComplexMap)"},{"path":"https://zqzneptune.github.io/ComplexMap/reference/getExampleGmt.html","id":null,"dir":"Reference","previous_headings":"","what":"Get the Path to an Example GMT File — getExampleGmt","title":"Get the Path to an Example GMT File — getExampleGmt","text":"Provides full system path example gene set (GMT) file included ComplexMap package.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/getExampleGmt.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get the Path to an Example GMT File — getExampleGmt","text":"","code":"getExampleGmt()"},{"path":"https://zqzneptune.github.io/ComplexMap/reference/getExampleGmt.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get the Path to an Example GMT File — getExampleGmt","text":"character string containing full path example GMT file.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/getExampleGmt.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Get the Path to an Example GMT File — getExampleGmt","text":"included file BioCarta gene set collection Molecular Signatures Database (MSigDB v2025.1). function makes easy access file use examples vignettes.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/getExampleGmt.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get the Path to an Example GMT File — getExampleGmt","text":"","code":"# Get the path gmtPath <- getExampleGmt()  # You can then read the file using the path if (file.exists(gmtPath)) {   exampleGmt <- getGmtFromFile(gmtPath) } #> Fetching gene sets from local file: /private/var/folders/x8/ngpdbcfd3pj5sf3r9kkxgs740000gn/T/RtmpojqfcE/temp_libpath40eca16c79e/ComplexMap/extdata/c2.cp.biocarta.v2025.1.Hs.symbols.gmt"},{"path":"https://zqzneptune.github.io/ComplexMap/reference/getGmtFromFile.html","id":null,"dir":"Reference","previous_headings":"","what":"Read a GMT File from a Local Path — getGmtFromFile","title":"Read a GMT File from a Local Path — getGmtFromFile","text":"Parses local GMT (Gene Matrix Transposed) file standard named-list format.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/getGmtFromFile.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Read a GMT File from a Local Path — getGmtFromFile","text":"","code":"getGmtFromFile(filepath, verbose = TRUE)"},{"path":"https://zqzneptune.github.io/ComplexMap/reference/getGmtFromFile.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Read a GMT File from a Local Path — getGmtFromFile","text":"filepath path local .gmt file. verbose logical value indicating whether print progress messages.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/getGmtFromFile.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Read a GMT File from a Local Path — getGmtFromFile","text":"named list names gene set names values character   vectors genes.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/getGoGmt.html","id":null,"dir":"Reference","previous_headings":"","what":"Fetch Gene Ontology (GO) Gene Sets — getGoGmt","title":"Fetch Gene Ontology (GO) Gene Sets — getGoGmt","text":"Fetches GO terms associated genes Bioconductor AnnotationDb package.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/getGoGmt.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fetch Gene Ontology (GO) Gene Sets — getGoGmt","text":"","code":"getGoGmt(   speciesDb,   ontology = \"BP\",   minGmtSize = 10,   maxGmtSize = 500,   verbose = TRUE )"},{"path":"https://zqzneptune.github.io/ComplexMap/reference/getGoGmt.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fetch Gene Ontology (GO) Gene Sets — getGoGmt","text":"speciesDb AnnotationDb object target species (e.g., `org.Hs.eg.db`). ontology GO ontology fetch. One \"BP\", \"MF\", \"CC\". minGmtSize minimum number genes GO term included. maxGmtSize maximum number genes GO term included. verbose logical value indicating whether print progress messages.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/getGoGmt.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fetch Gene Ontology (GO) Gene Sets — getGoGmt","text":"named list names GO terms values character   vectors Entrez IDs.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/getMsigdbGmt.html","id":null,"dir":"Reference","previous_headings":"","what":"Fetch Gene Sets from MSigDB — getMsigdbGmt","title":"Fetch Gene Sets from MSigDB — getMsigdbGmt","text":"wrapper `msigdbr::msigdbr` fetch gene sets format named list (GMT format).","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/getMsigdbGmt.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fetch Gene Sets from MSigDB — getMsigdbGmt","text":"","code":"getMsigdbGmt(species = \"Homo sapiens\", collection = \"H\", verbose = TRUE)"},{"path":"https://zqzneptune.github.io/ComplexMap/reference/getMsigdbGmt.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fetch Gene Sets from MSigDB — getMsigdbGmt","text":"species scientific name species (e.g., \"Homo sapiens\"). collection MSigDB collection code (e.g., \"H\" hallmark). verbose logical value indicating whether print progress messages.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/getMsigdbGmt.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fetch Gene Sets from MSigDB — getMsigdbGmt","text":"named list names gene set names values character   vectors gene symbols.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/getNodeTable.html","id":null,"dir":"Reference","previous_headings":"","what":"Get the Node Table from a ComplexMap Object — getNodeTable","title":"Get the Node Table from a ComplexMap Object — getNodeTable","text":"simple accessor function extract tibble node attributes layout data `ComplexMap` object.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/getNodeTable.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get the Node Table from a ComplexMap Object — getNodeTable","text":"","code":"getNodeTable(cm)"},{"path":"https://zqzneptune.github.io/ComplexMap/reference/getNodeTable.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get the Node Table from a ComplexMap Object — getNodeTable","text":"cm `ComplexMap` object, typically output `createComplexMap()`.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/getNodeTable.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get the Node Table from a ComplexMap Object — getNodeTable","text":"`tibble` containing node data.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/getNodeTable.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get the Node Table from a ComplexMap Object — getNodeTable","text":"","code":"# Assuming 'myComplexMap' is a valid ComplexMap object # nodeData <- getNodeTable(myComplexMap)"},{"path":"https://zqzneptune.github.io/ComplexMap/reference/getReactomeGmt.html","id":null,"dir":"Reference","previous_headings":"","what":"Fetch Reactome Pathway Gene Sets — getReactomeGmt","title":"Fetch Reactome Pathway Gene Sets — getReactomeGmt","text":"Fetches Reactome pathways associated genes `reactome.db` Bioconductor annotation package.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/getReactomeGmt.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fetch Reactome Pathway Gene Sets — getReactomeGmt","text":"","code":"getReactomeGmt(speciesDb, verbose = TRUE)"},{"path":"https://zqzneptune.github.io/ComplexMap/reference/getReactomeGmt.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fetch Reactome Pathway Gene Sets — getReactomeGmt","text":"speciesDb AnnotationDb object target species (e.g., `org.Hs.eg.db`). used filter pathways correct species. verbose logical value indicating whether print progress messages.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/getReactomeGmt.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fetch Reactome Pathway Gene Sets — getReactomeGmt","text":"named list names Reactome pathway names values   character vectors Entrez IDs.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/pipe.html","id":null,"dir":"Reference","previous_headings":"","what":"Pipe operator — %>%","title":"Pipe operator — %>%","text":"See magrittr::%>% details.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/pipe.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pipe operator — %>%","text":"","code":"lhs %>% rhs"},{"path":"https://zqzneptune.github.io/ComplexMap/reference/print.ComplexMap.html","id":null,"dir":"Reference","previous_headings":"","what":"Print Method for a ComplexMap Object — print.ComplexMap","title":"Print Method for a ComplexMap Object — print.ComplexMap","text":"Provides user-friendly summary `ComplexMap` object printed console. method automatically called `print` generic function.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/print.ComplexMap.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print Method for a ComplexMap Object — print.ComplexMap","text":"","code":"# S3 method for class 'ComplexMap' print(x, ...)"},{"path":"https://zqzneptune.github.io/ComplexMap/reference/print.ComplexMap.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print Method for a ComplexMap Object — print.ComplexMap","text":"x `ComplexMap` object. ... Additional arguments passed `print` (used method).","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/print.ComplexMap.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print Method for a ComplexMap Object — print.ComplexMap","text":"Invisibly returns original `ComplexMap` object, allowing   use pipelines.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/qcComplexList.html","id":null,"dir":"Reference","previous_headings":"","what":"Perform Quality Control on a List of Protein Complexes — qcComplexList","title":"Perform Quality Control on a List of Protein Complexes — qcComplexList","text":"function performs quality control analysis list protein complexes. provides basic statistics, analyzes distribution complex sizes, calculates pairwise redundancy using Jaccard similarity index.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/qcComplexList.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Perform Quality Control on a List of Protein Complexes — qcComplexList","text":"","code":"qcComplexList(complexList, redundancyThreshold = 0.8, verbose = TRUE)"},{"path":"https://zqzneptune.github.io/ComplexMap/reference/qcComplexList.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Perform Quality Control on a List of Protein Complexes — qcComplexList","text":"complexList list element character vector protein identifiers representing complex. redundancyThreshold numeric value 0 1. warning issued pair complexes Jaccard similarity score greater equal threshold. Defaults 0.8. verbose logical value indicating whether print progress messages summaries console. Defaults `TRUE`.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/qcComplexList.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Perform Quality Control on a List of Protein Complexes — qcComplexList","text":"Invisibly returns original `complexList` object, allowing used pipeline.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/qcComplexList.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Perform Quality Control on a List of Protein Complexes — qcComplexList","text":"QC process involves three main steps: 1.  **Basic Statistics:** Reports total number complexes unique     proteins list. 2.  **Size Distribution:** Provides summary number proteins per     complex warns complexes fewer three members. 3.  **Redundancy Analysis:** sparse binary membership matrix constructed     efficiently calculate Jaccard similarity unique pairs     complexes. warning issued significant portion pairs     exceeds specified `redundancyThreshold`.","code":""},{"path":[]},{"path":"https://zqzneptune.github.io/ComplexMap/reference/qcComplexList.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Perform Quality Control on a List of Protein Complexes — qcComplexList","text":"Qingzhou Zhang <zqzneptune@hotmail.com>","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/qcComplexList.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Perform Quality Control on a List of Protein Complexes — qcComplexList","text":"","code":"# Create a sample list of protein complexes complex1 <- c(\"A\", \"B\", \"C\", \"D\") complex2 <- c(\"A\", \"B\", \"C\", \"E\") # Highly redundant with complex1 complex3 <- c(\"F\", \"G\", \"H\") complex4 <- c(\"I\", \"J\")          # Small complex complex5 <- c(\"X\", \"Y\", \"Z\") sampleList <- list(   C1 = complex1, C2 = complex2, C3 = complex3, C4 = complex4, C5 = complex5 )  # Run the quality control analysis qcComplexList(sampleList) #>  #> --- Running Quality Control on Complex List --- #>  #> [1] Basic Statistics: #>     - Total number of complexes: 5 #>     - Total number of unique proteins: 13 #>  #> [2] Complex Size Distribution: #>        Min. 1st Qu.  Median    Mean 3rd Qu.    Max.  #>         2.0     3.0     3.0     3.2     4.0     4.0  #> Warning: 1 complexes have fewer than 3 members. #>  #> [3] Redundancy Analysis: #>     - Distribution of Jaccard similarity scores: #>        Min. 1st Qu.  Median    Mean 3rd Qu.    Max.  #>        0.00    0.00    0.00    0.06    0.00    0.60  #>     - No highly redundant complex pairs detected. #>  #> --- QC Complete ---"},{"path":"https://zqzneptune.github.io/ComplexMap/reference/queryMap.html","id":null,"dir":"Reference","previous_headings":"","what":"Query a ComplexMap Object for Specific Information — queryMap","title":"Query a ComplexMap Object for Specific Information — queryMap","text":"Allows targeted querying `ComplexMap` object find nodes (complexes) match specific criteria, containing particular protein belonging biological theme.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/queryMap.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Query a ComplexMap Object for Specific Information — queryMap","text":"","code":"queryMap(complexMapObject, query, type)"},{"path":"https://zqzneptune.github.io/ComplexMap/reference/queryMap.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Query a ComplexMap Object for Specific Information — queryMap","text":"complexMapObject `ComplexMap` object returned `createComplexMap()`. query character string containing search term (protein ID, complex ID, theme label). type character string specifying type query. Must one `\"protein\"`, `\"complex\"`, `\"theme\"`.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/queryMap.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Query a ComplexMap Object for Specific Information — queryMap","text":"`tibble` containing rows node table match   query. Returns empty tibble matches found.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/queryMap.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Query a ComplexMap Object for Specific Information — queryMap","text":"function supports three distinct modes querying: - `type = \"protein\"`: `query` character string representing   protein ID. function searches `proteins` column node table   returns complexes contain protein. search exact   case-sensitive. - `type = \"complex\"`: `query` character string complex ID   (e.g., \"CpxMap_0001\"). returns specific row node table   corresponding complex. - `type = \"theme\"`: `query` character string corresponding   `themeLabel` `summarizeThemes()`. use , themes must first   calculated IDs added node table. `themeId`   column found, function stop informative error.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/queryMap.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Query a ComplexMap Object for Specific Information — queryMap","text":"Qingzhou Zhang <zqzneptune@hotmail.com>","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/queryMap.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Query a ComplexMap Object for Specific Information — queryMap","text":"","code":"# Assume 'cm_obj' is a valid ComplexMap object  # Query for a specific protein (e.g., \"UBA1\") # uba1_complexes <- queryMap(cm_obj, query = \"UBA1\", type = \"protein\")  # Query for a specific complex ID # cpx1_data <- queryMap(cm_obj, query = \"CpxMap_0001\", type = \"complex\")  # To query by theme, you must first run summarizeThemes and add the IDs # theme_summary <- summarizeThemes(cm_obj) # nodes <- getNodeTable(cm_obj) # graph <- igraph::graph_from_data_frame(getEdgeTable(cm_obj)) # communities <- igraph::cluster_louvain(graph)$membership # nodes$themeId <- communities # cm_obj$nodes <- nodes # Update the object # # Then you could query by a theme label from the summary # proteasome_nodes <- queryMap(cm_obj, query = \"Proteasome\", type = \"theme\")"},{"path":"https://zqzneptune.github.io/ComplexMap/reference/referenceComplexes.html","id":null,"dir":"Reference","previous_headings":"","what":"Reference Protein Complex Set (CORUM) — referenceComplexes","title":"Reference Protein Complex Set (CORUM) — referenceComplexes","text":"reference dataset containing 324 merged CORUM protein complexes used training protein-protein interaction scoring clustering optimization procedures study.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/referenceComplexes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Reference Protein Complex Set (CORUM) — referenceComplexes","text":"","code":"referenceComplexes"},{"path":"https://zqzneptune.github.io/ComplexMap/reference/referenceComplexes.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Reference Protein Complex Set (CORUM) — referenceComplexes","text":"named list 324 elements. element character vector protein identifiers.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/referenceComplexes.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Reference Protein Complex Set (CORUM) — referenceComplexes","text":"Supplementary Table 3 (second tab) : Havugimana PC, Hart GT, Nepusz T, Yang H, Turinsky AL, Li Z, Wang PI, Boutz DR, Fong V, Phanse S, Babu M, Craig SA, Hu P, Wan C, Vlasblom J, Dar VU, Bezginov , Clark GW, Wu GC, Wodak SJ, Tillier ER, Paccanaro , Marcotte EM, Emili . *census human soluble protein complexes.* Cell. 2012 Aug 31;150(5):1068-81. doi: 10.1016/j.cell.2012.08.011. PMID: 22939629; PMCID: PMC3477804.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/referenceComplexes.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Reference Protein Complex Set (CORUM) — referenceComplexes","text":"complexes curated CORUM database merged reduce redundancy benchmarking purposes.","code":""},{"path":[]},{"path":"https://zqzneptune.github.io/ComplexMap/reference/refineComplexList.html","id":null,"dir":"Reference","previous_headings":"","what":"Refine a List of Protein Complexes by Size and Redundancy — refineComplexList","title":"Refine a List of Protein Complexes by Size and Redundancy — refineComplexList","text":"function refines list protein complexes first filtering based size merging highly redundant complexes based Jaccard similarity threshold.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/refineComplexList.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Refine a List of Protein Complexes by Size and Redundancy — refineComplexList","text":"","code":"refineComplexList(   complexList,   minSize = 3,   maxSize = 500,   mergeThreshold = 0.9,   verbose = TRUE )"},{"path":"https://zqzneptune.github.io/ComplexMap/reference/refineComplexList.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Refine a List of Protein Complexes by Size and Redundancy — refineComplexList","text":"complexList named list element character vector protein identifiers representing complex. minSize integer specifying minimum number proteins complex must retained. Defaults 3. maxSize integer specifying maximum number proteins complex can retained. Defaults 500. mergeThreshold numeric value (0-1) Jaccard similarity. Complexes score >= value merged. Defaults 0.9. verbose logical value indicating whether print progress messages. Defaults `TRUE`.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/refineComplexList.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Refine a List of Protein Complexes by Size and Redundancy — refineComplexList","text":"refined renamed named list protein complexes.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/refineComplexList.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Refine a List of Protein Complexes by Size and Redundancy — refineComplexList","text":"refinement process consists two main stages: 1.  **Size Filtering:** Complexes smaller `minSize` larger     `maxSize` removed list. 2.  **Redundancy Merging:** Jaccard similarity matrix calculated     remaining pairs complexes. union-find algorithm used     identify clusters (\"merge groups\") complexes members     connected similarity score greater equal     `mergeThreshold`. groups merged single complexes. Finally, complexes refined list renamed standardized format (\"CpxMap_0001\", \"CpxMap_0002\", etc.).","code":""},{"path":[]},{"path":"https://zqzneptune.github.io/ComplexMap/reference/refineComplexList.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Refine a List of Protein Complexes by Size and Redundancy — refineComplexList","text":"Qingzhou Zhang <zqzneptune@hotmail.com>","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/refineComplexList.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Refine a List of Protein Complexes by Size and Redundancy — refineComplexList","text":"","code":"# Create a sample list of protein complexes complex1 <- c(\"A\", \"B\", \"C\", \"D\") complex2 <- c(\"A\", \"B\", \"C\", \"E\") # Highly redundant with complex1 complex3 <- c(\"F\", \"G\", \"H\") complex4 <- c(\"I\", \"J\")          # Too small, will be filtered sampleList <- list(   C1 = complex1, C2 = complex2, C3 = complex3, C4 = complex4 )  # Refine the list using a high similarity threshold refinedList <- refineComplexList(sampleList, mergeThreshold = 0.75) #>  #> --- Refining Input Complex List --- #> Filtered 1 complexes by size. Retaining 3. #> Identifying merge groups with Jaccard >= 0.75... #> Found 0 merge groups. Merging 0 complexes into 3. #> Merging complete. Final list has 3 complexes. #>  #> --- Refinement Complete ---"},{"path":"https://zqzneptune.github.io/ComplexMap/reference/runComplexEnrichment.html","id":null,"dir":"Reference","previous_headings":"","what":"Run Gene Set Enrichment Analysis on a List of Complexes — runComplexEnrichment","title":"Run Gene Set Enrichment Analysis on a List of Complexes — runComplexEnrichment","text":"function performs hypergeometric-based enrichment analysis protein complex list provided gene set matrix (GMT).","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/runComplexEnrichment.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Run Gene Set Enrichment Analysis on a List of Complexes — runComplexEnrichment","text":"","code":"runComplexEnrichment(   complexList,   gmt,   pAdjustMethod = \"Benjamini\",   pValueCutoff = 0.05,   verbose = TRUE )"},{"path":"https://zqzneptune.github.io/ComplexMap/reference/runComplexEnrichment.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Run Gene Set Enrichment Analysis on a List of Complexes — runComplexEnrichment","text":"complexList named list element character vector gene/protein identifiers representing complex. gmt named list element character vector genes, representing functional gene set (e.g., GMT file). pAdjustMethod character string specifying p-value adjustment method use filtering. Must one \"Benjamini\", \"Bonferroni\", \"FDR\". Defaults \"Benjamini\". pValueCutoff numeric value used cutoff significance adjusted p-value. Defaults 0.05. verbose logical value indicating whether print progress messages. Defaults `TRUE`.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/runComplexEnrichment.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Run Gene Set Enrichment Analysis on a List of Complexes — runComplexEnrichment","text":"named list name corresponds `complexId` input. element data frame containing significant enrichment results complex, columns: `ID`, `Description`, `p.adjust`, `Count`, `Ratio`, `Fold`.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/runComplexEnrichment.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Run Gene Set Enrichment Analysis on a List of Complexes — runComplexEnrichment","text":"complex, function calculates -representation functional terms (e.g., GO terms, pathways) GMT file. uses hypergeometric test compute p-value, adjusted multiple testing. terms significant filtering `pValueCutoff` retained final output.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/runComplexEnrichment.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Run Gene Set Enrichment Analysis on a List of Complexes — runComplexEnrichment","text":"Qingzhou Zhang <zqzneptune@hotmail.com>","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/runComplexEnrichment.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Run Gene Set Enrichment Analysis on a List of Complexes — runComplexEnrichment","text":"","code":"# --- Sample Data --- # 1. Complexes to be tested complex1 <- c(\"A\", \"B\", \"C\", \"D\") complex2 <- c(\"F\", \"G\", \"H\") myComplexes <- list(Cpx1 = complex1, Cpx2 = complex2)  # 2. Gene Set Matrix (e.g., GO terms or pathways) term1 <- c(\"A\", \"B\", \"C\", \"X\", \"Y\") # Enriched in Cpx1 term2 <- c(\"F\", \"G\", \"Z\")          # Enriched in Cpx2 term3 <- c(\"L\", \"M\", \"N\")          # Not enriched myGmt <- list(Term1 = term1, Term2 = term2, Term3 = term3)  # --- Run Enrichment --- enrichment <- runComplexEnrichment(myComplexes, myGmt) #> Running enrichment for 2 complexes... #> Annotation complete. Found terms for 0 complexes. print(enrichment) #> list()"},{"path":"https://zqzneptune.github.io/ComplexMap/reference/summarizeThemes.html","id":null,"dir":"Reference","previous_headings":"","what":"Summarize Major Biological Themes in a Complex Map — summarizeThemes","title":"Summarize Major Biological Themes in a Complex Map — summarizeThemes","text":"function analyzes network structure within `ComplexMap` object identify summarize major biological themes. uses community detection algorithms find densely connected clusters nodes (themes).","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/summarizeThemes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summarize Major Biological Themes in a Complex Map — summarizeThemes","text":"","code":"summarizeThemes(complexMapObject, method = \"louvain\", verbose = TRUE)"},{"path":"https://zqzneptune.github.io/ComplexMap/reference/summarizeThemes.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summarize Major Biological Themes in a Complex Map — summarizeThemes","text":"complexMapObject `ComplexMap` object returned `createComplexMap()`. method character string specifying community detection algorithm use. Must valid `igraph` clustering function (e.g., \"louvain\", \"walktrap\", \"infomap\"). Defaults \"louvain\". verbose logical value indicating whether print progress messages.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/summarizeThemes.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summarize Major Biological Themes in a Complex Map — summarizeThemes","text":"`tibble` row represents summarized theme. tibble   contains following columns:   - `themeId`: unique integer identifier theme.   - `themeLabel`: descriptive label theme.   - `nodeCount`: number nodes (complexes) theme.   - `edgeCount`: number internal edges within theme.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/summarizeThemes.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Summarize Major Biological Themes in a Complex Map — summarizeThemes","text":"function performs following steps: 1.  constructs `igraph` graph object node edge tables     `complexMapObject`. 2.  applies community detection algorithm (e.g., Louvain, default)     partition network clusters \"themes\". 3.  identified theme, generates descriptive `themeLabel`     finding frequently occurring `primaryFunctionalDomain` among     member nodes (excluding \"Unenriched\"). 4.  calculates summary statistics theme, including number     nodes edges contains.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/summarizeThemes.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Summarize Major Biological Themes in a Complex Map — summarizeThemes","text":"Qingzhou Zhang <zqzneptune@hotmail.com>","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/summarizeThemes.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Summarize Major Biological Themes in a Complex Map — summarizeThemes","text":"","code":"# Assume 'cm_obj' is a valid ComplexMap object created by createComplexMap() # if (requireNamespace(\"igraph\", quietly = TRUE)) { #   themeSummary <- summarizeThemes(cm_obj) #   print(themeSummary) # }"},{"path":"https://zqzneptune.github.io/ComplexMap/reference/visualizeMapDirectLabels.html","id":null,"dir":"Reference","previous_headings":"","what":"Visualize a Complex Map with Direct Node Labels — visualizeMapDirectLabels","title":"Visualize a Complex Map with Direct Node Labels — visualizeMapDirectLabels","text":"Creates static visualization complex network using `ggraph`, functional domain labels placed directly plot near nodes.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/visualizeMapDirectLabels.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Visualize a Complex Map with Direct Node Labels — visualizeMapDirectLabels","text":"","code":"visualizeMapDirectLabels(   layoutDf,   edgesDf,   title = \"ComplexMap Functional Landscape\",   subtitle = \"Nodes are protein complexes, colored by function\",   bgColor = \"black\",   edgeColor = \"white\",   nodeSizeRange = c(2, 10),   labelFillColor = ggplot2::alpha(\"white\", 0.7),   fontFamily = \"sans\",   verbose = TRUE )"},{"path":"https://zqzneptune.github.io/ComplexMap/reference/visualizeMapDirectLabels.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Visualize a Complex Map with Direct Node Labels — visualizeMapDirectLabels","text":"layoutDf data frame containing node attributes layout coordinates, typically `computeMapTopology`. edgesDf data frame containing network edges. title main title plot. subtitle subtitle plot. bgColor background color plot. edgeColor color network edges. nodeSizeRange numeric vector length 2 specifying min max node size. labelFillColor background fill color labels. fontFamily base font family plot text. verbose logical value indicating whether print progress messages.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/visualizeMapDirectLabels.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Visualize a Complex Map with Direct Node Labels — visualizeMapDirectLabels","text":"`ggplot` object representing network visualization.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/visualizeMapDirectLabels.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Visualize a Complex Map with Direct Node Labels — visualizeMapDirectLabels","text":"function designed clarity domains distinct. large, dense domains (2 complexes), single label placed domain's centroid. smaller domains, complex labeled individually. uses pre-computed layout `computeMapTopology`.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/visualizeMapDirectLabels.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Visualize a Complex Map with Direct Node Labels — visualizeMapDirectLabels","text":"Qingzhou Zhang <zqzneptune@hotmail.com>","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/visualizeMapDirectLabels.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Visualize a Complex Map with Direct Node Labels — visualizeMapDirectLabels","text":"","code":"# --- Sample Data --- nodes <- tibble::tibble(   complexId = c(\"C1\", \"C2\", \"C3\"), x = c(1, 2, 1.5), y = c(1, 1, 2),   primaryFunctionalDomain = c(\"DNA Repair\", \"DNA Repair\", \"Metabolism\"),   sizeMapping = c(3, 4, 3.5), colorHex = c(\"#FF0000\", \"#FF0000\", \"#0000FF\") ) edges <- tibble::tibble(   source_complex_id = \"C1\", target_complex_id = \"C2\", weight = 0.8 )  # --- Generate Plot --- if (requireNamespace(\"ggrepel\", quietly = TRUE)) {   visualizeMapDirectLabels(nodes, edges) } #> Visualizing ComplexMap with direct labels..."},{"path":"https://zqzneptune.github.io/ComplexMap/reference/visualizeMapInteractive.html","id":null,"dir":"Reference","previous_headings":"","what":"Visualize a Complex Map Interactively — visualizeMapInteractive","title":"Visualize a Complex Map Interactively — visualizeMapInteractive","text":"Creates dynamic, zoomable, explorable HTML widget complex network using `visNetwork` package.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/visualizeMapInteractive.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Visualize a Complex Map Interactively — visualizeMapInteractive","text":"","code":"visualizeMapInteractive(   layoutDf,   edgesDf,   width = \"100%\",   height = \"90vh\",   title = \"ComplexMap Functional Landscape\",   physicsEnabled = FALSE,   verbose = TRUE )"},{"path":"https://zqzneptune.github.io/ComplexMap/reference/visualizeMapInteractive.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Visualize a Complex Map Interactively — visualizeMapInteractive","text":"layoutDf data frame node attributes `computeMapTopology`. edgesDf data frame network edges. width width HTML widget. height height HTML widget. title main title network visualization. physicsEnabled logical value. `TRUE`, nodes physically react dragging. Defaults `FALSE` stable layout. verbose logical value indicating whether print progress messages.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/visualizeMapInteractive.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Visualize a Complex Map Interactively — visualizeMapInteractive","text":"`visNetwork` HTML widget object.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/visualizeMapInteractive.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Visualize a Complex Map Interactively — visualizeMapInteractive","text":"function ideal data exploration. Nodes can clicked dragged, hovering node reveals detailed tooltip attributes. coordinates static layout rescaled used provide initial, non-random arrangement.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/visualizeMapInteractive.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Visualize a Complex Map Interactively — visualizeMapInteractive","text":"Qingzhou Zhang <zqzneptune@hotmail.com>","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/visualizeMapInteractive.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Visualize a Complex Map Interactively — visualizeMapInteractive","text":"","code":"# --- Sample Data --- nodes <- tibble::tibble(   complexId = c(\"C1\", \"C2\", \"C3\"), x = c(1, 2, 1.5), y = c(1, 1, 2),   primaryFunctionalDomain = c(\"DNA Repair\", \"DNA Repair\", \"Metabolism\"),   sizeMapping = c(3, 4, 3.5), colorHex = c(\"#FF0000\", \"#FF0000\", \"#0000FF\"),   proteinCount = c(10, 8, 12), proteins = c(\"A,B\", \"B,C\", \"D,E\") ) edges <- tibble::tibble(   source_complex_id = \"C1\", target_complex_id = \"C2\", weight = 0.8 )  # --- Generate Plot --- if (requireNamespace(\"visNetwork\", quietly = TRUE)) {   visualizeMapInteractive(nodes, edges) } #> Generating interactive visNetwork plot...  {\"x\":{\"nodes\":{\"complexId\":[\"C1\",\"C2\",\"C3\"],\"x\":[-800,800,0],\"y\":[800,800,-800],\"primaryFunctionalDomain\":[\"DNA Repair\",\"DNA Repair\",\"Metabolism\"],\"sizeMapping\":[3,4,3.5],\"colorHex\":[\"#FF0000\",\"#FF0000\",\"#0000FF\"],\"proteinCount\":[10,8,12],\"proteins\":[\"A,B\",\"B,C\",\"D,E\"],\"id\":[\"C1\",\"C2\",\"C3\"],\"label\":[\"C1\",\"C2\",\"C3\"],\"value\":[3,4,3.5],\"color\":[\"#FF0000\",\"#FF0000\",\"#0000FF\"],\"title\":[\"<div style='font-family:sans-serif; text-align:left;'><b>Complex:<\\/b> C1<br><b>Function:<\\/b> DNA Repair<br><b>Protein Count:<\\/b> 10<hr><b>Members:<\\/b><br>A, B<\\/div>\",\"<div style='font-family:sans-serif; text-align:left;'><b>Complex:<\\/b> C2<br><b>Function:<\\/b> DNA Repair<br><b>Protein Count:<\\/b> 8<hr><b>Members:<\\/b><br>B, C<\\/div>\",\"<div style='font-family:sans-serif; text-align:left;'><b>Complex:<\\/b> C3<br><b>Function:<\\/b> Metabolism<br><b>Protein Count:<\\/b> 12<hr><b>Members:<\\/b><br>D, E<\\/div>\"]},\"edges\":{\"source_complex_id\":[\"C1\"],\"target_complex_id\":[\"C2\"],\"weight\":[0.8],\"from\":[\"C1\"],\"to\":[\"C2\"],\"value\":[0.8]},\"nodesToDataframe\":true,\"edgesToDataframe\":true,\"options\":{\"width\":\"100%\",\"height\":\"100%\",\"nodes\":{\"shape\":\"dot\",\"borderWidth\":2,\"shadow\":true},\"manipulation\":{\"enabled\":false},\"edges\":{\"color\":{\"color\":\"#888888\",\"highlight\":\"#00BFFF\"},\"smooth\":false},\"physics\":{\"enabled\":false},\"interaction\":{\"hover\":true,\"dragNodes\":true,\"dragView\":true,\"navigationButtons\":true,\"tooltipDelay\":200,\"zoomView\":true,\"zoomSpeed\":1},\"layout\":{\"randomSeed\":123}},\"groups\":null,\"width\":\"100%\",\"height\":\"90vh\",\"idselection\":{\"enabled\":true,\"style\":\"width: 150px; height: 26px\",\"useLabels\":true,\"main\":\"Select by id\"},\"byselection\":{\"enabled\":true,\"style\":\"width: 150px; height: 26px\",\"multiple\":false,\"hideColor\":\"rgba(200,200,200,0.5)\",\"highlight\":false,\"variable\":\"primaryFunctionalDomain\",\"main\":\"Select by primaryFunctionalDomain\",\"values\":[\"DNA Repair\",\"Metabolism\"]},\"main\":{\"text\":\"ComplexMap Functional Landscape\",\"style\":\"font-family:Georgia, Times New Roman, Times, serif;font-weight:bold;font-size:20px;text-align:center;\"},\"submain\":null,\"footer\":null,\"background\":\"rgba(0, 0, 0, 0)\",\"highlight\":{\"enabled\":true,\"hoverNearest\":true,\"degree\":1,\"algorithm\":\"all\",\"hideColor\":\"rgba(200,200,200,0.5)\",\"labelOnly\":true},\"collapse\":{\"enabled\":false,\"fit\":false,\"resetHighlight\":true,\"clusterOptions\":null,\"keepCoord\":true,\"labelSuffix\":\"(cluster)\"},\"tooltipStay\":300,\"tooltipStyle\":\"position: fixed;visibility:hidden;padding: 5px;white-space: nowrap;font-family: verdana;font-size:14px;font-color:#000000;background-color: #f5f4ed;-moz-border-radius: 3px;-webkit-border-radius: 3px;border-radius: 3px;border: 1px solid #808074;box-shadow: 3px 3px 10px rgba(0, 0, 0, 0.2);\"},\"evals\":[],\"jsHooks\":[]}"},{"path":"https://zqzneptune.github.io/ComplexMap/reference/visualizeMapWithLegend.html","id":null,"dir":"Reference","previous_headings":"","what":"Visualize a Complex Map with a Color Legend — visualizeMapWithLegend","title":"Visualize a Complex Map with a Color Legend — visualizeMapWithLegend","text":"Creates static visualization complex network using `ggraph`, functional domains represented discrete color scale legend.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/visualizeMapWithLegend.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Visualize a Complex Map with a Color Legend — visualizeMapWithLegend","text":"","code":"visualizeMapWithLegend(   layoutDf,   edgesDf,   title = \"ComplexMap Functional Landscape\",   subtitle = \"Nodes are protein complexes, colored by function\",   bgColor = \"black\",   edgeColor = \"white\",   nodeSizeRange = c(2, 10),   unenrichedColor = \"#CCCCCC\",   fontFamily = \"sans\",   verbose = TRUE )"},{"path":"https://zqzneptune.github.io/ComplexMap/reference/visualizeMapWithLegend.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Visualize a Complex Map with a Color Legend — visualizeMapWithLegend","text":"layoutDf data frame containing node attributes layout coordinates, typically `computeMapTopology`. edgesDf data frame containing network edges. title main title plot. subtitle subtitle plot. bgColor background color plot. edgeColor color network edges. nodeSizeRange numeric vector length 2 specifying min max node size. unenrichedColor color nodes \"Unenriched\" category. fontFamily base font family plot text. verbose logical value indicating whether print progress messages.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/visualizeMapWithLegend.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Visualize a Complex Map with a Color Legend — visualizeMapWithLegend","text":"`ggplot` object representing network visualization.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/visualizeMapWithLegend.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Visualize a Complex Map with a Color Legend — visualizeMapWithLegend","text":"plot useful overviews direct labels cluttered. maps `primaryFunctionalDomain` node color displays legend. uses pre-computed layout `computeMapTopology`.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/visualizeMapWithLegend.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Visualize a Complex Map with a Color Legend — visualizeMapWithLegend","text":"Qingzhou Zhang <zqzneptune@hotmail.com>","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/visualizeMapWithLegend.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Visualize a Complex Map with a Color Legend — visualizeMapWithLegend","text":"","code":"# --- Sample Data --- nodes <- tibble::tibble(   complexId = c(\"C1\", \"C2\", \"C3\"), x = c(1, 2, 1.5), y = c(1, 1, 2),   primaryFunctionalDomain = c(\"DNA Repair\", \"DNA Repair\", \"Unenriched\"),   sizeMapping = c(3, 4, 3.5), colorHex = c(\"#FF0000\", \"#FF0000\", \"#CCCCCC\") ) edges <- tibble::tibble(   source_complex_id = \"C1\", target_complex_id = \"C2\", weight = 0.8 )  # --- Generate Plot --- visualizeMapWithLegend(nodes, edges) #> Visualizing ComplexMap with a color legend..."},{"path":"https://zqzneptune.github.io/ComplexMap/news/index.html","id":"complexmap-100","dir":"Changelog","previous_headings":"","what":"ComplexMap 1.0.0","title":"ComplexMap 1.0.0","text":"Initial stable release. Complete refactoring codebase adhere Bioconductor standards. Introduction ComplexMap S3 object structured workflow. Added high-level wrapper createComplexMap() end--end analysis. Added new functions analysis exploration: summarizeThemes(), queryMap(), exportNetwork(). Added three comprehensive vignettes. Numerous bug fixes improvements robustness.","code":""}]
