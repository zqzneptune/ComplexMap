% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/evaluateComplexes.R
\name{evaluateComplexes}
\alias{evaluateComplexes}
\title{Evaluate Predicted Protein Complexes Against a Reference Set}
\usage{
evaluateComplexes(
  predictedComplexes,
  referenceComplexes,
  nCores = NULL,
  verbose = TRUE
)
}
\arguments{
\item{predictedComplexes}{A list of predicted protein complexes.}

\item{referenceComplexes}{A list of reference (gold standard) complexes.}

\item{nCores}{The number of CPU cores to use for parallel computation.
Defaults to one less than the total number of detected cores.}

\item{verbose}{A logical value indicating whether to print progress messages.
Defaults to `TRUE`.}
}
\value{
A named list containing four numeric values: `PPV`, `Sn`, `Acc`, and `MMR`.
Returns `NA` for all metrics if either input list is empty.
}
\description{
Calculates four standard metrics for evaluating protein complex predictions:
Positive Predictive Value (PPV), Sensitivity (Sn), Accuracy (Acc), and the
Maximum Matching Ratio (MMR).
}
\details{
This function is optimized for speed by calculating a shared intersection
matrix between predicted and reference complexes in parallel. This matrix is
then used as the basis for all four metric calculations.

- **PPV, Sn, and Acc** are calculated based on the confusion matrix between
  predicted and reference complexes, as described in the literature.
- **MMR** is calculated by first deriving an overlap score matrix, where each
  entry `(i, j)` is `|intersection_ij|^2 / (|pred_i| * |ref_j|)`. The
  [Hungarian algorithm](https://en.wikipedia.org/wiki/Hungarian_algorithm)
  is then used to solve the maximum weight bipartite matching problem,
  finding the optimal one-to-one mapping between predicted and reference sets.

The parallel computation uses `parallel::mclapply`, which is not available on
Windows. On Windows, the calculation will run sequentially. For cross-platform
parallel execution in a package, consider using the `BiocParallel` package.
}
\examples{
# --- Sample Data ---
# Predicted complexes
pred1 <- c("A", "B", "C")
pred2 <- c("D", "E", "F")
pred3 <- c("A", "G", "H")
predicted <- list(P1 = pred1, P2 = pred2, P3 = pred3)

# Reference complexes (gold standard)
ref1 <- c("A", "B", "C", "X") # Good match for pred1
ref2 <- c("D", "E", "F")     # Perfect match for pred2
ref3 <- c("I", "J", "K")     # Unmatched complex
reference <- list(R1 = ref1, R2 = ref2, R3 = ref3)

# --- Evaluation ---
# Use 2 cores for the example
metrics <- evaluateComplexes(predicted, reference, nCores = 2)
print(metrics)

}
\author{
Qingzhou Zhang <zqzneptune@hotmail.com>
}
