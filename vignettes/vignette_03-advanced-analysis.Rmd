---
title: "3. Advanced Analysis and Visualization"
author: "Qingzhou Zhang"
date: "`r Sys.Date()`"
output: html_document
vignette: >
  %\VignetteIndexEntry{Advanced Analysis and Visualization}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 8,
  fig.height = 6,
  message = FALSE,
  warning = FALSE
)
```

## Advanced Analysis Workflow

Once you have a `ComplexMap` object, the package provides several functions for deeper analysis and interpretation of the network structure. This vignette covers:

1.  **Optimizing Parameters**: Using `evaluateComplexes()` to tune the `refineComplexList` step.

2.  **Summarizing Themes**: Using `summarizeThemes()` to identify major biological clusters.

3.  **Querying the Map**: Using `queryMap()` to find specific proteins, complexes, or themes.

```{r setup}
library(ComplexMap)
library(dplyr)
library(ggplot2)
library(igraph)
```

### 1. Optimizing Refinement with `evaluateComplexes`

The `mergeThreshold` in `refineComplexList` is a critical parameter that determines how aggressively smaller complexes are merged. A low threshold creates fewer, larger complexes, while a high threshold preserves more distinct complexes. The optimal value often depends on the dataset.

The `evaluateComplexes()` function can be used to score a refined complex list against a gold standard (like the `referenceComplexes` dataset) to help guide this choice. It returns four key metrics: Positive Predictive Value (PPV), Sensitivity (Sn), Accuracy (Acc), and Maximum Matching Ratio (MMR).

Let's test a `mergeThreshold` of 0.85.

```{r evaluate}
# Load the package's demo and reference data
data(demoComplexes)
data(referenceComplexes)

# refineComplexList now returns a list with two elements
refinement_output <- refineComplexList(
  demoComplexes,
  mergeThreshold = 0.85,
  verbose = FALSE
)

# We must now explicitly use the `$refinedComplexes` element for evaluation
metrics <- evaluateComplexes(
  predictedComplexes = refinement_output$refinedComplexes,
  referenceComplexes = referenceComplexes,
  nCores = 2, # <-- THIS IS THE FIX: Limit cores for check environment
  verbose = FALSE
)

# Display the resulting metrics
knitr::kable(as.data.frame(metrics))
```

For more systematic tuning, see the documentation for the new `benchmarkParameters()` function, which automates this process over a range of thresholds.

### 2. Summarizing Biological Themes

A key goal of `ComplexMap` is to organize complexes into a functional landscape. The `summarizeThemes()` function uses network community detection algorithms (like Louvain, the default) to find densely connected clusters of complexes within the map. It then automatically labels each cluster based on the most common functional annotation among its members.

Let's generate a map with a slightly lower merge threshold to create a more interconnected network for this example.

```{r create_adv_map}
# We'll use the example GMT file that comes with the package
gmtPath <- getExampleGmt()
gmt <- getGmtFromFile(gmtPath, verbose = FALSE)

# Create the map object
cm_obj_adv <- createComplexMap(
  complexList = demoComplexes,
  gmt = gmt,
  mergeThreshold = 0.75, # Lower threshold for more connections
  verbose = FALSE
)
```

Now, we can run `summarizeThemes()` on this object.

```{r summarize_themes}
# The function returns a tibble summarizing each detected theme
theme_summary <- summarizeThemes(cm_obj_adv, verbose = FALSE)

# Display the largest themes
theme_summary %>%
  arrange(desc(nodeCount)) %>%
  head(10) %>%
  knitr::kable()
```
This summary shows us the major biological stories in our dataset, such as the large "Ribosome" and "Proteasome" communities.

### 3. Querying the Map for Specific Information

The `queryMap()` function provides an easy way to retrieve specific nodes from the `ComplexMap` object based on different criteria.

#### Query by Protein

Find all complexes that contain a specific protein.

```{r query_protein}
# Find all complexes containing the protein "UBA1"
queryMap(cm_obj_adv, query = "UBA1", type = "protein") %>%
  select(complexId, primaryFunctionalDomain, proteinCount, proteins) %>%
  knitr::kable()
```

#### Query by Complex ID

Retrieve the data for a single complex.

```{r query_complex}
# Get the data for complex "CpxMap_0001"
queryMap(cm_obj_adv, query = "CpxMap_0001", type = "complex") %>%
  knitr::kable()
```

#### Query by Theme

To query by theme, we first need to add the theme labels from `summarizeThemes()` back into our main `ComplexMap` object's node table.

```{r add-themes}
# To add the theme labels to our main node table for querying or visualization,
# we first need to get the theme ID for each node.

# Re-run the community detection to get the membership vector
graph <- igraph::graph_from_data_frame(
  d = getEdgeTable(cm_obj_adv), 
  vertices = getNodeTable(cm_obj_adv), 
  directed = FALSE
)
communities <- igraph::cluster_louvain(graph)

# Create a tibble mapping complexId to themeId
# Coerce the 'membership' object to a simple integer for joining
node_themes <- tibble(
  complexId = names(igraph::membership(communities)),
  themeId = as.integer(igraph::membership(communities))
)
theme_summary$themeId <-
  as.integer(theme_summary$themeId)

# Join this mapping with the theme summary table to get the labels
node_theme_labels <- node_themes %>%
  left_join(theme_summary, by = "themeId")

# Finally, join the theme labels back to the main node table of our object
nodes_with_themes <- getNodeTable(cm_obj_adv) %>%
  left_join(node_theme_labels, by = "complexId")

# Update the ComplexMap object with this new node table
cm_obj_adv$nodes <- nodes_with_themes

# Preview the new columns
head(select(cm_obj_adv$nodes, complexId, themeId, themeLabel)) %>%
  knitr::kable()
```

Now that the `themeLabel` column exists in our node table, we can query it.

```{r query-theme}
# Find all complexes belonging to the "Proteasome" theme
proteasome_nodes <- queryMap(cm_obj_adv, query = "BIOCARTA_PROTEASOME_PATHWAY", type = "theme")

cat("Found", nrow(proteasome_nodes), "nodes in the Proteasome theme.")

proteasome_nodes %>%
  select(complexId, primaryFunctionalDomain, proteinCount, betweenness) %>%
  head(10) %>%
  knitr::kable()
```