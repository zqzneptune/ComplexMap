[{"path":"https://zqzneptune.github.io/ComplexMap/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2025 Qingzhou Zhang Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_00-perp-input.html","id":"the-complexmap-philosophy-identifier-matching","dir":"Articles","previous_headings":"","what":"The ComplexMap Philosophy: Identifier Matching","title":"Preparing Input","text":"ComplexMap package designed powerful, flexible, species-agnostic. contain hard-coded assumptions Homo sapiens model organism. entire workflow depends one simple principle: identifiers used input lists must match. means package’s functions can support organism identifier type (e.g., Gene Symbols, Entrez IDs, Ensembl IDs, UniProt IDs), long consistent. three key inputs identifiers must consistent: Complex List: list protein/gene members complex want analyze. Functional Gene Sets (GMT): database used enrichment analysis. Reference Complex List: “gold standard” list used benchmarking ComplexMap::evaluateComplexes(). (required benchmarking, functional analysis.) example, complex list uses Gene Symbols, GMT file must also use Gene Symbols. complex list uses Entrez IDs, GMT must use Entrez IDs. vignette demonstrates prepare functional gene sets (GMT) various sources , crucially, handle convert identifiers ensure match input data.","code":"# For this tutorial, we will assume our input complex list uses Gene Symbols. myComplexes <- list(   CPLX1 = c(\"POLR2A\", \"POLR2B\", \"POLR2C\"),   CPLX2 = c(\"CDK1\", \"CCNB1\", \"CCNB2\") )"},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_00-perp-input.html","id":"preparing-functional-gene-sets-gmt","dir":"Articles","previous_headings":"","what":"Preparing Functional Gene Sets (GMT)","title":"Preparing Input","text":"ComplexMap provides several helper functions obtain GMT files. align package’s philosophy clarity avoiding namespace conflicts, call functions explicitly using package::function() syntax (e.g., ComplexMap::getGmtFromFile()) instead using library(). Let’s explore method, paying close attention identifier type returns.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_00-perp-input.html","id":"method-1-from-a-user-provided-local-file","dir":"Articles","previous_headings":"Preparing Functional Gene Sets (GMT)","what":"Method 1: From a User-Provided Local File","title":"Preparing Input","text":"direct method. GMT file, can load ComplexMap::getGmtFromFile(). First, get path example GMT file included package. file uses Gene Symbols. Load GMT file path. Let’s inspect identifiers: Identifier Match: example GMT file uses Gene Symbols. Since hypothetical myComplexes list also uses Gene Symbols, directly compatible ready analysis.","code":"gmtPath <- ComplexMap::getExampleGmt() gmtFromFile <- ComplexMap::getGmtFromFile(gmtPath, verbose = FALSE) # First 5 genes in the first gene set: utils::head(gmtFromFile[[1]], 5) #> [1] \"ATF2\"  \"CHUK\"  \"IFNG\"  \"IKBKB\" \"IL2\""},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_00-perp-input.html","id":"method-2-from-the-molecular-signatures-database-msigdb","dir":"Articles","previous_headings":"Preparing Functional Gene Sets (GMT)","what":"Method 2: From the Molecular Signatures Database (MSigDB)","title":"Preparing Input","text":"msigdbr package provides powerful --date interface MSigDB collections. ComplexMap::getMsigdbGmt() function simplifies process. Identifier Match: default, msigdbr also returns Gene Symbols. directly compatible myComplexes list.","code":"# Fetch the Hallmark gene sets for Human # This requires the `msigdbr` package if (requireNamespace(\"msigdbr\", quietly = TRUE)) {   h_gmt <- ComplexMap::getMsigdbGmt(species = \"Homo sapiens\", collection = \"H\")    # Inspect the identifiers   utils::head(h_gmt[[1]], 5) } #> Fetching MSigDB sets (Species: Homo sapiens, Cat: H) #> [1] \"ABCA1\" \"ABCB8\" \"ACAA2\" \"ACADL\" \"ACADM\""},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_00-perp-input.html","id":"method-3-from-gene-ontology-go-via-bioconductor","dir":"Articles","previous_headings":"Preparing Functional Gene Sets (GMT)","what":"Method 3: From Gene Ontology (GO) via Bioconductor","title":"Preparing Input","text":"Using official Bioconductor annotation packages highly reproducible way get functional annotations. databases, however, typically use stable database identifiers, gene symbols. Identifier Mismatch! getGoGmt function returns list genes Entrez IDs (e.g., “5594”, “5595”). match Gene Symbols myComplexes list (e.g., “POLR2A”). Solution: Convert Complex List Identifiers recommended approach convert input complex identifiers match stable IDs annotation database. AnnotationDbi::mapIds function perfect . Now, myComplexesEntrez list directly compatible goGmt generated Bioconductor.","code":"# This requires an organism annotation package, e.g., org.Hs.eg.db for human if (requireNamespace(\"org.Hs.eg.db\", quietly = TRUE)) {   # Fetch Biological Process (BP) terms   # We pass the database object directly using the `::` operator   goGmt <- ComplexMap::getGoGmt(speciesDb = org.Hs.eg.db::org.Hs.eg.db,                                  ontology = \"BP\",                                 verbose = FALSE)    # Inspect the identifiers   utils::head(goGmt[[1]], 5) } #>  #> 'select()' returned 1:many mapping between keys and columns #>  #> 'select()' returned 1:1 mapping between keys and columns #> [1] \"1291\" \"1738\" \"1743\" \"2805\" \"2806\" if (requireNamespace(\"org.Hs.eg.db\", quietly = TRUE)) {   # Get all unique symbols from our complex list   allSymbols <- unique(unlist(myComplexes))    # Map symbols to Entrez IDs, taking the first ID if multiple exist   symbolToEntrez <- AnnotationDbi::mapIds(       org.Hs.eg.db::org.Hs.eg.db,       keys = allSymbols,       keytype = \"SYMBOL\",       column = \"ENTREZID\",       multiVals = \"first\"   )      # Remove any symbols that could not be mapped   symbolToEntrez <- symbolToEntrez[!is.na(symbolToEntrez)]    # Now, create a new complex list with Entrez IDs   myComplexesEntrez <- lapply(myComplexes, function(complex) {     # Look up the Entrez ID for each symbol     entrez_ids <- symbolToEntrez[complex]     # Return only the successfully mapped IDs, removing any NAs     unname(entrez_ids[!is.na(entrez_ids)])   })    # Inspect the result   print(myComplexesEntrez) } #> 'select()' returned 1:1 mapping between keys and columns #> $CPLX1 #> [1] \"5430\" \"5431\" \"5432\" #>  #> $CPLX2 #> [1] \"983\"  \"891\"  \"9133\""},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_00-perp-input.html","id":"method-4-from-reactome-pathways-via-bioconductor","dir":"Articles","previous_headings":"Preparing Functional Gene Sets (GMT)","what":"Method 4: From Reactome Pathways via Bioconductor","title":"Preparing Input","text":"Similarly, reactome.db package provides pathway annotations, also use Entrez IDs. Identifier Mismatch! Like GO example, reactome.db provides Entrez IDs. Solution: solution Gene Ontology. use myComplexesEntrez list created previous step, identifiers match identifiers reactomeGmt.","code":"if (requireNamespace(\"reactome.db\", quietly = TRUE) &&      requireNamespace(\"org.Hs.eg.db\", quietly = TRUE)) {          reactomeGmt <- ComplexMap::getReactomeGmt(       speciesDb = org.Hs.eg.db::org.Hs.eg.db,       verbose = FALSE   )    # Inspect the identifiers   utils::head(reactomeGmt[[1]], 5) } #> [1] \"1\"     \"10019\" \"10112\" \"10125\" \"10125\""},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_00-perp-input.html","id":"conclusion","dir":"Articles","previous_headings":"","what":"Conclusion","title":"Preparing Input","text":"vignette demonstrated core philosophy ComplexMap: flexibility identifier consistency. understanding identifier types returned different sources knowing convert data match, can apply ComplexMap workflow virtually organism. Always check identifiers running ComplexMap::createComplexMap() ensure smooth successful analysis. explicit package::function() syntax demonstrated recommended best practice writing clean, reproducible, error-free analysis scripts.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_01-prep-input.html","id":"the-complexmap-philosophy-identifier-matching","dir":"Articles","previous_headings":"","what":"The ComplexMap Philosophy: Identifier Matching","title":"1. Preparing Your Input Data","text":"ComplexMap package designed powerful, flexible, species-agnostic. contain hard-coded assumptions Homo sapiens model organism. entire workflow depends one simple principle: identifiers used input lists must match. means package’s functions can support organism identifier type (e.g., Gene Symbols, Entrez IDs, Ensembl IDs, UniProt IDs), long consistent. three key inputs identifiers must consistent: Complex List: list protein/gene members complex want analyze. Functional Gene Sets (GMT): database used enrichment analysis. Reference Complex List: “gold standard” list used benchmarking ComplexMap::evaluateComplexes(). (required benchmarking, functional analysis.) example, complex list uses Gene Symbols, GMT file must also use Gene Symbols. complex list uses Entrez IDs, GMT must use Entrez IDs. vignette demonstrates prepare functional gene sets (GMT) various sources , crucially, handle convert identifiers ensure match input data.","code":"# For this tutorial, we will assume our input complex list uses Gene Symbols. myComplexes <- list(   CPLX1 = c(\"POLR2A\", \"POLR2B\", \"POLR2C\"),   CPLX2 = c(\"CDK1\", \"CCNB1\", \"CCNB2\") )"},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_01-prep-input.html","id":"preparing-functional-gene-sets-gmt","dir":"Articles","previous_headings":"","what":"Preparing Functional Gene Sets (GMT)","title":"1. Preparing Your Input Data","text":"ComplexMap provides several helper functions obtain GMT files. align package’s philosophy clarity avoiding namespace conflicts, call functions explicitly using package::function() syntax (e.g., ComplexMap::getGmtFromFile()) instead using library(). Let’s explore method, paying close attention identifier type returns.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_01-prep-input.html","id":"method-1-from-a-user-provided-local-file","dir":"Articles","previous_headings":"Preparing Functional Gene Sets (GMT)","what":"Method 1: From a User-Provided Local File","title":"1. Preparing Your Input Data","text":"direct method. GMT file, can load ComplexMap::getGmtFromFile(). First, get path example GMT file included package. file uses Gene Symbols. Load GMT file path. Let’s inspect identifiers: Identifier Match: example GMT file uses Gene Symbols. Since hypothetical myComplexes list also uses Gene Symbols, directly compatible ready analysis.","code":"gmtPath <- ComplexMap::getExampleGmt() gmtFromFile <- ComplexMap::getGmtFromFile(gmtPath, verbose = FALSE) # First 5 genes in the first gene set: utils::head(gmtFromFile[[1]], 5) #> [1] \"ATF2\"  \"CHUK\"  \"IFNG\"  \"IKBKB\" \"IL2\""},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_01-prep-input.html","id":"method-2-from-the-molecular-signatures-database-msigdb","dir":"Articles","previous_headings":"Preparing Functional Gene Sets (GMT)","what":"Method 2: From the Molecular Signatures Database (MSigDB)","title":"1. Preparing Your Input Data","text":"msigdbr package provides powerful --date interface MSigDB collections. ComplexMap::getMsigdbGmt() function simplifies process. Identifier Match: default, msigdbr also returns Gene Symbols. directly compatible myComplexes list.","code":"# Fetch the Hallmark gene sets for Human # This requires the `msigdbr` package if (requireNamespace(\"msigdbr\", quietly = TRUE)) {   h_gmt <- ComplexMap::getMsigdbGmt(species = \"Homo sapiens\", collection = \"H\")    # Inspect the identifiers   utils::head(h_gmt[[1]], 5) } #> Fetching MSigDB sets (Species: Homo sapiens, Cat: H) #> [1] \"ABCA1\" \"ABCB8\" \"ACAA2\" \"ACADL\" \"ACADM\""},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_01-prep-input.html","id":"method-3-from-gene-ontology-go-via-bioconductor","dir":"Articles","previous_headings":"Preparing Functional Gene Sets (GMT)","what":"Method 3: From Gene Ontology (GO) via Bioconductor","title":"1. Preparing Your Input Data","text":"Using official Bioconductor annotation packages highly reproducible way get functional annotations. databases, however, typically use stable database identifiers, gene symbols. Identifier Mismatch! getGoGmt function returns list genes Entrez IDs (e.g., “5594”, “5595”). match Gene Symbols myComplexes list (e.g., “POLR2A”). Solution: Convert Complex List Identifiers recommended approach convert input complex identifiers match stable IDs annotation database. AnnotationDbi::mapIds function perfect . Now, myComplexesEntrez list directly compatible goGmt generated Bioconductor.","code":"# This requires an organism annotation package, e.g., org.Hs.eg.db for human if (requireNamespace(\"org.Hs.eg.db\", quietly = TRUE)) {   # Fetch Biological Process (BP) terms   # We pass the database object directly using the `::` operator   goGmt <- ComplexMap::getGoGmt(speciesDb = org.Hs.eg.db::org.Hs.eg.db,                                  ontology = \"BP\",                                 verbose = FALSE)    # Inspect the identifiers   utils::head(goGmt[[1]], 5) } #>  #> 'select()' returned 1:many mapping between keys and columns #>  #> 'select()' returned 1:1 mapping between keys and columns #> [1] \"1743\" \"2805\" \"2806\" \"3417\" \"3418\" if (requireNamespace(\"org.Hs.eg.db\", quietly = TRUE)) {   # Get all unique symbols from our complex list   allSymbols <- unique(unlist(myComplexes))    # Map symbols to Entrez IDs, taking the first ID if multiple exist   symbolToEntrez <- AnnotationDbi::mapIds(       org.Hs.eg.db::org.Hs.eg.db,       keys = allSymbols,       keytype = \"SYMBOL\",       column = \"ENTREZID\",       multiVals = \"first\"   )      # Remove any symbols that could not be mapped   symbolToEntrez <- symbolToEntrez[!is.na(symbolToEntrez)]    # Now, create a new complex list with Entrez IDs   myComplexesEntrez <- lapply(myComplexes, function(complex) {     # Look up the Entrez ID for each symbol     entrez_ids <- symbolToEntrez[complex]     # Return only the successfully mapped IDs, removing any NAs     unname(entrez_ids[!is.na(entrez_ids)])   })    # Inspect the result   print(myComplexesEntrez) } #> 'select()' returned 1:1 mapping between keys and columns #> $CPLX1 #> [1] \"5430\" \"5431\" \"5432\" #>  #> $CPLX2 #> [1] \"983\"  \"891\"  \"9133\""},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_01-prep-input.html","id":"method-4-from-reactome-pathways-via-bioconductor","dir":"Articles","previous_headings":"Preparing Functional Gene Sets (GMT)","what":"Method 4: From Reactome Pathways via Bioconductor","title":"1. Preparing Your Input Data","text":"Similarly, reactome.db package provides pathway annotations, also use Entrez IDs. Identifier Mismatch! Like GO example, reactome.db provides Entrez IDs. Solution: solution Gene Ontology. use myComplexesEntrez list created previous step, identifiers match identifiers reactomeGmt.","code":"if (requireNamespace(\"reactome.db\", quietly = TRUE) &&      requireNamespace(\"org.Hs.eg.db\", quietly = TRUE)) {          reactomeGmt <- ComplexMap::getReactomeGmt(       speciesDb = org.Hs.eg.db::org.Hs.eg.db,       verbose = FALSE   )    # Inspect the identifiers   utils::head(reactomeGmt[[1]], 5) } #> [1] \"1\"     \"10019\" \"10112\" \"10125\" \"10125\""},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_01-prep-input.html","id":"conclusion","dir":"Articles","previous_headings":"","what":"Conclusion","title":"1. Preparing Your Input Data","text":"vignette demonstrated core philosophy ComplexMap: flexibility identifier consistency. understanding identifier types returned different sources knowing convert data match, can apply ComplexMap workflow virtually organism. Always check identifiers running ComplexMap::createComplexMap() ensure smooth successful analysis. explicit package::function() syntax demonstrated recommended best practice writing clean, reproducible, error-free analysis scripts.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_01-workflow.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"A Typical Workflow","text":"Protein complexes functional machinery cell. High-throughput experimental methods can identify hundreds putative protein complexes single experiment. ComplexMap package provides comprehensive, end--end workflow process, analyze, annotate, visualize dataset. vignette demonstrates main analysis workflow using high-level createComplexMap() wrapper function. use dataset human soluble protein complexes, originally published 2012 census human soluble protein complexes, perform complete analysis start finish. showcase downstream analysis functions interpreting exploring results.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_01-workflow.html","id":"step-1-loading-data","dir":"Articles","previous_headings":"","what":"Step 1: Loading Data","title":"A Typical Workflow","text":"ComplexMap package includes demoComplexes dataset, list 622 putative human protein complexes. also load example gene set (GMT) file functional annotation.","code":"# Load the example complex list shipped with the package utils::data(\"demoComplexes\", package = \"ComplexMap\")  # Get the path to the example GMT file and load it gmtPath <- ComplexMap::getExampleGmt() biocartaGmt <- ComplexMap::getGmtFromFile(gmtPath, verbose = FALSE)"},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_01-workflow.html","id":"step-2-running-the-main-workflow","dir":"Articles","previous_headings":"","what":"Step 2: Running the Main Workflow","title":"A Typical Workflow","text":"core package createComplexMap() function. single wrapper function handles essential processing steps: Quality Control & Refinement: Filters complexes size merges highly redundant ones. Functional Enrichment: Annotates complex biological functions. Network Construction: Builds similarity network based shared proteins functions. Attribute & Topology Generation: Calculates node colors, sizes, layout coordinates visualization. can pass parameters underlying functions (like mergeThreshold refineComplexList) directly wrapper. output, complexMapObject, formal ComplexMap S3 object contains complete results analysis. Printing object gives high-level summary.","code":"# Run the entire workflow with a single command # We will merge complexes with a Jaccard similarity of 0.75 or higher complexMapObject <- ComplexMap::createComplexMap(   complexList = demoComplexes,   gmt = biocartaGmt,   mergeThreshold = 0.75 ) #> --- Starting ComplexMap Workflow --- #>  #> Step 1: Refining complex list... #>  #> --- Refining Input Complex List --- #> Filtered 112 complexes by size. Retaining 510. #> Identifying merge groups with Jaccard >= 0.75... #> Found 0 merge groups. Merging 0 complexes into 510. #> Merging complete. Final list has 510 complexes. #>  #> --- Refinement Complete --- #>  #> Step 2: Running enrichment analysis... #> Running enrichment for 510 complexes... #> Annotation complete. Found terms for 239 complexes. #>  #> Step 3: Building complex network... #> Building complex network using 'jaccard' similarity... #> Using 11 cores for parallel processing. #> Processing 129795 complex pairs... #> Split into 130 chunks of up to 1000 pairs each. #> Combining results from chunks... #> Calculating final weights and filtering... #> Network construction complete: 1020 edges retained. #>  #> Step 4: Generating node attributes... #> Generating core node attributes (function and color)... #>     -> Clustering terms using 'jaccard' similarity. #> Metric: 'jaccard' with unit: 'log'; comparing: 231 vectors #>  #> Step 5: Computing map topology... #> Computing map topology (layout and centrality)... #> Topology computation complete. #>  #> --- ComplexMap Workflow Complete --- # Print the object to see a summary complexMapObject #> # A ComplexMap Object #> # ── 510 nodes and 1020 edges #> # ── 15 major biological themes identified. #> # ── Use `getNodeTable()` or `getEdgeTable()` to access data."},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_01-workflow.html","id":"step-3-summarizing-biological-themes","dir":"Articles","previous_headings":"","what":"Step 3: Summarizing Biological Themes","title":"A Typical Workflow","text":"key goal map identify major biological themes. summarizeThemes() function uses community detection algorithms find densely connected network modules provides summary. result table listing theme, descriptive label (derived common function within theme), size terms nodes edges.","code":"themeSummary <- ComplexMap::summarizeThemes(complexMapObject) #> Summarizing themes using the 'louvain' community algorithm... #> Identified 295 distinct themes.  # Display the top 10 largest themes themeSummary %>%   dplyr::arrange(dplyr::desc(nodeCount)) %>%   utils::head(10) #> # A tibble: 10 × 4 #>    themeId    themeLabel                  nodeCount edgeCount #>    <membrshp> <chr>                           <int>     <int> #>  1  2         BIOCARTA_EICOSANOID_PATHWAY        42       167 #>  2  1         BIOCARTA_EICOSANOID_PATHWAY        30        89 #>  3  7         BIOCARTA_EICOSANOID_PATHWAY        23        93 #>  4  5         BIOCARTA_EICOSANOID_PATHWAY        21        98 #>  5  9         BIOCARTA_EICOSANOID_PATHWAY        19        56 #>  6  4         BIOCARTA_EICOSANOID_PATHWAY        16        68 #>  7  6         BIOCARTA_EICOSANOID_PATHWAY        13        29 #>  8 12         BIOCARTA_ETS_PATHWAY               13        24 #>  9 13         BIOCARTA_EICOSANOID_PATHWAY        10        24 #> 10  3         BIOCARTA_EICOSANOID_PATHWAY         8        22"},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_01-workflow.html","id":"step-4-exploring-and-querying-the-map","dir":"Articles","previous_headings":"","what":"Step 4: Exploring and Querying the Map","title":"A Typical Workflow","text":"queryMap() function provides powerful way programmatically explore results.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_01-workflow.html","id":"querying-for-a-specific-protein","dir":"Articles","previous_headings":"Step 4: Exploring and Querying the Map","what":"4.1 Querying for a Specific Protein","title":"A Typical Workflow","text":"Let’s find complexes contain protein “SMAD4”.","code":"# To ensure our example is robust, let's find a protein to query # that is guaranteed to be in our final, refined map. nodes <- ComplexMap::getNodeTable(complexMapObject) first_protein_list <- nodes$proteins[1] query_protein <- strsplit(first_protein_list, \",\")[[1]][1]  message(\"Dynamically querying for a protein found in the map: \", query_protein) #> Dynamically querying for a protein found in the map: WDR3  protein_complexes <- ComplexMap::queryMap(   complexMapObject,   query = query_protein,   type = \"protein\" )  # Show the primary functional domain of the resulting complexes protein_complexes %>%   dplyr::select(complexId, primaryFunctionalDomain, proteins) #> # A tibble: 1 × 3 #>   complexId   primaryFunctionalDomain     proteins                               #>   <chr>       <chr>                       <chr>                                  #> 1 CpxMap_0414 BIOCARTA_EICOSANOID_PATHWAY WDR3,RB1,PNO1,EMG1,CSNK1E,TPTEP2-CSNK…"},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_01-workflow.html","id":"querying-for-a-specific-complex","dir":"Articles","previous_headings":"Step 4: Exploring and Querying the Map","what":"4.2 Querying for a Specific Complex","title":"A Typical Workflow","text":"can also retrieve data single complex interest.","code":"# Note: The exact CpxMap ID may vary slightly between runs # if refinement results change. We query for the first node in the table. first_complex_id <- ComplexMap::getNodeTable(complexMapObject)$complexId[1]  complex_data <- ComplexMap::queryMap(   complexMapObject,   query = first_complex_id,   type = \"complex\" )  dplyr::glimpse(complex_data) #> Rows: 1 #> Columns: 11 #> $ complexId               <chr> \"CpxMap_0414\" #> $ proteinCount            <int> 8 #> $ proteins                <chr> \"WDR3,RB1,PNO1,EMG1,CSNK1E,TPTEP2-CSNK1E,DDX49… #> $ primaryFunctionalDomain <chr> \"BIOCARTA_EICOSANOID_PATHWAY\" #> $ topEnrichedFunctions    <chr> \"BIOCARTA_ARF_PATHWAY, BIOCARTA_BTG2_PATHWAY, … #> $ colorHex                <chr> \"#E41A1C\" #> $ sizeMapping             <dbl> 3 #> $ x                       <dbl> 4.630453 #> $ y                       <dbl> 15.11785 #> $ betweenness             <dbl> 0.05917501 #> $ degree                  <dbl> 45"},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_01-workflow.html","id":"step-5-visualization","dir":"Articles","previous_headings":"","what":"Step 5: Visualization","title":"A Typical Workflow","text":"Finally, can visualize entire functional landscape. ComplexMap provides three visualization functions work directly ComplexMap object. First, extract final node edge tables plotting.","code":"mapLayout <- ComplexMap::getNodeTable(complexMapObject) networkEdges <- ComplexMap::getEdgeTable(complexMapObject)"},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_01-workflow.html","id":"static-plot-with-a-legend","dir":"Articles","previous_headings":"Step 5: Visualization","what":"5.1 Static Plot with a Legend","title":"A Typical Workflow","text":"version useful clean overview, using discrete color legend represent functional domains.","code":"ComplexMap::visualizeMapWithLegend(mapLayout, networkEdges) #> Visualizing ComplexMap with a color legend..."},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_01-workflow.html","id":"interactive-plot","dir":"Articles","previous_headings":"Step 5: Visualization","what":"5.2 Interactive Plot","title":"A Typical Workflow","text":"deep exploration, interactive HTML widget ideal. can zoom, pan, hover nodes see detailed tooltips.","code":"# visNetwork is required for this plot if (requireNamespace(\"visNetwork\", quietly = TRUE)) {   ComplexMap::visualizeMapInteractive(mapLayout, networkEdges) } #> Generating interactive visNetwork plot..."},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_01-workflow.html","id":"conclusion","dir":"Articles","previous_headings":"","what":"Conclusion","title":"A Typical Workflow","text":"vignette demonstrated power simplicity refactored ComplexMap workflow. using main createComplexMap() wrapper, complete analysis can run single step. resulting object can easily interpreted, queried, visualized, providing user-friendly powerful platform exploring landscape protein complexes.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_02-advanced-analysis.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Advanced Analysis","text":"ComplexMap::createComplexMap() function provides seamless, one-step workflow use cases, package also includes suite granular functions users require control, wish benchmark results, need export data tools. vignette covers advanced topics: Granular Workflow Control: Running quality control refinement steps manually inspect intermediate results. Benchmarking Predictions: Using evaluateComplexes() compare experimental complexes reference set like CORUM. Advanced Network Exploration: Adding theme information back ComplexMap object enable powerful, theme-based queries. Interoperability: Exporting final network visualization analysis external software like Cytoscape. use package’s built-datasets demonstration.","code":"# Load the experimental and reference complex lists utils::data(\"demoComplexes\", package = \"ComplexMap\") utils::data(\"referenceComplexes\", package = \"ComplexMap\")"},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_02-advanced-analysis.html","id":"granular-workflow-control","dir":"Articles","previous_headings":"","what":"1. Granular Workflow Control","title":"Advanced Analysis","text":"createComplexMap() function automatically runs quality control refinement. However, can run steps manually using underlying functions better understand tune analysis.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_02-advanced-analysis.html","id":"quality-control","dir":"Articles","previous_headings":"1. Granular Workflow Control","what":"1.1 Quality Control","title":"Advanced Analysis","text":"First, can run qcComplexList() raw input data get detailed report complex sizes redundancy. report provides summary statistics warns us number complex pairs highly redundant (Jaccard similarity >= 0.8). confirms refinement step necessary.","code":"# Run the QC function with verbose output ComplexMap::qcComplexList(demoComplexes) #>  #> --- Running Quality Control on Complex List --- #>  #> [1] Basic Statistics: #>     - Total number of complexes: 622 #>     - Total number of unique proteins: 2649 #>  #> [2] Complex Size Distribution: #>        Min. 1st Qu.  Median    Mean 3rd Qu.    Max. #>       1.000   3.000   4.000   5.183   5.000 102.000 #> Warning in ComplexMap::qcComplexList(demoComplexes): 112 complexes have fewer #> than 3 members. #>  #> [3] Redundancy Analysis: #>     - Distribution of Jaccard similarity scores: #>          Min.   1st Qu.    Median      Mean   3rd Qu.      Max. #>     0.0000000 0.0000000 0.0000000 0.0003226 0.0000000 0.5000000 #>     - No highly redundant complex pairs detected. #>  #> --- QC Complete ---"},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_02-advanced-analysis.html","id":"manual-refinement","dir":"Articles","previous_headings":"1. Granular Workflow Control","what":"1.2 Manual Refinement","title":"Advanced Analysis","text":"Next, can manually run refineComplexList(). allows us inspect set complexes merging functional enrichment, can useful debugging parameter tuning. Running step manually gives us direct access refinedComplexes list inspection proceeding rest workflow.","code":"message(\"Number of complexes before refinement: \", length(demoComplexes)) #> Number of complexes before refinement: 622  # Merge complexes with a Jaccard similarity of 0.75 or higher refinedComplexes <- ComplexMap::refineComplexList(   demoComplexes,   mergeThreshold = 0.75,   verbose = FALSE # Set to TRUE for detailed messages )  message(\"Number of complexes after refinement: \", length(refinedComplexes)) #> Number of complexes after refinement: 510"},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_02-advanced-analysis.html","id":"benchmarking-predictions","dir":"Articles","previous_headings":"","what":"2. Benchmarking Predictions","title":"Advanced Analysis","text":"methods development, essential evaluate well set predicted complexes matches “gold standard” reference. evaluateComplexes() function calculates four standard metrics purpose. compare refinedComplexes referenceComplexes (curated subset CORUM). PPV (Positive Predictive Value): Measures accuracy predictions. Sn (Sensitivity): Measures coverage reference set. Acc (Accuracy): geometric mean PPV Sn. MMR (Maximum Matching Ratio): score based finding best one--one mapping predicted reference complexes. metrics provide quantitative assessment complex prediction quality.","code":"# Evaluate the refined complexes against the reference set evaluationMetrics <- ComplexMap::evaluateComplexes(   predictedComplexes = refinedComplexes,   referenceComplexes = referenceComplexes,   verbose = FALSE )  # Print the resulting metrics print(evaluationMetrics) #> $PPV #> [1] 0.8005051 #>  #> $Sn #> [1] 0.2510583 #>  #> $Acc #> [1] 0.4483006 #>  #> $MMR #> [1] 0.09403458"},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_02-advanced-analysis.html","id":"advanced-network-exploration-querying-by-theme","dir":"Articles","previous_headings":"","what":"3. Advanced Network Exploration: Querying by Theme","title":"Advanced Analysis","text":"main workflow vignette, used summarizeThemes() get table biological themes. powerful advanced technique add theme information back ComplexMap object , enabling direct queries. First, let’s generate ComplexMap object. Now, generate themes add theme assignments node table. prepared object, can now find complexes belonging specific theme, example, “26S Proteasome”. technique provides powerful way programmatically subset analyze biological modules within map.","code":"gmtPath <- ComplexMap::getExampleGmt() gmt <- ComplexMap::getGmtFromFile(gmtPath, verbose = FALSE)  # We use the manually refined list as input cm_obj <- ComplexMap::createComplexMap(   complexList = refinedComplexes,   gmt = gmt,   verbose = FALSE ) #> Metric: 'jaccard' with unit: 'log'; comparing: 231 vectors # Generate the theme summary to get theme labels theme_summary <- ComplexMap::summarizeThemes(cm_obj, verbose = FALSE)  # To get the theme assignment for each node, we must re-run community detection nodes <- ComplexMap::getNodeTable(cm_obj) edges <- ComplexMap::getEdgeTable(cm_obj) graph <- igraph::graph_from_data_frame(d = edges, vertices = nodes, directed = FALSE) communities <- igraph::cluster_louvain(graph)  # Create a mapping from themeId (integer) to themeLabel (character) theme_map <- theme_summary[, c(\"themeId\", \"themeLabel\")]  # Add theme ID and label columns to our node table nodes$themeId <- igraph::membership(communities) nodes <- dplyr::left_join(nodes, theme_map, by = \"themeId\")  # **Crucially, update the object with the new node information** cm_obj$nodes <- nodes # To make the example robust, we query for a theme label that we know # exists because we just generated it in the `theme_summary` table. query_label <- theme_summary$themeLabel  message(\"Dynamically querying for a theme found in the map: \", query_label) #> Dynamically querying for a theme found in the map: BIOCARTA_EICOSANOID_PATHWAYBIOCARTA_EICOSANOID_PATHWAYBIOCARTA_EICOSANOID_PATHWAYBIOCARTA_EICOSANOID_PATHWAYBIOCARTA_EICOSANOID_PATHWAYBIOCARTA_EICOSANOID_PATHWAYBIOCARTA_EICOSANOID_PATHWAYBIOCARTA_EPONFKB_PATHWAYBIOCARTA_EICOSANOID_PATHWAYBIOCARTA_EICOSANOID_PATHWAYBIOCARTA_RAB_PATHWAYBIOCARTA_ETS_PATHWAYBIOCARTA_EICOSANOID_PATHWAYBIOCARTA_MCM_PATHWAYBIOCARTA_EICOSANOID_PATHWAYBIOCARTA_S1P_PATHWAYBIOCARTA_MRP_PATHWAYBIOCARTA_CYTOKINE_PATHWAYBIOCARTA_GABA_PATHWAYBIOCARTA_LDL_PATHWAYBIOCARTA_SAM68_PATHWAYBIOCARTA_NUCLEARRS_PATHWAYMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedBIOCARTA_VITCB_PATHWAYMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedBIOCARTA_ARAP_PATHWAYMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or UnenrichedMixed or Unenriched  theme_complexes <- ComplexMap::queryMap(   cm_obj,   query = query_label,   type = \"theme\" ) #> Warning in nodes$themeLabel == query: longer object length is not a multiple of #> shorter object length  # Show the results theme_complexes %>%   dplyr::select(complexId, themeLabel, proteinCount, betweenness) #> # A tibble: 258 × 4 #>    complexId   themeLabel                  proteinCount betweenness #>    <chr>       <chr>                              <int>       <dbl> #>  1 CpxMap_0414 BIOCARTA_EICOSANOID_PATHWAY            8      0.0592 #>  2 CpxMap_0359 BIOCARTA_EICOSANOID_PATHWAY            5      0.0391 #>  3 CpxMap_0501 BIOCARTA_EICOSANOID_PATHWAY           20      0.0326 #>  4 CpxMap_0401 BIOCARTA_EICOSANOID_PATHWAY            6      0.0323 #>  5 CpxMap_0090 BIOCARTA_EICOSANOID_PATHWAY            4      0.0181 #>  6 CpxMap_0491 BIOCARTA_EICOSANOID_PATHWAY           15      0.0181 #>  7 CpxMap_0182 BIOCARTA_EICOSANOID_PATHWAY            4      0.0181 #>  8 CpxMap_0397 BIOCARTA_EICOSANOID_PATHWAY            7      0.0177 #>  9 CpxMap_0177 BIOCARTA_EICOSANOID_PATHWAY            6      0.0177 #> 10 CpxMap_0481 BIOCARTA_EICOSANOID_PATHWAY           10      0.0105 #> # ℹ 248 more rows"},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_02-advanced-analysis.html","id":"interoperability-exporting-to-cytoscape","dir":"Articles","previous_headings":"","what":"4. Interoperability: Exporting to Cytoscape","title":"Advanced Analysis","text":"ComplexMap provides excellent internal visualizations, may want use powerful tools like Cytoscape advanced analysis, network manipulation, creating publication-quality figures. exportNetwork() function writes node edge tables disk tab-separated files (.tsv), can easily imported Cytoscape. use Cytoscape, : Go File > Import > Network File... select _edges.tsv file. mapping dialog, map source_complex_id column “Source Node” target_complex_id “Target Node”. network loaded, go File > Import > Table File... select _nodes.tsv file. Ensure “Key column network” set complexId. import node attributes (colors, sizes, functional domains, etc.) map directly onto network.","code":"# Use a temporary directory for this example temp_dir <- tempdir() file_prefix <- file.path(temp_dir, \"human_complex_map\")  # Export the network ComplexMap::exportNetwork(cm_obj, filePrefix = file_prefix) #> Exporting network in Cytoscape format to: #>  -> /tmp/RtmpDxAzUP/human_complex_map_nodes.tsv #>  -> /tmp/RtmpDxAzUP/human_complex_map_edges.tsv #> Export complete.  # List the files that were created list.files(temp_dir, pattern = \"human_complex_map\") #> [1] \"human_complex_map_edges.tsv\" \"human_complex_map_nodes.tsv\""},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_02-advanced-analysis.html","id":"conclusion","dir":"Articles","previous_headings":"","what":"Conclusion","title":"Advanced Analysis","text":"vignette demonstrated advanced capabilities ComplexMap package. Beyond simple one-step workflow, package provides granular functions quality control, rigorous benchmarking tools methods development, powerful utilities deep, theme-based querying exporting results platforms. layered functionality makes ComplexMap comprehensive toolkit novice expert users.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_02-workflow.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"2. Start a Typical Workflow","text":"Protein complexes functional machinery cell. High-throughput experimental methods can identify hundreds putative protein complexes single experiment. ComplexMap package provides comprehensive, end--end workflow process, analyze, annotate, visualize dataset. vignette demonstrates main analysis workflow using high-level createComplexMap() wrapper function. use dataset human soluble protein complexes, originally published 2012 census human soluble protein complexes, perform complete analysis start finish. showcase downstream analysis functions interpreting exploring results.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_02-workflow.html","id":"step-1-loading-data","dir":"Articles","previous_headings":"","what":"Step 1: Loading Data","title":"2. Start a Typical Workflow","text":"ComplexMap package includes demoComplexes dataset, list 622 putative human protein complexes. also load example gene set (GMT) file functional annotation.","code":"# Load the example complex list shipped with the package utils::data(\"demoComplexes\", package = \"ComplexMap\")  # Get the path to the example GMT file and load it gmtPath <- ComplexMap::getExampleGmt() biocartaGmt <- ComplexMap::getGmtFromFile(gmtPath, verbose = FALSE)"},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_02-workflow.html","id":"step-2-running-the-main-workflow","dir":"Articles","previous_headings":"","what":"Step 2: Running the Main Workflow","title":"2. Start a Typical Workflow","text":"core package createComplexMap() function. single wrapper function handles essential processing steps: Quality Control & Refinement: Filters complexes size merges highly redundant ones. Functional Enrichment: Annotates complex biological functions. Network Construction: Builds similarity network based shared proteins functions. Attribute & Topology Generation: Calculates node colors, sizes, layout coordinates visualization. can pass parameters underlying functions (like mergeThreshold refineComplexList) directly wrapper. output, complexMapObject, formal ComplexMap S3 object contains complete results analysis. Printing object gives high-level summary.","code":"# Run the entire workflow with a single command # We will merge complexes with a Jaccard similarity of 0.75 or higher complexMapObject <- ComplexMap::createComplexMap(   complexList = demoComplexes,   gmt = biocartaGmt,   mergeThreshold = 0.75 ) #> --- Starting ComplexMap Workflow --- #>  #> Step 1: Refining complex list... #>  #> --- Refining Input Complex List --- #> Filtered 112 complexes by size. Retaining 510. #> Identifying merge groups with matching_score >= 0.75... #> Found 0 merge groups. Merging 0 complexes into 510. #> Merging complete. Final list has 510 complexes. #>  #> --- Refinement Complete --- #>  #> Step 2: Running enrichment analysis... #> Running enrichment for 510 complexes... #> Annotation complete. Found terms for 239 complexes. #>  #> Step 3: Building complex network... #> Building complex network using 'jaccard' similarity... #> Using 7 cores for parallel processing. #> Processing 129795 complex pairs... #> Split into 130 chunks of up to 1000 pairs each. #> Combining results from chunks... #> Calculating final weights and filtering... #> Network construction complete: 1390 edges retained. #>  #> Step 4: Generating node attributes... #> Generating core node attributes (function and color)... #>     -> Clustering 231 terms using co-occurrence (overlap) #>     -> Identified 3 functional domains #>  #> Step 5: Computing map topology... #> Computing map topology (layout and centrality)... #> Topology computation complete. #>  #> --- ComplexMap Workflow Complete --- # Print the object to see a summary complexMapObject #> # A ComplexMap Object #> # ── 510 nodes and 1390 edges #> # ── 3 major biological themes identified. #> # ── Use `getNodeTable()` or `getEdgeTable()` to access data."},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_02-workflow.html","id":"step-3-summarizing-biological-themes","dir":"Articles","previous_headings":"","what":"Step 3: Summarizing Biological Themes","title":"2. Start a Typical Workflow","text":"key goal map identify major biological themes. summarizeThemes() function uses community detection algorithms find densely connected network modules provides summary. result table listing theme, descriptive label (derived common function within theme), size terms nodes edges.","code":"themeSummary <- ComplexMap::summarizeThemes(complexMapObject) #> Summarizing themes using the 'louvain' community algorithm... #> Identified 98 distinct themes.  # Display the top 10 largest themes themeSummary %>%   dplyr::arrange(dplyr::desc(nodeCount)) %>%   utils::head(10) #> # A tibble: 10 × 4 #>    themeId themeLabel                  nodeCount edgeCount #>      <int> <chr>                           <int>     <int> #>  1       1 BIOCARTA_PTDINS_PATHWAY            56       180 #>  2       2 BIOCARTA_PROTEASOME_PATHWAY        47        86 #>  3       8 BIOCARTA_PROTEASOME_PATHWAY        45        68 #>  4       9 BIOCARTA_PROTEASOME_PATHWAY        31        68 #>  5       6 BIOCARTA_PROTEASOME_PATHWAY        27        47 #>  6       5 BIOCARTA_PROTEASOME_PATHWAY        25        78 #>  7      11 BIOCARTA_PROTEASOME_PATHWAY        25        92 #>  8      12 BIOCARTA_PROTEASOME_PATHWAY        24       101 #>  9       4 BIOCARTA_PROTEASOME_PATHWAY        20        49 #> 10      10 BIOCARTA_CACAM_PATHWAY             20        20"},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_02-workflow.html","id":"step-4-exploring-and-querying-the-map","dir":"Articles","previous_headings":"","what":"Step 4: Exploring and Querying the Map","title":"2. Start a Typical Workflow","text":"queryMap() function provides powerful way programmatically explore results.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_02-workflow.html","id":"querying-for-a-specific-protein","dir":"Articles","previous_headings":"Step 4: Exploring and Querying the Map","what":"4.1 Querying for a Specific Protein","title":"2. Start a Typical Workflow","text":"Let’s find complexes contain protein “SMAD4”.","code":"# To ensure our example is robust, let's find a protein to query # that is guaranteed to be in our final, refined map. nodes <- ComplexMap::getNodeTable(complexMapObject) first_protein_list <- nodes$proteins[1] query_protein <- strsplit(first_protein_list, \",\")[[1]][1]  message(\"Dynamically querying for a protein found in the map: \", query_protein) #> Dynamically querying for a protein found in the map: PRKACB  protein_complexes <- ComplexMap::queryMap(   complexMapObject,   query = query_protein,   type = \"protein\" )  # Show the primary functional domain of the resulting complexes protein_complexes %>%   dplyr::select(complexId, primaryFunctionalDomain, proteins) #> # A tibble: 1 × 3 #>   complexId   primaryFunctionalDomain proteins                            #>   <chr>       <chr>                   <chr>                               #> 1 CpxMap_0359 BIOCARTA_CACAM_PATHWAY  PRKACB,PRKACA,PRKAR2A,CIRBP,CAPRIN1"},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_02-workflow.html","id":"querying-for-a-specific-complex","dir":"Articles","previous_headings":"Step 4: Exploring and Querying the Map","what":"4.2 Querying for a Specific Complex","title":"2. Start a Typical Workflow","text":"can also retrieve data single complex interest.","code":"# Note: The exact CpxMap ID may vary slightly between runs # if refinement results change. We query for the first node in the table. first_complex_id <- ComplexMap::getNodeTable(complexMapObject)$complexId[1]  complex_data <- ComplexMap::queryMap(   complexMapObject,   query = first_complex_id,   type = \"complex\" )  dplyr::glimpse(complex_data) #> Rows: 1 #> Columns: 11 #> $ complexId               <chr> \"CpxMap_0359\" #> $ proteinCount            <int> 5 #> $ proteins                <chr> \"PRKACB,PRKACA,PRKAR2A,CIRBP,CAPRIN1\" #> $ primaryFunctionalDomain <chr> \"BIOCARTA_CACAM_PATHWAY\" #> $ topEnrichedFunctions    <chr> \"BIOCARTA_AGPCR_PATHWAY; BIOCARTA_AKAP13_PATHW… #> $ colorHex                <chr> \"#836FA8\" #> $ sizeMapping             <dbl> 2.321928 #> $ x                       <dbl> 7.989894 #> $ y                       <dbl> 6.128077 #> $ betweenness             <dbl> 0.1544715 #> $ degree                  <dbl> 33"},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_02-workflow.html","id":"step-5-visualization","dir":"Articles","previous_headings":"","what":"Step 5: Visualization","title":"2. Start a Typical Workflow","text":"Finally, can visualize entire functional landscape. ComplexMap provides three visualization functions work directly ComplexMap object. First, extract final node edge tables plotting.","code":"mapLayout <- ComplexMap::getNodeTable(complexMapObject) networkEdges <- ComplexMap::getEdgeTable(complexMapObject)"},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_02-workflow.html","id":"static-plot-with-a-legend","dir":"Articles","previous_headings":"Step 5: Visualization","what":"5.1 Static Plot with a Legend","title":"2. Start a Typical Workflow","text":"version useful clean overview, using discrete color legend represent functional domains.","code":"ComplexMap::visualizeMapWithLegend(mapLayout, networkEdges) #> Visualizing ComplexMap with a color legend..."},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_02-workflow.html","id":"interactive-plot","dir":"Articles","previous_headings":"Step 5: Visualization","what":"5.2 Interactive Plot","title":"2. Start a Typical Workflow","text":"deep exploration, interactive HTML widget ideal. can zoom, pan, hover nodes see detailed tooltips.","code":"# visNetwork is required for this plot if (requireNamespace(\"visNetwork\", quietly = TRUE)) {   ComplexMap::visualizeMapInteractive(mapLayout, networkEdges) } #> Generating interactive visNetwork plot..."},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_02-workflow.html","id":"conclusion","dir":"Articles","previous_headings":"","what":"Conclusion","title":"2. Start a Typical Workflow","text":"using main createComplexMap() wrapper, complete analysis can run single step. resulting object can easily interpreted, queried, visualized, providing user-friendly powerful platform exploring landscape protein complexes.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_03-advanced-analysis.html","id":"advanced-analysis-workflow","dir":"Articles","previous_headings":"","what":"Advanced Analysis Workflow","title":"3. Advanced Analysis and Visualization","text":"ComplexMap object, package provides several functions deeper analysis interpretation network structure. vignette covers: Optimizing Parameters: Using evaluateComplexes() tune refineComplexList step. Summarizing Themes: Using summarizeThemes() identify major biological clusters. Querying Map: Using queryMap() find specific proteins, complexes, themes.","code":"library(ComplexMap) library(dplyr) library(ggplot2) library(igraph)"},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_03-advanced-analysis.html","id":"optimizing-refinement-with-evaluatecomplexes","dir":"Articles","previous_headings":"Advanced Analysis Workflow","what":"1. Optimizing Refinement with evaluateComplexes","title":"3. Advanced Analysis and Visualization","text":"mergeThreshold refineComplexList critical parameter determines aggressively smaller complexes merged. low threshold creates fewer, larger complexes, high threshold preserves distinct complexes. optimal value often depends dataset. evaluateComplexes() function can used score refined complex list gold standard (like referenceComplexes dataset) help guide choice. returns four key metrics: Positive Predictive Value (PPV), Sensitivity (Sn), Accuracy (Acc), Maximum Matching Ratio (MMR). Let’s test mergeThreshold 0.85. systematic tuning, see documentation new benchmarkParameters() function, automates process range thresholds.","code":"# Load the package's demo and reference data data(demoComplexes) data(referenceComplexes)  # refineComplexList now returns a list with two elements refinement_output <- refineComplexList(   demoComplexes,   mergeThreshold = 0.85,   verbose = FALSE )  # We must now explicitly use the `$refinedComplexes` element for evaluation metrics <- evaluateComplexes(   predictedComplexes = refinement_output$refinedComplexes,   referenceComplexes = referenceComplexes,   nCores = 2, # <-- THIS IS THE FIX: Limit cores for check environment   verbose = FALSE )  # Display the resulting metrics knitr::kable(as.data.frame(metrics))"},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_03-advanced-analysis.html","id":"summarizing-biological-themes","dir":"Articles","previous_headings":"Advanced Analysis Workflow","what":"2. Summarizing Biological Themes","title":"3. Advanced Analysis and Visualization","text":"key goal ComplexMap organize complexes functional landscape. summarizeThemes() function uses network community detection algorithms (like Louvain, default) find densely connected clusters complexes within map. automatically labels cluster based common functional annotation among members. Let’s generate map slightly lower merge threshold create interconnected network example. Now, can run summarizeThemes() object. summary shows us major biological stories dataset, large “Ribosome” “Proteasome” communities.","code":"# We'll use the example GMT file that comes with the package gmtPath <- getExampleGmt() gmt <- getGmtFromFile(gmtPath, verbose = FALSE)  # Create the map object cm_obj_adv <- createComplexMap(   complexList = demoComplexes,   gmt = gmt,   mergeThreshold = 0.75, # Lower threshold for more connections   verbose = FALSE ) # The function returns a tibble summarizing each detected theme theme_summary <- summarizeThemes(cm_obj_adv, verbose = FALSE)  # Display the largest themes theme_summary %>%   arrange(desc(nodeCount)) %>%   head(10) %>%   knitr::kable()"},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_03-advanced-analysis.html","id":"querying-the-map-for-specific-information","dir":"Articles","previous_headings":"Advanced Analysis Workflow","what":"3. Querying the Map for Specific Information","title":"3. Advanced Analysis and Visualization","text":"queryMap() function provides easy way retrieve specific nodes ComplexMap object based different criteria.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_03-advanced-analysis.html","id":"query-by-protein","dir":"Articles","previous_headings":"Advanced Analysis Workflow > 3. Querying the Map for Specific Information","what":"Query by Protein","title":"3. Advanced Analysis and Visualization","text":"Find complexes contain specific protein.","code":"# Find all complexes containing the protein \"UBA1\" queryMap(cm_obj_adv, query = \"UBA1\", type = \"protein\") %>%   select(complexId, primaryFunctionalDomain, proteinCount, proteins) %>%   knitr::kable()"},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_03-advanced-analysis.html","id":"query-by-complex-id","dir":"Articles","previous_headings":"Advanced Analysis Workflow > 3. Querying the Map for Specific Information","what":"Query by Complex ID","title":"3. Advanced Analysis and Visualization","text":"Retrieve data single complex.","code":"# Get the data for complex \"CpxMap_0001\" queryMap(cm_obj_adv, query = \"CpxMap_0001\", type = \"complex\") %>%   knitr::kable()"},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_03-advanced-analysis.html","id":"query-by-theme","dir":"Articles","previous_headings":"Advanced Analysis Workflow > 3. Querying the Map for Specific Information","what":"Query by Theme","title":"3. Advanced Analysis and Visualization","text":"query theme, first need add theme labels summarizeThemes() back main ComplexMap object’s node table. Now themeLabel column exists node table, can query .","code":"# To add the theme labels to our main node table for querying or visualization, # we first need to get the theme ID for each node.  # Re-run the community detection to get the membership vector graph <- igraph::graph_from_data_frame(   d = getEdgeTable(cm_obj_adv),    vertices = getNodeTable(cm_obj_adv),    directed = FALSE ) communities <- igraph::cluster_louvain(graph)  # Create a tibble mapping complexId to themeId # Coerce the 'membership' object to a simple integer for joining node_themes <- tibble(   complexId = names(igraph::membership(communities)),   themeId = as.integer(igraph::membership(communities)) ) theme_summary$themeId <-   as.integer(theme_summary$themeId)  # Join this mapping with the theme summary table to get the labels node_theme_labels <- node_themes %>%   left_join(theme_summary, by = \"themeId\")  # Finally, join the theme labels back to the main node table of our object nodes_with_themes <- getNodeTable(cm_obj_adv) %>%   left_join(node_theme_labels, by = \"complexId\")  # Update the ComplexMap object with this new node table cm_obj_adv$nodes <- nodes_with_themes  # Preview the new columns head(select(cm_obj_adv$nodes, complexId, themeId, themeLabel)) %>%   knitr::kable() # Find all complexes belonging to the \"Proteasome\" theme proteasome_nodes <- queryMap(cm_obj_adv, query = \"BIOCARTA_PROTEASOME_PATHWAY\", type = \"theme\")  cat(\"Found\", nrow(proteasome_nodes), \"nodes in the Proteasome theme.\") #> Found 310 nodes in the Proteasome theme.  proteasome_nodes %>%   select(complexId, primaryFunctionalDomain, proteinCount, betweenness) %>%   head(10) %>%   knitr::kable()"},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_04-quantitative-visualization.html","id":"integrating-experimental-data-into-the-network","dir":"Articles","previous_headings":"","what":"Integrating Experimental Data into the Network","title":"4. Visualizing Quantitative Data","text":"default ComplexMap visualizations color complexes primary functional domain, powerful advanced use-case map quantitative experimental data directly onto network nodes. allows visualize biological information—complex abundance, purity scores, differential expression—context functional map. three core visualization functions (visualizeMapDirectLabels, visualizeMapWithLegend, visualizeMapInteractive) support feature consistent interface. vignette provides step--step workflow creating continuous color visualizations complex-level quantitative data. workflow requires following packages:","code":"library(ComplexMap) library(dplyr)"},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_04-quantitative-visualization.html","id":"step-1-generate-a-stable-base-map","dir":"Articles","previous_headings":"Integrating Experimental Data into the Network","what":"Step 1: Generate a Stable Base Map","title":"4. Visualizing Quantitative Data","text":"first step generate complete ComplexMap object. provides stable network topology layout serve canvas quantitative data.","code":"# Load the package's demo complexes and example GMT file data(demoComplexes) gmtPath <- getExampleGmt() gmt <- getGmtFromFile(gmtPath, verbose = FALSE)  # Run the full workflow to get a ComplexMap object cm_obj <- createComplexMap(   complexList = demoComplexes,   gmt = gmt,   mergeThreshold = 0.8,   verbose = FALSE )  # Extract the node and edge tables node_table <- getNodeTable(cm_obj) edge_table <- getEdgeTable(cm_obj)  cat(\"Generated a base map with\", nrow(node_table), \"nodes.\\n\") #> Generated a base map with 510 nodes."},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_04-quantitative-visualization.html","id":"step-2-prepare-your-quantitative-data","dir":"Articles","previous_headings":"Integrating Experimental Data into the Network","what":"Step 2: Prepare Your Quantitative Data","title":"4. Visualizing Quantitative Data","text":"workflow assumes data frame complex-level quantitative data. data frame must contain column complex IDs match complexId ComplexMap node table (e.g., “CpxMap_0001”), least one numeric column values wish visualize. Let’s create sample data representing “purity score” subset complexes.","code":"# Create sample complex-level data set.seed(123) # for reproducibility complex_quant_data <- tibble(   complexId = sample(node_table$complexId, size = 50),   purity_score = runif(50, min = 0.5, max = 1.0) )  head(complex_quant_data) #> # A tibble: 6 × 2 #>   complexId   purity_score #>   <chr>              <dbl> #> 1 CpxMap_0290        0.561 #> 2 CpxMap_0029        0.780 #> 3 CpxMap_0272        0.603 #> 4 CpxMap_0148        0.564 #> 5 CpxMap_0460        0.877 #> 6 CpxMap_0336        0.948"},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_04-quantitative-visualization.html","id":"step-3-join-quantitative-data-to-the-node-table","dir":"Articles","previous_headings":"Integrating Experimental Data into the Network","what":"Step 3: Join Quantitative Data to the Node Table","title":"4. Visualizing Quantitative Data","text":"Next, simply join new complex-level quantitative data back main node table. use left_join ensure original nodes kept, even without quantitative data.","code":"# Join the quantitative data to the main node table nodes_with_quant <- node_table %>%   left_join(complex_quant_data, by = \"complexId\")  # Preview the new column. Note that complexes without data have NA. head(select(nodes_with_quant, complexId, primaryFunctionalDomain, purity_score)) #> # A tibble: 6 × 3 #>   complexId   primaryFunctionalDomain     purity_score #>   <chr>       <chr>                              <dbl> #> 1 CpxMap_0359 BIOCARTA_CACAM_PATHWAY                NA #> 2 CpxMap_0414 BIOCARTA_PROTEASOME_PATHWAY           NA #> 3 CpxMap_0508 Unenriched                            NA #> 4 CpxMap_0401 BIOCARTA_CACAM_PATHWAY                NA #> 5 CpxMap_0509 BIOCARTA_PROTEASOME_PATHWAY           NA #> 6 CpxMap_0090 BIOCARTA_PTDINS_PATHWAY               NA"},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_04-quantitative-visualization.html","id":"step-4-visualize-the-map-using-any-function","dir":"Articles","previous_headings":"Integrating Experimental Data into the Network","what":"Step 4: Visualize the Map Using Any Function","title":"4. Visualizing Quantitative Data","text":"Now data prepared, can use core visualization functions. key use color.argument specify numeric column used color gradient.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_04-quantitative-visualization.html","id":"plot-1-direct-labels-visualization","dir":"Articles","previous_headings":"Integrating Experimental Data into the Network > Step 4: Visualize the Map Using Any Function","what":"Plot 1: Direct Labels Visualization","title":"4. Visualizing Quantitative Data","text":"plot ideal detailed inspection labels overlap significantly. function automatically generate continuous color bar legend purity_score.","code":"visualizeMapDirectLabels(   layoutDf = nodes_with_quant,   edgesDf = edge_table,   title = \"Complex Map with Purity Score\",   subtitle = \"Nodes colored by quantitative score, labels shown directly\",      # --- Key arguments for continuous coloring ---   color.by = \"purity_score\",   color.palette = \"viridis\",    color.legend.title = \"Purity Score\" )"},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_04-quantitative-visualization.html","id":"plot-2-visualization-with-legend","dir":"Articles","previous_headings":"Integrating Experimental Data into the Network > Step 4: Visualize the Map Using Any Function","what":"Plot 2: Visualization with Legend","title":"4. Visualizing Quantitative Data","text":"plot uses underlying logic designed overviews. color.specified, overrides default discrete legend (functional domains) instead creates continuous color bar, just like direct labels plot.","code":"visualizeMapWithLegend(   layoutDf = nodes_with_quant,   edgesDf = edge_table,   title = \"Complex Map with Purity Score\",   subtitle = \"Nodes colored by quantitative score\",      # --- Key arguments for continuous coloring ---   color.by = \"purity_score\",   color.palette = \"plasma\", # We can easily switch palettes   color.legend.title = \"Purity Score\" )"},{"path":"https://zqzneptune.github.io/ComplexMap/articles/vignette_04-quantitative-visualization.html","id":"plot-3-interactive-visualization","dir":"Articles","previous_headings":"Integrating Experimental Data into the Network > Step 4: Visualize the Map Using Any Function","what":"Plot 3: Interactive Visualization","title":"4. Visualizing Quantitative Data","text":"principle applies interactive plot. specifying color., function color nodes gradient , importantly, add quantitative value hover tooltip easy data exploration. consistent interface across three visualization functions provides maximum flexibility exploring presenting quantitative data context protein complex network.","code":"visualizeMapInteractive(   layoutDf = nodes_with_quant,   edgesDf = edge_table,   title = \"Interactive Complex Map with Purity Score\",      # --- Key arguments for continuous coloring ---   color.by = \"purity_score\",   color.palette = \"viridis\" )"},{"path":"https://zqzneptune.github.io/ComplexMap/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Qingzhou Zhang. Author, maintainer.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Zhang Q (2025). ComplexMap: Toolset Functional Analysis Visualization Protein Complex Data. R package version 1.1.0, https://github.com/zqzneptune/ComplexMap, https://zqzneptune.github.io/ComplexMap.","code":"@Manual{,   title = {ComplexMap: A Toolset for the Functional Analysis and Visualization of Protein Complex Data},   author = {Qingzhou Zhang},   year = {2025},   note = {R package version 1.1.0, https://github.com/zqzneptune/ComplexMap},   url = {https://zqzneptune.github.io/ComplexMap}, }"},{"path":"https://zqzneptune.github.io/ComplexMap/index.html","id":"complexmap-","dir":"","previous_headings":"","what":"A Toolset for the Functional Analysis and Visualization of Protein Complex Data","title":"A Toolset for the Functional Analysis and Visualization of Protein Complex Data","text":"ComplexMap R package provides complete, end--end workflow analysis protein complex datasets. designed take raw list putative protein complexes transform fully annotated, publication-ready functional map.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/index.html","id":"core-features","dir":"","previous_headings":"","what":"Core Features","title":"A Toolset for the Functional Analysis and Visualization of Protein Complex Data","text":"Integrated Workflow: Go raw complex list final network map single function, createComplexMap(). Flexible Refinement: Choose multiple similarity metrics (Matching Score, Simpson, Jaccard, Dice) merge redundant complexes according specific research goals. Functional Enrichment: Annotate complexes using gene sets local files, MSigDB, Gene Ontology, Reactome. Powerful Visualizations: Generate static (ggplot2) interactive (visNetwork) plots explore functional landscape. Quantitative Data Integration: Map experimental data (e.g., protein abundance, fold-change) directly onto network nodes continuous color gradient visualization functions. Robust Benchmarking: Optimize refinement parameters new benchmarkParameters() helper function evaluate results reference standard like CORUM.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"A Toolset for the Functional Analysis and Visualization of Protein Complex Data","text":"can install stable version ComplexMap GitHub. installer automatically handle required dependencies CRAN Bioconductor.","code":"# If you don't have remotes installed: install.packages(\"remotes\") remotes::install_github(\"zqzneptune/ComplexMap\")"},{"path":"https://zqzneptune.github.io/ComplexMap/index.html","id":"workflow-at-a-glance","dir":"","previous_headings":"","what":"Workflow at a Glance","title":"A Toolset for the Functional Analysis and Visualization of Protein Complex Data","text":"example demonstrates core workflow, including new quantitative visualization capabilities.","code":"library(ComplexMap) library(dplyr)  # 1. Load the example complex list and a gene set file data(\"demoComplexes\", package = \"ComplexMap\") gmt_file <- ComplexMap::getExampleGmt() gmt <- ComplexMap::getGmtFromFile(gmt_file, verbose = FALSE)  # 2. Run the entire workflow # The default similarityMethod is now \"matching_score\" cm_obj <- ComplexMap::createComplexMap(   complexList = demoComplexes,   gmt = gmt,   mergeThreshold = 0.8,   verbose = FALSE # Set to TRUE to see workflow steps )  # 3. Print the resulting object for a high-level summary cm_obj #> # A ComplexMap Object #> # ── Use `getNodeTable()` or `getEdgeTable()` to access data.  #   # 4. Visualize with data node_tbl <- ComplexMap::getNodeTable(cm_obj) edge_tbl <- ComplexMap::getEdgeTable(cm_obj)"},{"path":"https://zqzneptune.github.io/ComplexMap/index.html","id":"exploring-the-results","dir":"","previous_headings":"","what":"Exploring the Results","title":"A Toolset for the Functional Analysis and Visualization of Protein Complex Data","text":"ComplexMap object can easily analyzed downstream functions.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/index.html","id":"summarize-biological-themes","dir":"","previous_headings":"Exploring the Results","what":"Summarize Biological Themes","title":"A Toolset for the Functional Analysis and Visualization of Protein Complex Data","text":"Identify major biological themes (network modules) using community detection.","code":"theme_summary <- ComplexMap::summarizeThemes(cm_obj, verbose = FALSE)  # Show the 10 largest themes dplyr::slice_max(theme_summary, n = 10, order_by = nodeCount)"},{"path":"https://zqzneptune.github.io/ComplexMap/index.html","id":"query-the-map","dir":"","previous_headings":"Exploring the Results","what":"Query the Map","title":"A Toolset for the Functional Analysis and Visualization of Protein Complex Data","text":"Programmatically find specific complexes interest.","code":"# Find the complex with the ID \"CpxMap_0001\" result <- ComplexMap::queryMap(cm_obj, query = \"CpxMap_0001\", type = \"complex\")  # Show some of its key attributes dplyr::select(result, complexId, primaryFunctionalDomain, proteinCount, degree)```"},{"path":"https://zqzneptune.github.io/ComplexMap/index.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"A Toolset for the Functional Analysis and Visualization of Protein Complex Data","text":"use ComplexMap research, please cite publication (link added upon publication). now, can cite package : Qingzhou Zhang (2025). ComplexMap: Toolset Functional Analysis Visualization Protein Complex Data. R package version 1.1.0. https://github.com/zqzneptune/ComplexMap","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/index.html","id":"contributing","dir":"","previous_headings":"","what":"Contributing","title":"A Toolset for the Functional Analysis and Visualization of Protein Complex Data","text":"Please note ComplexMap project released Contributor Code Conduct. contributing project, agree abide terms. welcome bug reports, feature requests, pull requests.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/benchmarkParameters.html","id":null,"dir":"Reference","previous_headings":"","what":"Benchmark Complex Refinement Parameters — benchmarkParameters","title":"Benchmark Complex Refinement Parameters — benchmarkParameters","text":"Evaluates performance complex refinement process across range `mergeThreshold` values, providing key metrics reference set.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/benchmarkParameters.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Benchmark Complex Refinement Parameters — benchmarkParameters","text":"","code":"benchmarkParameters(   complexList,   referenceComplexes,   threshold_range = seq(0.5, 1, by = 0.05),   ... )"},{"path":"https://zqzneptune.github.io/ComplexMap/reference/benchmarkParameters.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Benchmark Complex Refinement Parameters — benchmarkParameters","text":"complexList list predicted protein complexes refined. referenceComplexes list reference (gold standard) complexes. threshold_range numeric vector `mergeThreshold` values test. Defaults `seq(0.5, 1.0, = 0.05)`. ... Additional arguments passed `refineComplexList`, `similarityMethod` (e.g., \"jaccard\" \"overlap\"), `minSize`, `maxSize`.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/benchmarkParameters.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Benchmark Complex Refinement Parameters — benchmarkParameters","text":"tidy `tibble` columns: `mergeThreshold`, `PPV`, `Sn`, `Acc`, `MMR`. Rows corresponding thresholds yielded complexes `NA` values metric columns.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/benchmarkParameters.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Benchmark Complex Refinement Parameters — benchmarkParameters","text":"function systematically tests different `mergeThreshold` values help users optimize complex merging step. threshold `threshold_range`: 1.  calls `refineComplexList()` given threshold. 2.  checks resulting list refined complexes. list empty     (can happen threshold 1.0), records `NA`     performance metrics threshold. 3.  list empty, calls `evaluateComplexes()` calculate     PPV, Sensitivity, Accuracy, MMR. function returns single tidy data frame, making easy plot results (e.g., F1-score) identify optimal `mergeThreshold`.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/benchmarkParameters.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Benchmark Complex Refinement Parameters — benchmarkParameters","text":"Qingzhou Zhang <zqzneptune@hotmail.com>","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/benchmarkParameters.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Benchmark Complex Refinement Parameters — benchmarkParameters","text":"","code":"# Load the package's demo data data(demoComplexes) data(referenceComplexes)  if (FALSE) { # \\dontrun{ # Run benchmarking over a range of thresholds using the \"overlap\" method benchmark_results <- benchmarkParameters(   complexList = demoComplexes,   referenceComplexes = referenceComplexes,   threshold_range = seq(0.7, 1.0, by = 0.05),   similarityMethod = \"overlap\" )  print(benchmark_results)  # To find the optimal threshold, calculate the F1-score (harmonic mean # of PPV and Sn) and plot the results. if (requireNamespace(\"ggplot2\", quietly = TRUE) &&     requireNamespace(\"dplyr\", quietly = TRUE)) {    plot_data <- benchmark_results %>%     dplyr::mutate(F1_Score = 2 * (PPV * Sn) / (PPV + Sn))    # Find the best threshold   best_threshold <- plot_data %>%     dplyr::filter(F1_Score == max(F1_Score, na.rm = TRUE)) %>%     dplyr::pull(mergeThreshold)    ggplot2::ggplot(plot_data, ggplot2::aes(x = mergeThreshold, y = F1_Score)) +     ggplot2::geom_line(color = \"blue\") +     ggplot2::geom_point(size = 3, color = \"blue\") +     ggplot2::geom_vline(       xintercept = best_threshold, linetype = \"dashed\", color = \"red\"     ) +     ggplot2::scale_x_continuous(breaks = plot_data$mergeThreshold) +     ggplot2::labs(       title = \"F1-Score vs. Merge Threshold\",       subtitle = paste(\"Optimal threshold based on F1-Score:\", best_threshold),       x = \"Merge Threshold\",       y = \"F1-Score\"     ) +     ggplot2::theme_minimal(base_size = 14) } } # }"},{"path":"https://zqzneptune.github.io/ComplexMap/reference/buildComplexNetwork.html","id":null,"dir":"Reference","previous_headings":"","what":"Build a Complex-Complex Interaction Network — buildComplexNetwork","title":"Build a Complex-Complex Interaction Network — buildComplexNetwork","text":"Constructs network complexes edges represent similarity. similarity can based shared proteins (compositional), shared functional annotations (functional), weighted combination .","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/buildComplexNetwork.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Build a Complex-Complex Interaction Network — buildComplexNetwork","text":"","code":"buildComplexNetwork(   complexes,   enrichments,   mode = \"combined\",   similarityMethod = \"jaccard\",   alpha = 0.5,   nCores = NULL,   chunkSize = 1000,   verbose = TRUE )"},{"path":"https://zqzneptune.github.io/ComplexMap/reference/buildComplexNetwork.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Build a Complex-Complex Interaction Network — buildComplexNetwork","text":"complexes named list protein complexes. enrichments named list enrichment results, corresponding `complexes`. Typically output `runComplexEnrichment`. mode character string specifying calculate final edge weight. One \"functional\", \"compositional\", \"combined\". similarityMethod metric used compositional functional similarity. One \"jaccard\", \"overlap\", \"dice\". alpha numeric value (0-1) used \"combined\" mode weigh compositional similarity score. nCores number CPU cores parallel processing. Defaults one less available. chunkSize number complex pairs process parallel chunk. verbose logical value indicating whether show progress messages progress bar.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/buildComplexNetwork.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Build a Complex-Complex Interaction Network — buildComplexNetwork","text":"`tibble` representing network edges. row includes source target_complex_id complexes, similarity scores, shared component counts, final calculated `weight`, `similarity_mode`.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/buildComplexNetwork.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Build a Complex-Complex Interaction Network — buildComplexNetwork","text":"function calculates pairwise similarities complexes list. highly optimized large datasets using chunking parallel processing via `future` framework. final edge weight determined `mode`: - `\"compositional\"`: Uses protein similarity score. - `\"functional\"`: Uses functional annotation similarity score. - `\"combined\"`: Uses weighted average: `alpha * compositional + (1 - alpha) * functional`. `progressr` package installed, progress bar displayed parallel computation `verbose = TRUE`.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/buildComplexNetwork.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Build a Complex-Complex Interaction Network — buildComplexNetwork","text":"Qingzhou Zhang <zqzneptune@hotmail.com>","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/buildComplexNetwork.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Build a Complex-Complex Interaction Network — buildComplexNetwork","text":"","code":"# --- Sample Data (from previous examples) --- complexes <- list(   Cpx1 = c(\"A\", \"B\", \"C\", \"D\"),   Cpx2 = c(\"A\", \"B\", \"C\", \"E\"), # similar to Cpx1   Cpx3 = c(\"F\", \"G\", \"H\") ) enrichments <- list(   Cpx1 = data.frame(ID = c(\"GO:1\", \"GO:2\")),   Cpx2 = data.frame(ID = c(\"GO:1\", \"GO:3\")), # functionally similar to Cpx1   Cpx3 = data.frame(ID = c(\"GO:4\")) )  # --- Build Network (using 2 cores for the example) --- network <- buildComplexNetwork(   complexes, enrichments, mode = \"combined\", nCores = 2 ) #> Building complex network using 'jaccard' similarity... #> Using 2 cores for parallel processing. #> Processing 3 complex pairs... #> Split into 1 chunks of up to 1000 pairs each. #> Combining results from chunks... #> Calculating final weights and filtering... #> Network construction complete: 1 edges retained. print(network) #> # A tibble: 1 × 8 #>   source_complex_id target_complex_id compSim funcSim sharedProt sharedFunc #>   <chr>             <chr>               <dbl>   <dbl>      <int>      <int> #> 1 Cpx1              Cpx2                  0.6   0.333          3          1 #> # ℹ 2 more variables: weight <dbl>, similarity_mode <chr>"},{"path":"https://zqzneptune.github.io/ComplexMap/reference/computeMapTopology.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Network Topology and Layout Coordinates — computeMapTopology","title":"Compute Network Topology and Layout Coordinates — computeMapTopology","text":"Calculates 2D layout coordinates key centrality metrics complex network. function serves final step preparing network data visualization.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/computeMapTopology.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute Network Topology and Layout Coordinates — computeMapTopology","text":"","code":"computeMapTopology(nodeAttributes, network, verbose = TRUE)"},{"path":"https://zqzneptune.github.io/ComplexMap/reference/computeMapTopology.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute Network Topology and Layout Coordinates — computeMapTopology","text":"nodeAttributes `tibble` `data.frame` containing attributes node (complex). Must contain column node identifiers matches source/target columns `network` data. network `tibble` `data.frame` representing network edges. Must contain columns source, target, edge `weight`. verbose logical value indicating whether print progress messages. Defaults `TRUE`.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/computeMapTopology.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute Network Topology and Layout Coordinates — computeMapTopology","text":"`tibble` containing original columns `nodeAttributes` plus four new columns: `x`, `y` (layout coordinates), `betweenness`, `degree`. table arranged descending order betweenness degree.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/computeMapTopology.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute Network Topology and Layout Coordinates — computeMapTopology","text":"function takes node attribute table edge list (network) performs following steps: 1.  Constructs `igraph` graph object provided data. 2.  Computes force-directed layout using Fruchterman-Reingold algorithm     via `ggraph::create_layout`. Edge weights used influence     layout, pulling strongly connected nodes closer together. 3.  Calculates node centrality metrics: - **Betweenness Centrality:** Measures often node lies       shortest path nodes (normalized). - **Degree Centrality:** number edges connected node. 4.  Merges layout coordinates centrality scores back original     node attribute table.","code":""},{"path":[]},{"path":"https://zqzneptune.github.io/ComplexMap/reference/computeMapTopology.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Compute Network Topology and Layout Coordinates — computeMapTopology","text":"Qingzhou Zhang <zqzneptune@hotmail.com>","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/computeMapTopology.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute Network Topology and Layout Coordinates — computeMapTopology","text":"","code":"# --- Sample Data --- # 1. Node attributes nodes <- tibble::tibble(   complexId = c(\"Cpx1\", \"Cpx2\", \"Cpx3\"),   proteinCount = c(10, 8, 12) )  # 2. Network edges net <- tibble::tibble(   source = c(\"Cpx1\", \"Cpx2\"),   target = c(\"Cpx2\", \"Cpx3\"),   weight = c(0.8, 0.6) )  # --- Compute Topology --- masterLayout <- computeMapTopology(nodes, net) #> Computing map topology (layout and centrality)... #> Topology computation complete. print(masterLayout) #> # A tibble: 3 × 6 #>   complexId proteinCount     x     y betweenness degree #>   <chr>            <dbl> <dbl> <dbl>       <dbl>  <dbl> #> 1 Cpx2                 8 1.43   1.92           1      2 #> 2 Cpx1                10 0.265  1.54           0      1 #> 3 Cpx3                12 2.73   2.33           0      1"},{"path":"https://zqzneptune.github.io/ComplexMap/reference/createComplexMap.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a Complete Complex Map Object — createComplexMap","title":"Create a Complete Complex Map Object — createComplexMap","text":"high-level wrapper function executes entire `ComplexMap` workflow. takes list protein complexes gene set matrix (GMT) performs refinement, enrichment, network construction, topology calculation.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/createComplexMap.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a Complete Complex Map Object — createComplexMap","text":"","code":"createComplexMap(complexList, gmt, verbose = TRUE, ...)"},{"path":"https://zqzneptune.github.io/ComplexMap/reference/createComplexMap.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a Complete Complex Map Object — createComplexMap","text":"complexList named list element character vector protein identifiers representing complex. gmt named list element character vector genes, representing functional gene set (e.g., GMT file). verbose logical value indicating whether print progress messages entire workflow. Defaults `TRUE`. ... Additional arguments passed core functions. Common arguments include: - `minSize`, `maxSize`, `mergeThreshold`, `similarityMethod` (`refineComplexList`) - `pAdjustMethod`, `pValueCutoff` (`runComplexEnrichment`) - `mode`, `similarityMethod`, `alpha` (`buildComplexNetwork`)","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/createComplexMap.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a Complete Complex Map Object — createComplexMap","text":"validated `ComplexMap` S3 object containing final node   edge tables.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/createComplexMap.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create a Complete Complex Map Object — createComplexMap","text":"function serves primary entry point analyses. internally calls core workflow following order: 1.  `refineComplexList()` 2.  `runComplexEnrichment()` 3.  `buildComplexNetwork()` 4.  `generateNodeAttributes()` 5.  `computeMapTopology()` Arguments underlying functions can passed directly wrapper via `...` parameter.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/createComplexMap.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Create a Complete Complex Map Object — createComplexMap","text":"Qingzhou Zhang <zqzneptune@hotmail.com>","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/createComplexMap.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a Complete Complex Map Object — createComplexMap","text":"","code":"# Assume 'demoComplexes' and a 'gmt' object are loaded # gmtPath <- getExampleGmt() # gmt <- getGmtFromFile(gmtPath, verbose = FALSE)  # Run the full workflow with custom parameters # complexMapObject <- createComplexMap( #   demoComplexes, #   gmt, #   verbose = TRUE, #   minSize = 5, #   mergeThreshold = 0.8, #   pValueCutoff = 0.01, #   mode = \"combined\" # ) # print(complexMapObject)"},{"path":"https://zqzneptune.github.io/ComplexMap/reference/demoComplexes.html","id":null,"dir":"Reference","previous_headings":"","what":"Example Protein Complex List — demoComplexes","title":"Example Protein Complex List — demoComplexes","text":"dataset containing list 622 putative protein complexes identified study using integrative global proteomic profiling approach. dataset intended use package examples vignettes.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/demoComplexes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Example Protein Complex List — demoComplexes","text":"","code":"demoComplexes"},{"path":"https://zqzneptune.github.io/ComplexMap/reference/demoComplexes.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Example Protein Complex List — demoComplexes","text":"named list 622 elements. element character vector protein identifiers representing single complex.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/demoComplexes.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Example Protein Complex List — demoComplexes","text":"Supplementary Table 3 (first tab) : Havugimana PC, Hart GT, Nepusz T, Yang H, Turinsky AL, Li Z, Wang PI, Boutz DR, Fong V, Phanse S, Babu M, Craig SA, Hu P, Wan C, Vlasblom J, Dar VU, Bezginov , Clark GW, Wu GC, Wodak SJ, Tillier ER, Paccanaro , Marcotte EM, Emili . *census human soluble protein complexes.* Cell. 2012 Aug 31;150(5):1068-81. doi: 10.1016/j.cell.2012.08.011. PMID: 22939629; PMCID: PMC3477804.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/demoComplexes.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Example Protein Complex List — demoComplexes","text":"complexes derived chromatographic separation cultured human cell extracts one thousand biochemical fractions, followed quantitative tandem mass spectrometry analysis. 622 complexes linked core biological processes include candidate disease genes unannotated proteins.","code":""},{"path":[]},{"path":"https://zqzneptune.github.io/ComplexMap/reference/dot-apply_color_mapping.html","id":null,"dir":"Reference","previous_headings":"","what":"Apply Color Mapping (Categorical or Continuous) — .apply_color_mapping","title":"Apply Color Mapping (Categorical or Continuous) — .apply_color_mapping","text":"Apply Color Mapping (Categorical Continuous)","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/dot-apply_color_mapping.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Apply Color Mapping (Categorical or Continuous) — .apply_color_mapping","text":"","code":".apply_color_mapping(   p,   layoutDf,   color.by,   color.palette,   color.legend.title,   geom_type = c(\"color\", \"fill\"),   unenrichedColor = \"#CCCCCC\" )"},{"path":"https://zqzneptune.github.io/ComplexMap/reference/dot-apply_theme.html","id":null,"dir":"Reference","previous_headings":"","what":"Apply Common Theme to ggraph Plot — .apply_theme","title":"Apply Common Theme to ggraph Plot — .apply_theme","text":"Apply Common Theme ggraph Plot","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/dot-apply_theme.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Apply Common Theme to ggraph Plot — .apply_theme","text":"","code":".apply_theme(   p,   bgColor,   edgeColor,   fontFamily,   nodeSizeRange,   size.legend.title,   title,   subtitle )"},{"path":"https://zqzneptune.github.io/ComplexMap/reference/dot-build_base_graph.html","id":null,"dir":"Reference","previous_headings":"","what":"Build Base Graph Structure — .build_base_graph","title":"Build Base Graph Structure — .build_base_graph","text":"Build Base Graph Structure","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/dot-build_base_graph.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Build Base Graph Structure — .build_base_graph","text":"","code":".build_base_graph(layoutDf, edgesDf, edgeColor, verbose)"},{"path":"https://zqzneptune.github.io/ComplexMap/reference/dot-calculateSimilarity.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate a Similarity Score Between Two Sets — .calculateSimilarity","title":"Calculate a Similarity Score Between Two Sets — .calculateSimilarity","text":"internal helper function computes one three common similarity metrics: Jaccard, Overlap, Dice.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/dot-calculateSimilarity.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate a Similarity Score Between Two Sets — .calculateSimilarity","text":"","code":".calculateSimilarity(set1, set2, method = \"jaccard\")"},{"path":"https://zqzneptune.github.io/ComplexMap/reference/dot-calculateSimilarity.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate a Similarity Score Between Two Sets — .calculateSimilarity","text":"set1 character vector representing first set. set2 character vector representing second set. method similarity metric use. One \"jaccard\", \"overlap\", \"dice\".","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/dot-calculateSimilarity.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate a Similarity Score Between Two Sets — .calculateSimilarity","text":"numeric similarity score 0 1. Returns 0 either   set empty intersection.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/dot-create_label_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Create Label Data for Direct Labels — .create_label_data","title":"Create Label Data for Direct Labels — .create_label_data","text":"Create Label Data Direct Labels","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/dot-create_label_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create Label Data for Direct Labels — .create_label_data","text":"","code":".create_label_data(layoutDf, centroid_threshold = 2)"},{"path":"https://zqzneptune.github.io/ComplexMap/reference/dot-create_tooltip.html","id":null,"dir":"Reference","previous_headings":"","what":"Create Tooltip HTML for visNetwork — .create_tooltip","title":"Create Tooltip HTML for visNetwork — .create_tooltip","text":"Create Tooltip HTML visNetwork","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/dot-create_tooltip.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create Tooltip HTML for visNetwork — .create_tooltip","text":"","code":".create_tooltip(   complexId,   primaryFunctionalDomain,   proteinCount,   proteins,   color.by = NULL,   color.value = NULL )"},{"path":"https://zqzneptune.github.io/ComplexMap/reference/evaluateComplexes.html","id":null,"dir":"Reference","previous_headings":"","what":"Evaluate Predicted Protein Complexes Against a Reference Set — evaluateComplexes","title":"Evaluate Predicted Protein Complexes Against a Reference Set — evaluateComplexes","text":"Calculates four standard metrics evaluating protein complex predictions: Positive Predictive Value (PPV), Sensitivity (Sn), Accuracy (Acc), Maximum Matching Ratio (MMR).","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/evaluateComplexes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Evaluate Predicted Protein Complexes Against a Reference Set — evaluateComplexes","text":"","code":"evaluateComplexes(   predictedComplexes,   referenceComplexes,   nCores = NULL,   verbose = TRUE )"},{"path":"https://zqzneptune.github.io/ComplexMap/reference/evaluateComplexes.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Evaluate Predicted Protein Complexes Against a Reference Set — evaluateComplexes","text":"predictedComplexes list predicted protein complexes. referenceComplexes list reference (gold standard) complexes. nCores number CPU cores use parallel computation. Defaults one less total number detected cores. verbose logical value indicating whether print progress messages. Defaults `TRUE`.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/evaluateComplexes.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Evaluate Predicted Protein Complexes Against a Reference Set — evaluateComplexes","text":"named list containing four numeric values: `PPV`, `Sn`, `Acc`, `MMR`. Returns `NA` metrics either input list empty.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/evaluateComplexes.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Evaluate Predicted Protein Complexes Against a Reference Set — evaluateComplexes","text":"function optimized speed calculating shared intersection matrix predicted reference complexes parallel. matrix used basis four metric calculations. - **PPV, Sn, Acc** calculated based confusion matrix   predicted reference complexes, described literature (e.g.,   Zhang et al., 2012). - **MMR** calculated first deriving overlap score matrix,   score predicted complex (P) reference complex (R)   `|P ∩ R|² / (|P| * |R|)`.   [Hungarian algorithm](https://en.wikipedia.org/wiki/Hungarian_algorithm)   used solve maximum weight bipartite matching problem.   approach based method described Nepusz et al. (2012). parallel computation uses `parallel::mclapply`, available Windows. Windows, calculation run sequentially.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/evaluateComplexes.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Evaluate Predicted Protein Complexes Against a Reference Set — evaluateComplexes","text":"Nepusz, T., Yu, H. & Paccanaro, . (2012). Detecting overlapping protein complexes protein-protein interaction networks. *Nature Methods*, 9, 471–472. doi:10.1038/nmeth.1938 Zhang XF, Dai DQ, Ou-Yang L, Wu (2012). Exploring Overlapping Functional Units Various Structure Protein Interaction Networks. *PLOS ONE*, 7(8): e43092. doi:10.1371/journal.pone.0043092","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/evaluateComplexes.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Evaluate Predicted Protein Complexes Against a Reference Set — evaluateComplexes","text":"Qingzhou Zhang <zqzneptune@hotmail.com>","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/evaluateComplexes.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Evaluate Predicted Protein Complexes Against a Reference Set — evaluateComplexes","text":"","code":"# --- Sample Data --- # Predicted complexes pred1 <- c(\"A\", \"B\", \"C\") pred2 <- c(\"D\", \"E\", \"F\") pred3 <- c(\"A\", \"G\", \"H\") predicted <- list(P1 = pred1, P2 = pred2, P3 = pred3)  # Reference complexes (gold standard) ref1 <- c(\"A\", \"B\", \"C\", \"X\") # Good match for pred1 ref2 <- c(\"D\", \"E\", \"F\")     # Perfect match for pred2 ref3 <- c(\"I\", \"J\", \"K\")     # Unmatched complex reference <- list(R1 = ref1, R2 = ref2, R3 = ref3)  # --- Evaluation --- # Use 2 cores for the example metrics <- evaluateComplexes(predicted, reference, nCores = 2) #>  #> --- Evaluating Complex Predictions --- #> [1] Calculating intersections using 2 core(s)... #> [2] Calculating PPV, Sensitivity, and Accuracy... #> [3] Calculating Maximum Matching Ratio (MMR)... #>  #> --- Evaluation Complete --- print(metrics) #> $PPV #> [1] 1 #>  #> $Sn #> [1] 0.6 #>  #> $Acc #> [1] 0.7745967 #>  #> $MMR #> [1] 0.5833333 #>"},{"path":"https://zqzneptune.github.io/ComplexMap/reference/exportNetwork.html","id":null,"dir":"Reference","previous_headings":"","what":"Export a ComplexMap Network for External Tools — exportNetwork","title":"Export a ComplexMap Network for External Tools — exportNetwork","text":"function exports node edge tables `ComplexMap` object format suitable widely used network visualization software, Cytoscape.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/exportNetwork.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Export a ComplexMap Network for External Tools — exportNetwork","text":"","code":"exportNetwork(   complexMapObject,   filePrefix,   format = \"cytoscape\",   verbose = TRUE )"},{"path":"https://zqzneptune.github.io/ComplexMap/reference/exportNetwork.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Export a ComplexMap Network for External Tools — exportNetwork","text":"complexMapObject `ComplexMap` object returned `createComplexMap()`. filePrefix character string used prefix output filenames. example, `filePrefix` \"my_map\" result \"my_map_nodes.tsv\" \"my_map_edges.tsv\". format character string specifying output format. Currently, `\"cytoscape\"` supported. verbose logical value indicating whether print confirmation message upon successful export.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/exportNetwork.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Export a ComplexMap Network for External Tools — exportNetwork","text":"function called side effect writing files disk.   return value.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/exportNetwork.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Export a ComplexMap Network for External Tools — exportNetwork","text":"function currently supports one format: - `\"cytoscape\"`: option generates two separate tab-separated value   (.tsv) files. One file contains node attributes (`<filePrefix>_nodes.tsv`)   contains edge list attributes   (`<filePrefix>_edges.tsv`). files can directly imported   Cytoscape's network attribute tables. function uses `utils::write.table` robust standard-compliant file writing.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/exportNetwork.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Export a ComplexMap Network for External Tools — exportNetwork","text":"Qingzhou Zhang <zqzneptune@hotmail.com>","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/exportNetwork.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Export a ComplexMap Network for External Tools — exportNetwork","text":"","code":"# Assume 'cm_obj' is a valid ComplexMap object # dir <- tempdir() # Use a temporary directory for the example # exportNetwork(cm_obj, filePrefix = file.path(dir, \"myNetwork\"))"},{"path":"https://zqzneptune.github.io/ComplexMap/reference/generateNodeAttributes.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate Node Attributes for a Complex Network — generateNodeAttributes","title":"Generate Node Attributes for a Complex Network — generateNodeAttributes","text":"Creates detailed attribute table complex, suitable network visualization. Attributes include protein count, primary functional domain, top enriched functions, unique color representing complex's functional profile.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/generateNodeAttributes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate Node Attributes for a Complex Network — generateNodeAttributes","text":"","code":"generateNodeAttributes(   complexes,   enrichments,   geneSetDb = NULL,   similarityMethod = \"overlap\",   verbose = TRUE )"},{"path":"https://zqzneptune.github.io/ComplexMap/reference/generateNodeAttributes.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate Node Attributes for a Complex Network — generateNodeAttributes","text":"complexes named list protein complexes. enrichments named list enrichment results, typically `runComplexEnrichment`. geneSetDb Optional named list names term IDs values character vectors genes. provided, term similarity calculated based gene set overlap instead co-occurrence. results biologically meaningful color groupings. similarityMethod distance/similarity method. gene set overlap: \"overlap\" (default), \"jaccard\", \"cosine\". co-occurrence: method supported `philentropy::distance`. Defaults \"overlap\". verbose logical value indicating whether print progress messages.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/generateNodeAttributes.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate Node Attributes for a Complex Network — generateNodeAttributes","text":"`tibble` row corresponds complex, detailed attributes visualization.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/generateNodeAttributes.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate Node Attributes for a Complex Network — generateNodeAttributes","text":"function performs several steps generate rich node attributes: 1.  aggregates enriched terms input `enrichments` list. 2.  term-complex matrix built, terms clustered based     co-occurrence complexes gene set overlap (provided). 3.  unique color assigned functional domain using qualitative     palette. 4.  complex, determines primary functional domain based     significant enriched term. 5.  unique \"blended\" color calculated complex mixing     colors associated domains, weighted significance. 6.  Basic attributes like protein count list proteins also included. Complexes significant enrichments assigned default \"Unenriched\" domain grey color.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/generateNodeAttributes.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Generate Node Attributes for a Complex Network — generateNodeAttributes","text":"Qingzhou Zhang <zqzneptune@hotmail.com>","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/generateNodeAttributes.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate Node Attributes for a Complex Network — generateNodeAttributes","text":"","code":"# --- Sample Data --- complexes <- list(   Cpx1 = c(\"A\", \"B\", \"C\"),   Cpx2 = c(\"C\", \"D\", \"E\"),   Cpx3 = c(\"F\", \"G\") ) enrichments <- list(   Cpx1 = data.frame(ID = \"GO:1\", Description = \"Term A\", p.adjust = 0.01),   Cpx2 = data.frame(ID = \"GO:2\", Description = \"Term B\", p.adjust = 0.02) )  # --- Without gene sets (co-occurrence) --- nodeAttrs <- generateNodeAttributes(complexes, enrichments) #> Generating core node attributes (function and color)... #>     -> Clustering 2 terms using co-occurrence (overlap) #>     -> Identified 2 functional domains  # --- With gene sets (better functional grouping) --- geneSets <- list(   \"GO:1\" = c(\"A\", \"B\", \"X\"),   \"GO:2\" = c(\"A\", \"B\", \"Y\"),  # High overlap with GO:1 -> similar color   \"GO:3\" = c(\"M\", \"N\", \"O\")   # No overlap -> different color ) nodeAttrs <- generateNodeAttributes(complexes, enrichments,                                     geneSetDb = geneSets) #> Generating core node attributes (function and color)... #>     -> Clustering 2 terms using gene set overlap (overlap) #>     -> Identified 2 functional domains"},{"path":"https://zqzneptune.github.io/ComplexMap/reference/getEdgeTable.html","id":null,"dir":"Reference","previous_headings":"","what":"Get the Edge Table from a ComplexMap Object — getEdgeTable","title":"Get the Edge Table from a ComplexMap Object — getEdgeTable","text":"simple accessor function extract tibble network edges `ComplexMap` object.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/getEdgeTable.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get the Edge Table from a ComplexMap Object — getEdgeTable","text":"","code":"getEdgeTable(cm)"},{"path":"https://zqzneptune.github.io/ComplexMap/reference/getEdgeTable.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get the Edge Table from a ComplexMap Object — getEdgeTable","text":"cm `ComplexMap` object, typically output `createComplexMap()`.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/getEdgeTable.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get the Edge Table from a ComplexMap Object — getEdgeTable","text":"`tibble` containing edge data.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/getEdgeTable.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get the Edge Table from a ComplexMap Object — getEdgeTable","text":"","code":"# Assuming 'myComplexMap' is a valid ComplexMap object # edgeData <- getEdgeTable(myComplexMap)"},{"path":"https://zqzneptune.github.io/ComplexMap/reference/getExampleGmt.html","id":null,"dir":"Reference","previous_headings":"","what":"Get the Path to an Example GMT File — getExampleGmt","title":"Get the Path to an Example GMT File — getExampleGmt","text":"Provides full system path example gene set (GMT) file included ComplexMap package.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/getExampleGmt.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get the Path to an Example GMT File — getExampleGmt","text":"","code":"getExampleGmt()"},{"path":"https://zqzneptune.github.io/ComplexMap/reference/getExampleGmt.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get the Path to an Example GMT File — getExampleGmt","text":"character string containing full path example GMT file.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/getExampleGmt.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Get the Path to an Example GMT File — getExampleGmt","text":"included file BioCarta gene set collection Molecular Signatures Database (MSigDB v2025.1). function makes easy access file use examples vignettes.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/getExampleGmt.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get the Path to an Example GMT File — getExampleGmt","text":"","code":"# Get the path gmtPath <- getExampleGmt()  # You can then read the file using the path if (file.exists(gmtPath)) {   exampleGmt <- getGmtFromFile(gmtPath) } #> Fetching gene sets from local file: /tmp/RtmpxmbeGW/temp_libpath1df80553f4968/ComplexMap/extdata/c2.cp.biocarta.v2025.1.Hs.symbols.gmt"},{"path":"https://zqzneptune.github.io/ComplexMap/reference/getGmtFromFile.html","id":null,"dir":"Reference","previous_headings":"","what":"Read a GMT File from a Local Path — getGmtFromFile","title":"Read a GMT File from a Local Path — getGmtFromFile","text":"Parses local GMT (Gene Matrix Transposed) file standard named-list format.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/getGmtFromFile.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Read a GMT File from a Local Path — getGmtFromFile","text":"","code":"getGmtFromFile(filepath, verbose = TRUE)"},{"path":"https://zqzneptune.github.io/ComplexMap/reference/getGmtFromFile.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Read a GMT File from a Local Path — getGmtFromFile","text":"filepath path local .gmt file. verbose logical value indicating whether print progress messages.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/getGmtFromFile.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Read a GMT File from a Local Path — getGmtFromFile","text":"named list names gene set names values character   vectors genes.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/getGoGmt.html","id":null,"dir":"Reference","previous_headings":"","what":"Fetch Gene Ontology (GO) Gene Sets — getGoGmt","title":"Fetch Gene Ontology (GO) Gene Sets — getGoGmt","text":"Fetches GO terms associated genes Bioconductor AnnotationDb package.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/getGoGmt.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fetch Gene Ontology (GO) Gene Sets — getGoGmt","text":"","code":"getGoGmt(   speciesDb,   ontology = \"BP\",   minGmtSize = 10,   maxGmtSize = 500,   verbose = TRUE )"},{"path":"https://zqzneptune.github.io/ComplexMap/reference/getGoGmt.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fetch Gene Ontology (GO) Gene Sets — getGoGmt","text":"speciesDb AnnotationDb object target species (e.g., `org.Hs.eg.db`). ontology GO ontology fetch. One \"BP\", \"MF\", \"CC\". minGmtSize minimum number genes GO term included. maxGmtSize maximum number genes GO term included. verbose logical value indicating whether print progress messages.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/getGoGmt.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fetch Gene Ontology (GO) Gene Sets — getGoGmt","text":"named list names GO terms values character   vectors Entrez IDs.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/getMsigdbGmt.html","id":null,"dir":"Reference","previous_headings":"","what":"Fetch Gene Sets from MSigDB — getMsigdbGmt","title":"Fetch Gene Sets from MSigDB — getMsigdbGmt","text":"wrapper `msigdbr::msigdbr` fetch gene sets format named list (GMT format).","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/getMsigdbGmt.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fetch Gene Sets from MSigDB — getMsigdbGmt","text":"","code":"getMsigdbGmt(species = \"Homo sapiens\", collection = \"H\", verbose = TRUE)"},{"path":"https://zqzneptune.github.io/ComplexMap/reference/getMsigdbGmt.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fetch Gene Sets from MSigDB — getMsigdbGmt","text":"species scientific name species (e.g., \"Homo sapiens\"). collection MSigDB collection code (e.g., \"H\" hallmark). verbose logical value indicating whether print progress messages.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/getMsigdbGmt.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fetch Gene Sets from MSigDB — getMsigdbGmt","text":"named list names gene set names values character   vectors gene symbols.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/getNodeTable.html","id":null,"dir":"Reference","previous_headings":"","what":"Get the Node Table from a ComplexMap Object — getNodeTable","title":"Get the Node Table from a ComplexMap Object — getNodeTable","text":"simple accessor function extract tibble node attributes layout data `ComplexMap` object.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/getNodeTable.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get the Node Table from a ComplexMap Object — getNodeTable","text":"","code":"getNodeTable(cm)"},{"path":"https://zqzneptune.github.io/ComplexMap/reference/getNodeTable.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get the Node Table from a ComplexMap Object — getNodeTable","text":"cm `ComplexMap` object, typically output `createComplexMap()`.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/getNodeTable.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get the Node Table from a ComplexMap Object — getNodeTable","text":"`tibble` containing node data.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/getNodeTable.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get the Node Table from a ComplexMap Object — getNodeTable","text":"","code":"# Assuming 'myComplexMap' is a valid ComplexMap object # nodeData <- getNodeTable(myComplexMap)"},{"path":"https://zqzneptune.github.io/ComplexMap/reference/getReactomeGmt.html","id":null,"dir":"Reference","previous_headings":"","what":"Fetch Reactome Pathway Gene Sets — getReactomeGmt","title":"Fetch Reactome Pathway Gene Sets — getReactomeGmt","text":"Fetches Reactome pathways associated genes `reactome.db` Bioconductor annotation package.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/getReactomeGmt.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fetch Reactome Pathway Gene Sets — getReactomeGmt","text":"","code":"getReactomeGmt(speciesDb, verbose = TRUE)"},{"path":"https://zqzneptune.github.io/ComplexMap/reference/getReactomeGmt.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fetch Reactome Pathway Gene Sets — getReactomeGmt","text":"speciesDb AnnotationDb object target species (e.g., `org.Hs.eg.db`). used filter pathways correct species. verbose logical value indicating whether print progress messages.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/getReactomeGmt.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fetch Reactome Pathway Gene Sets — getReactomeGmt","text":"named list names Reactome pathway names values   character vectors Entrez IDs.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/pipe.html","id":null,"dir":"Reference","previous_headings":"","what":"Pipe operator — %>%","title":"Pipe operator — %>%","text":"See magrittr::%>% details.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/pipe.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pipe operator — %>%","text":"","code":"lhs %>% rhs"},{"path":"https://zqzneptune.github.io/ComplexMap/reference/print.ComplexMap.html","id":null,"dir":"Reference","previous_headings":"","what":"Print Method for a ComplexMap Object — print.ComplexMap","title":"Print Method for a ComplexMap Object — print.ComplexMap","text":"Provides user-friendly summary `ComplexMap` object printed console. method automatically called `print` generic function.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/print.ComplexMap.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print Method for a ComplexMap Object — print.ComplexMap","text":"","code":"# S3 method for class 'ComplexMap' print(x, ...)"},{"path":"https://zqzneptune.github.io/ComplexMap/reference/print.ComplexMap.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print Method for a ComplexMap Object — print.ComplexMap","text":"x `ComplexMap` object. ... Additional arguments passed `print` (used method).","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/print.ComplexMap.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print Method for a ComplexMap Object — print.ComplexMap","text":"Invisibly returns original `ComplexMap` object, allowing   use pipelines.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/qcComplexList.html","id":null,"dir":"Reference","previous_headings":"","what":"Perform Quality Control on a List of Protein Complexes — qcComplexList","title":"Perform Quality Control on a List of Protein Complexes — qcComplexList","text":"function performs quality control analysis list protein complexes, delivering user-friendly report key statistics actionable warnings.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/qcComplexList.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Perform Quality Control on a List of Protein Complexes — qcComplexList","text":"","code":"qcComplexList(complexList, redundancyThreshold = 0.8, verbose = TRUE)"},{"path":"https://zqzneptune.github.io/ComplexMap/reference/qcComplexList.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Perform Quality Control on a List of Protein Complexes — qcComplexList","text":"complexList list element character vector protein identifiers representing complex. redundancyThreshold numeric value 0 1. warning issued pair complexes Jaccard similarity score greater equal threshold. Defaults 0.8. verbose logical value indicating whether print QC report console. Defaults `TRUE`.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/qcComplexList.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Perform Quality Control on a List of Protein Complexes — qcComplexList","text":"Invisibly returns original `complexList` object, allowing used pipeline.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/qcComplexList.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Perform Quality Control on a List of Protein Complexes — qcComplexList","text":"QC process involves three main steps, presented clear report: 1.  **Basic Statistics:** Reports total number complexes unique     proteins. 2.  **Size Distribution:** Summarizes number proteins per complex,     highlighting smallest, median, largest complexes.     issue -report warning complexes fewer 3 members. 3.  **Redundancy Analysis:** Calculates Jaccard similarity pairs     complexes. reports median maximum similarity issues     -report warning pairs exceed `redundancyThreshold`. function intended **diagnostic tool**. uses Jaccard index clear intuitive interpretation redundancy. actively merging complexes, see advanced `refineComplexList()` function.","code":""},{"path":[]},{"path":"https://zqzneptune.github.io/ComplexMap/reference/qcComplexList.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Perform Quality Control on a List of Protein Complexes — qcComplexList","text":"Qingzhou Zhang <zqzneptune@hotmail.com>","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/qcComplexList.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Perform Quality Control on a List of Protein Complexes — qcComplexList","text":"","code":"# Create a sample list of protein complexes complex1 <- c(\"A\", \"B\", \"C\", \"D\") complex2 <- c(\"A\", \"B\", \"C\", \"E\") # Highly redundant with complex1 complex3 <- c(\"F\", \"G\", \"H\") complex4 <- c(\"I\", \"J\")          # Small complex sampleList <- list(   C1 = complex1, C2 = complex2, C3 = complex3, C4 = complex4 )  # Run the quality control analysis to see the new report format qcComplexList(sampleList) #>  #> --- Quality Control Report for Complex List --- #>  #> [1] Basic Statistics #>   ✓ Total Complexes: 4 #>   ✓ Unique Proteins: 10 #>  #> [2] Complex Size Distribution #>   - Smallest Complex: 2 proteins #>   - Median Complex:   4 proteins #>   - Largest Complex:  4 proteins #>   ! WARNING: Found 1 complex(es) with fewer than 3 members. #>     -> These are often considered too small for robust analysis. #>  #> [3] Redundancy Analysis (Jaccard Index) #>   - Median Similarity: 0.000 #>   - Max Similarity:    0.600 #>   ✓ No highly redundant pairs detected (>= 0.80). #>  #> --- QC Complete ---"},{"path":"https://zqzneptune.github.io/ComplexMap/reference/queryMap.html","id":null,"dir":"Reference","previous_headings":"","what":"Query a ComplexMap Object for Specific Information — queryMap","title":"Query a ComplexMap Object for Specific Information — queryMap","text":"Allows targeted querying `ComplexMap` object find nodes (complexes) match specific criteria, containing particular protein belonging biological theme.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/queryMap.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Query a ComplexMap Object for Specific Information — queryMap","text":"","code":"queryMap(complexMapObject, query, type)"},{"path":"https://zqzneptune.github.io/ComplexMap/reference/queryMap.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Query a ComplexMap Object for Specific Information — queryMap","text":"complexMapObject `ComplexMap` object. query character string containing search term. type character string: one `\"protein\"`, `\"complex\"`, `\"theme\"`.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/queryMap.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Query a ComplexMap Object for Specific Information — queryMap","text":"`tibble` containing rows node table match   query. Returns empty tibble matches found.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/queryMap.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Query a ComplexMap Object for Specific Information — queryMap","text":"function supports three distinct modes querying: - `type = \"protein\"`: Searches complexes containing specific protein. - `type = \"complex\"`: Retrieves specific complex ID. - `type = \"theme\"`: Finds complexes belonging given theme.   requires theme information added `ComplexMap` object first   (see \"Advanced Analysis\" vignette example).","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/queryMap.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Query a ComplexMap Object for Specific Information — queryMap","text":"Qingzhou Zhang <zqzneptune@hotmail.com>","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/queryMap.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Query a ComplexMap Object for Specific Information — queryMap","text":"","code":"# Assume 'cm_obj' is a valid ComplexMap object # uba1_complexes <- queryMap(cm_obj, query = \"UBA1\", type = \"protein\")"},{"path":"https://zqzneptune.github.io/ComplexMap/reference/referenceComplexes.html","id":null,"dir":"Reference","previous_headings":"","what":"Reference Protein Complex Set (CORUM) — referenceComplexes","title":"Reference Protein Complex Set (CORUM) — referenceComplexes","text":"reference dataset containing 324 merged CORUM protein complexes used training protein-protein interaction scoring clustering optimization procedures study.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/referenceComplexes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Reference Protein Complex Set (CORUM) — referenceComplexes","text":"","code":"referenceComplexes"},{"path":"https://zqzneptune.github.io/ComplexMap/reference/referenceComplexes.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Reference Protein Complex Set (CORUM) — referenceComplexes","text":"named list 324 elements. element character vector protein identifiers.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/referenceComplexes.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Reference Protein Complex Set (CORUM) — referenceComplexes","text":"Supplementary Table 3 (second tab) : Havugimana PC, Hart GT, Nepusz T, Yang H, Turinsky AL, Li Z, Wang PI, Boutz DR, Fong V, Phanse S, Babu M, Craig SA, Hu P, Wan C, Vlasblom J, Dar VU, Bezginov , Clark GW, Wu GC, Wodak SJ, Tillier ER, Paccanaro , Marcotte EM, Emili . *census human soluble protein complexes.* Cell. 2012 Aug 31;150(5):1068-81. doi: 10.1016/j.cell.2012.08.011. PMID: 22939629; PMCID: PMC3477804.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/referenceComplexes.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Reference Protein Complex Set (CORUM) — referenceComplexes","text":"complexes curated CORUM database merged reduce redundancy benchmarking purposes.","code":""},{"path":[]},{"path":"https://zqzneptune.github.io/ComplexMap/reference/refineComplexList.html","id":null,"dir":"Reference","previous_headings":"","what":"Refine a List of Protein Complexes by Size and Redundancy — refineComplexList","title":"Refine a List of Protein Complexes by Size and Redundancy — refineComplexList","text":"function refines list protein complexes first filtering based size merging highly redundant complexes based similarity threshold.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/refineComplexList.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Refine a List of Protein Complexes by Size and Redundancy — refineComplexList","text":"","code":"refineComplexList(   complexList,   minSize = 3,   maxSize = 500,   mergeThreshold = 0.9,   similarityMethod = \"matching_score\",   verbose = TRUE )"},{"path":"https://zqzneptune.github.io/ComplexMap/reference/refineComplexList.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Refine a List of Protein Complexes by Size and Redundancy — refineComplexList","text":"complexList named list element character vector protein identifiers representing complex. minSize integer specifying minimum number proteins complex must retained. Defaults 3. maxSize integer specifying maximum number proteins complex can retained. Defaults 500. mergeThreshold numeric value (0-1). Complexes similarity score >= value merged. Defaults 0.9. similarityMethod character string specifying similarity metric merging. Defaults `\"matching_score\"`. available options : `\"matching_score\"` `Intersection² / (|| * |B|)`. Rewards large,     shared cores. Aligns MMR evaluation metric. `\"simpson\"` `Intersection / min(||, |B|)`. Also known     Overlap coefficient. excels merging sub-complexes larger parents. `\"jaccard\"` `Intersection / Union`. classic, balanced metric     penalizes size differences. `\"dice\"` `2 * Intersection / (|| + |B|)`. Similar Jaccard     generally less stringent. verbose logical value indicating whether print progress messages. Defaults `TRUE`.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/refineComplexList.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Refine a List of Protein Complexes by Size and Redundancy — refineComplexList","text":"list containing two named elements: `refinedComplexes` final, renamed list merged complexes. `mergeMap` `tibble` columns `originalId` `finalId`,   mapping original complex final standardized ID.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/refineComplexList.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Refine a List of Protein Complexes by Size and Redundancy — refineComplexList","text":"refinement process consists two main stages: 1.  **Size Filtering:** Complexes smaller `minSize` larger     `maxSize` removed. 2.  **Redundancy Merging:** similarity matrix calculated     remaining complex pairs using chosen `similarityMethod`.     union-find algorithm identifies clusters complexes connected     similarity score >= `mergeThreshold`, merged. Finally, complexes refined list renamed standardized format (\"CpxMap_0001\", etc.), traceability map generated.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/refineComplexList.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Refine a List of Protein Complexes by Size and Redundancy — refineComplexList","text":"Qingzhou Zhang <zqzneptune@hotmail.com>","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/refineComplexList.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Refine a List of Protein Complexes by Size and Redundancy — refineComplexList","text":"","code":"# Create a sample list of protein complexes c1 <- c(\"A\", \"B\", \"C\", \"D\", \"E\") c2 <- c(\"A\", \"B\", \"C\", \"D\", \"F\") # High similarity with c1 c3 <- c(\"A\", \"B\", \"C\")          # Subset of c1 and c2 c4 <- c(\"X\", \"Y\", \"Z\") sampleList <- list(C1=c1, C2=c2, C3=c3, C4=c4)  # Refine using the default \"matching_score\" refineComplexList(sampleList, mergeThreshold = 0.6) #>  #> --- Refining Input Complex List --- #> Filtered 0 complexes by size. Retaining 4. #> Identifying merge groups with matching_score >= 0.60... #> Found 1 merge groups. Merging 2 complexes into 2. #> Merging complete. Final list has 2 complexes. #>  #> --- Refinement Complete --- #> $refinedComplexes #> $refinedComplexes$CpxMap_0001 #> [1] \"A\" \"B\" \"C\" \"D\" \"E\" \"F\" #>  #> $refinedComplexes$CpxMap_0002 #> [1] \"X\" \"Y\" \"Z\" #>  #>  #> $mergeMap #> # A tibble: 4 × 2 #>   originalId finalId     #>   <chr>      <chr>       #> 1 C1         CpxMap_0001 #> 2 C2         CpxMap_0001 #> 3 C3         CpxMap_0001 #> 4 C4         CpxMap_0002 #>   # Refine using the \"simpson\" method to merge the subset refineComplexList(sampleList, mergeThreshold = 0.9, similarityMethod = \"simpson\") #>  #> --- Refining Input Complex List --- #> Filtered 0 complexes by size. Retaining 4. #> Identifying merge groups with simpson >= 0.90... #> Found 1 merge groups. Merging 2 complexes into 2. #> Merging complete. Final list has 2 complexes. #>  #> --- Refinement Complete --- #> $refinedComplexes #> $refinedComplexes$CpxMap_0001 #> [1] \"A\" \"B\" \"C\" \"D\" \"E\" \"F\" #>  #> $refinedComplexes$CpxMap_0002 #> [1] \"X\" \"Y\" \"Z\" #>  #>  #> $mergeMap #> # A tibble: 4 × 2 #>   originalId finalId     #>   <chr>      <chr>       #> 1 C1         CpxMap_0001 #> 2 C2         CpxMap_0001 #> 3 C3         CpxMap_0001 #> 4 C4         CpxMap_0002 #>"},{"path":"https://zqzneptune.github.io/ComplexMap/reference/runComplexEnrichment.html","id":null,"dir":"Reference","previous_headings":"","what":"Run Gene Set Enrichment Analysis on a List of Complexes — runComplexEnrichment","title":"Run Gene Set Enrichment Analysis on a List of Complexes — runComplexEnrichment","text":"function performs hypergeometric-based enrichment analysis protein complex list provided gene set matrix (GMT).","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/runComplexEnrichment.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Run Gene Set Enrichment Analysis on a List of Complexes — runComplexEnrichment","text":"","code":"runComplexEnrichment(   complexList,   gmt,   pAdjustMethod = \"Benjamini\",   pValueCutoff = 0.05,   verbose = TRUE )"},{"path":"https://zqzneptune.github.io/ComplexMap/reference/runComplexEnrichment.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Run Gene Set Enrichment Analysis on a List of Complexes — runComplexEnrichment","text":"complexList named list element character vector gene/protein identifiers representing complex. gmt named list element character vector genes, representing functional gene set (e.g., GMT file). pAdjustMethod character string specifying p-value adjustment method use filtering. Must one \"Benjamini\", \"Bonferroni\", \"FDR\". Defaults \"Benjamini\". pValueCutoff numeric value used cutoff significance adjusted p-value. Defaults 0.05. verbose logical value indicating whether print progress messages. Defaults `TRUE`.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/runComplexEnrichment.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Run Gene Set Enrichment Analysis on a List of Complexes — runComplexEnrichment","text":"named list name corresponds `complexId` input. element data frame containing significant enrichment results complex, columns: `ID`, `Description`, `p.adjust`, `Count`, `Ratio`, `Fold`.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/runComplexEnrichment.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Run Gene Set Enrichment Analysis on a List of Complexes — runComplexEnrichment","text":"complex, function calculates -representation functional terms (e.g., GO terms, pathways) GMT file. uses hypergeometric test compute p-value, adjusted multiple testing. terms significant filtering `pValueCutoff` retained final output.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/runComplexEnrichment.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Run Gene Set Enrichment Analysis on a List of Complexes — runComplexEnrichment","text":"Qingzhou Zhang <zqzneptune@hotmail.com>","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/runComplexEnrichment.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Run Gene Set Enrichment Analysis on a List of Complexes — runComplexEnrichment","text":"","code":"# --- Sample Data --- # 1. Complexes to be tested complex1 <- c(\"A\", \"B\", \"C\", \"D\") complex2 <- c(\"F\", \"G\", \"H\") myComplexes <- list(Cpx1 = complex1, Cpx2 = complex2)  # 2. Gene Set Matrix (e.g., GO terms or pathways) term1 <- c(\"A\", \"B\", \"C\", \"X\", \"Y\") # Enriched in Cpx1 term2 <- c(\"F\", \"G\", \"Z\")          # Enriched in Cpx2 term3 <- c(\"L\", \"M\", \"N\")          # Not enriched myGmt <- list(Term1 = term1, Term2 = term2, Term3 = term3)  # --- Run Enrichment --- enrichment <- runComplexEnrichment(myComplexes, myGmt) #> Running enrichment for 2 complexes... #> Annotation complete. Found terms for 0 complexes. print(enrichment) #> list()"},{"path":"https://zqzneptune.github.io/ComplexMap/reference/summarizeThemes.html","id":null,"dir":"Reference","previous_headings":"","what":"Summarize Major Biological Themes in a Complex Map — summarizeThemes","title":"Summarize Major Biological Themes in a Complex Map — summarizeThemes","text":"function analyzes network structure within `ComplexMap` object identify summarize major biological themes. uses community detection algorithms find densely connected clusters nodes (themes).","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/summarizeThemes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Summarize Major Biological Themes in a Complex Map — summarizeThemes","text":"","code":"summarizeThemes(complexMapObject, method = \"louvain\", verbose = TRUE)"},{"path":"https://zqzneptune.github.io/ComplexMap/reference/summarizeThemes.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Summarize Major Biological Themes in a Complex Map — summarizeThemes","text":"complexMapObject `ComplexMap` object returned `createComplexMap()`. method character string specifying community detection algorithm use. Must valid `igraph` clustering function (e.g., \"louvain\", \"walktrap\", \"infomap\"). Defaults \"louvain\". verbose logical value indicating whether print progress messages.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/summarizeThemes.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Summarize Major Biological Themes in a Complex Map — summarizeThemes","text":"`tibble` row represents summarized theme, containing   `themeId`, `themeLabel`, `nodeCount`, `edgeCount`.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/summarizeThemes.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Summarize Major Biological Themes in a Complex Map — summarizeThemes","text":"function performs following steps: 1.  constructs `igraph` graph object node edge tables. 2.  applies community detection algorithm (e.g., Louvain, default)     partition network clusters \"themes\". 3.  theme, generates descriptive `themeLabel` finding     frequently occurring `primaryFunctionalDomain` among member     nodes (excluding \"Unenriched\"). 4.  calculates summary statistics theme, including node edge counts.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/summarizeThemes.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Summarize Major Biological Themes in a Complex Map — summarizeThemes","text":"Qingzhou Zhang <zqzneptune@hotmail.com>","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/summarizeThemes.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Summarize Major Biological Themes in a Complex Map — summarizeThemes","text":"","code":"# Assume 'cm_obj' is a valid ComplexMap object created by createComplexMap() # if (requireNamespace(\"igraph\", quietly = TRUE)) { #   themeSummary <- summarizeThemes(cm_obj) #   print(themeSummary) # }"},{"path":"https://zqzneptune.github.io/ComplexMap/reference/visualizeMapDirectLabels.html","id":null,"dir":"Reference","previous_headings":"","what":"Visualize a Complex Map with Direct Node Labels — visualizeMapDirectLabels","title":"Visualize a Complex Map with Direct Node Labels — visualizeMapDirectLabels","text":"Creates static visualization complex network using `ggraph`, functional domain labels placed directly plot near nodes.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/visualizeMapDirectLabels.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Visualize a Complex Map with Direct Node Labels — visualizeMapDirectLabels","text":"","code":"visualizeMapDirectLabels(   layoutDf,   edgesDf,   title = \"ComplexMap Functional Landscape\",   subtitle = \"Nodes are protein complexes, colored by function\",   bgColor = \"black\",   edgeColor = \"white\",   nodeSizeRange = c(2, 10),   labelFillColor = ggplot2::alpha(\"white\", 0.7),   fontFamily = \"sans\",   size.legend.title = \"Complex Size (log2)\",   color.by = NULL,   color.palette = \"viridis\",   color.legend.title = NULL,   centroid_threshold = 2,   label_wrap_width = 20,   verbose = TRUE )"},{"path":"https://zqzneptune.github.io/ComplexMap/reference/visualizeMapDirectLabels.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Visualize a Complex Map with Direct Node Labels — visualizeMapDirectLabels","text":"layoutDf data frame containing node attributes layout coordinates, typically `computeMapTopology`. edgesDf data frame containing network edges. title main title plot. subtitle subtitle plot. bgColor background color plot. edgeColor color network edges. nodeSizeRange numeric vector length 2 specifying min max node size. labelFillColor background fill color labels. fontFamily base font family plot text. size.legend.title title node size legend. color.character string specifying name numeric column `layoutDf` use continuous node coloring. `NULL` (default), categorical `colorHex` column used. color.palette character string vector colors continuous gradient (e.g., \"viridis\", \"plasma\", `c(\"blue\", \"white\", \"red\")`). used `color.` specified. color.legend.title character string title continuous color legend. Defaults value `color.`. centroid_threshold Integer. Domains many complexes use centroid labels. Defaults 2. label_wrap_width Integer. Maximum width label text wrapping. Defaults 20. verbose logical value indicating whether print progress messages.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/visualizeMapDirectLabels.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Visualize a Complex Map with Direct Node Labels — visualizeMapDirectLabels","text":"`ggplot` object representing network visualization.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/visualizeMapDirectLabels.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Visualize a Complex Map with Direct Node Labels — visualizeMapDirectLabels","text":"function supports two coloring modes: 1.  **Categorical (default):** `color.= NULL`, nodes colored     using `colorHex` column, typically represents functional domains.     color legend drawn. 2.  **Continuous:** `color.` set name numeric column     `layoutDf` (e.g., \"abundance\"), nodes colored along continuous     gradient based column's values. color bar legend drawn. function places labels centroid large domains (>centroid_threshold complexes) directly nodes smaller domains.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/visualizeMapDirectLabels.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Visualize a Complex Map with Direct Node Labels — visualizeMapDirectLabels","text":"Qingzhou Zhang <zqzneptune@hotmail.com>","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/visualizeMapDirectLabels.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Visualize a Complex Map with Direct Node Labels — visualizeMapDirectLabels","text":"","code":"# --- Sample Data --- nodes <- tibble::tibble(   complexId = c(\"C1\", \"C2\", \"C3\"), x = c(1, 2, 1.5), y = c(1, 1, 2),   primaryFunctionalDomain = c(\"DNA Repair\", \"DNA Repair\", \"Metabolism\"),   sizeMapping = c(3, 4, 3.5), colorHex = c(\"#FF0000\", \"#FF0000\", \"#0000FF\"),   abundance = c(1.2, -0.5, 0.8) ) edges <- tibble::tibble(   source_complex_id = \"C1\", target_complex_id = \"C2\", weight = 0.8 )  # --- Usage 1: Default categorical coloring --- if (requireNamespace(\"ggrepel\", quietly = TRUE)) {   visualizeMapDirectLabels(nodes, edges) } #> Visualizing ComplexMap with direct labels...   # --- Usage 2: Continuous coloring by 'abundance' --- if (requireNamespace(\"ggrepel\", quietly = TRUE)) {   visualizeMapDirectLabels(nodes, edges, color.by = \"abundance\") } #> Visualizing ComplexMap with direct labels..."},{"path":"https://zqzneptune.github.io/ComplexMap/reference/visualizeMapInteractive.html","id":null,"dir":"Reference","previous_headings":"","what":"Visualize a Complex Map Interactively — visualizeMapInteractive","title":"Visualize a Complex Map Interactively — visualizeMapInteractive","text":"Creates dynamic, zoomable HTML widget complex network using `visNetwork` package.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/visualizeMapInteractive.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Visualize a Complex Map Interactively — visualizeMapInteractive","text":"","code":"visualizeMapInteractive(   layoutDf,   edgesDf,   width = \"100%\",   height = \"90vh\",   title = \"ComplexMap Functional Landscape\",   physicsEnabled = FALSE,   color.by = NULL,   color.palette = \"viridis\",   rescale_coords = TRUE,   rescale_range = c(-800, 800),   legend_steps = 5,   verbose = TRUE )"},{"path":"https://zqzneptune.github.io/ComplexMap/reference/visualizeMapInteractive.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Visualize a Complex Map Interactively — visualizeMapInteractive","text":"layoutDf data frame containing node attributes layout coordinates, typically `computeMapTopology`. edgesDf data frame containing network edges. width width HTML widget. height height HTML widget. title main title plot. physicsEnabled logical value. `TRUE`, nodes physically react dragging. Defaults `FALSE` stable layout. color.character string specifying name numeric column `layoutDf` use continuous node coloring. `NULL` (default), categorical `colorHex` column used. color.palette character string vector colors continuous gradient (e.g., \"viridis\", \"plasma\", `c(\"blue\", \"white\", \"red\")`). used `color.` specified. rescale_coords Logical. `TRUE`, rescale coordinates visNetwork's coordinate system. Defaults `TRUE`. rescale_range Numeric vector length 2. Range coordinate rescaling. Defaults `c(-800, 800)`. legend_steps Integer. Number steps show continuous color legend. Defaults 5. verbose logical value indicating whether print progress messages.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/visualizeMapInteractive.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Visualize a Complex Map Interactively — visualizeMapInteractive","text":"`visNetwork` HTML widget object.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/visualizeMapInteractive.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Visualize a Complex Map Interactively — visualizeMapInteractive","text":"function supports categorical continuous coloring. `color.` specified, nodes colored numeric values column, tooltip updated include information.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/visualizeMapInteractive.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Visualize a Complex Map Interactively — visualizeMapInteractive","text":"Qingzhou Zhang <zqzneptune@hotmail.com>","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/visualizeMapInteractive.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Visualize a Complex Map Interactively — visualizeMapInteractive","text":"","code":"# --- Sample Data --- nodes <- tibble::tibble(   complexId = c(\"C1\", \"C2\", \"C3\"), x = c(1, 2, 1.5), y = c(1, 1, 2),   primaryFunctionalDomain = c(\"DNA Repair\", \"DNA Repair\", \"Metabolism\"),   sizeMapping = c(3, 4, 3.5), colorHex = c(\"#FF0000\", \"#FF0000\", \"#0000FF\"),   proteinCount = c(10, 8, 12), proteins = c(\"A,B\", \"B,C\", \"D,E\"),   score = c(105.1, 88.3, 95.7) ) edges <- tibble::tibble(   source_complex_id = \"C1\", target_complex_id = \"C2\", weight = 0.8 )  # --- Generate Plot (requires visNetwork) --- if (requireNamespace(\"visNetwork\", quietly = TRUE)) {   # Default categorical coloring   visualizeMapInteractive(nodes, edges)    # Continuous coloring   visualizeMapInteractive(nodes, edges, color.by = \"score\") } #> Generating interactive visNetwork plot... #> Generating interactive visNetwork plot...  {\"x\":{\"nodes\":{\"complexId\":[\"C1\",\"C2\",\"C3\"],\"x\":[-800,800,0],\"y\":[800,800,-800],\"primaryFunctionalDomain\":[\"DNA Repair\",\"DNA Repair\",\"Metabolism\"],\"sizeMapping\":[3,4,3.5],\"colorHex\":[\"#FF0000\",\"#FF0000\",\"#0000FF\"],\"proteinCount\":[10,8,12],\"proteins\":[\"A,B\",\"B,C\",\"D,E\"],\"score\":[105.1,88.3,95.7],\"id\":[\"C1\",\"C2\",\"C3\"],\"label\":[\"C1\",\"C2\",\"C3\"],\"value\":[3,4,3.5],\"color\":[\"#FDE725\",\"#440154\",\"#26828E\"],\"title\":[\"<div style='font-family:sans-serif; text-align:left;'><b>Complex:<\\/b> C1<br><b>Function:<\\/b> DNA Repair<br><b>score:<\\/b> 105.1<br><b>Protein Count:<\\/b> 10<hr><b>Members:<\\/b><br>A, B<\\/div>\",\"<div style='font-family:sans-serif; text-align:left;'><b>Complex:<\\/b> C2<br><b>Function:<\\/b> DNA Repair<br><b>score:<\\/b> 88.3<br><b>Protein Count:<\\/b> 8<hr><b>Members:<\\/b><br>B, C<\\/div>\",\"<div style='font-family:sans-serif; text-align:left;'><b>Complex:<\\/b> C3<br><b>Function:<\\/b> Metabolism<br><b>score:<\\/b> 95.7<br><b>Protein Count:<\\/b> 12<hr><b>Members:<\\/b><br>D, E<\\/div>\"]},\"edges\":{\"source_complex_id\":[\"C1\"],\"target_complex_id\":[\"C2\"],\"weight\":[0.8],\"from\":[\"C1\"],\"to\":[\"C2\"],\"value\":[0.8]},\"nodesToDataframe\":true,\"edgesToDataframe\":true,\"options\":{\"width\":\"100%\",\"height\":\"100%\",\"nodes\":{\"shape\":\"dot\",\"borderWidth\":2,\"shadow\":true},\"manipulation\":{\"enabled\":false},\"edges\":{\"color\":{\"color\":\"#888888\",\"highlight\":\"#00BFFF\"},\"smooth\":false},\"physics\":{\"enabled\":false},\"interaction\":{\"hover\":true,\"dragNodes\":true,\"dragView\":true,\"navigationButtons\":true,\"tooltipDelay\":200,\"zoomView\":true,\"zoomSpeed\":1},\"layout\":{\"randomSeed\":123}},\"groups\":null,\"width\":\"100%\",\"height\":\"90vh\",\"idselection\":{\"enabled\":true,\"style\":\"width: 150px; height: 26px\",\"useLabels\":true,\"main\":\"Select by id\"},\"byselection\":{\"enabled\":true,\"style\":\"width: 150px; height: 26px\",\"multiple\":false,\"hideColor\":\"rgba(200,200,200,0.5)\",\"highlight\":false,\"variable\":\"primaryFunctionalDomain\",\"main\":\"Select by primaryFunctionalDomain\",\"values\":[\"DNA Repair\",\"Metabolism\"]},\"main\":{\"text\":\"ComplexMap Functional Landscape\",\"style\":\"font-family:Georgia, Times New Roman, Times, serif;font-weight:bold;font-size:20px;text-align:center;\"},\"submain\":null,\"footer\":null,\"background\":\"rgba(0, 0, 0, 0)\",\"highlight\":{\"enabled\":true,\"hoverNearest\":true,\"degree\":1,\"algorithm\":\"all\",\"hideColor\":\"rgba(200,200,200,0.5)\",\"labelOnly\":true},\"collapse\":{\"enabled\":false,\"fit\":false,\"resetHighlight\":true,\"clusterOptions\":null,\"keepCoord\":true,\"labelSuffix\":\"(cluster)\"},\"tooltipStay\":300,\"tooltipStyle\":\"position: fixed;visibility:hidden;padding: 5px;white-space: nowrap;font-family: verdana;font-size:14px;font-color:#000000;background-color: #f5f4ed;-moz-border-radius: 3px;-webkit-border-radius: 3px;border-radius: 3px;border: 1px solid #808074;box-shadow: 3px 3px 10px rgba(0, 0, 0, 0.2);\",\"legend\":{\"width\":0.2,\"useGroups\":false,\"position\":\"left\",\"ncol\":1,\"stepX\":100,\"stepY\":100,\"zoom\":true,\"nodes\":{\"label\":[88.3,92.5,96.7,100.9,105.1],\"color\":[\"#440154\",\"#3B528B\",\"#21908D\",\"#5DC863\",\"#FDE725\"],\"shape\":[\"dot\",\"dot\",\"dot\",\"dot\",\"dot\"],\"size\":[10,10,10,10,10]},\"nodesToDataframe\":true,\"main\":{\"text\":\"score\",\"style\":\"color:black;font-weight:bold;font-size:14px;text-align:center;\"}}},\"evals\":[],\"jsHooks\":[]}"},{"path":"https://zqzneptune.github.io/ComplexMap/reference/visualizeMapWithLegend.html","id":null,"dir":"Reference","previous_headings":"","what":"Visualize a Complex Map with a Color Legend — visualizeMapWithLegend","title":"Visualize a Complex Map with a Color Legend — visualizeMapWithLegend","text":"Creates static visualization complex network using `ggraph`, legend representing node colors.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/visualizeMapWithLegend.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Visualize a Complex Map with a Color Legend — visualizeMapWithLegend","text":"","code":"visualizeMapWithLegend(   layoutDf,   edgesDf,   title = \"ComplexMap Functional Landscape\",   subtitle = \"Nodes are protein complexes, colored by function\",   bgColor = \"black\",   edgeColor = \"white\",   nodeSizeRange = c(2, 10),   unenrichedColor = \"#CCCCCC\",   fontFamily = \"sans\",   size.legend.title = \"Complex Size (log2)\",   color.by = NULL,   color.palette = \"viridis\",   color.legend.title = NULL,   verbose = TRUE )"},{"path":"https://zqzneptune.github.io/ComplexMap/reference/visualizeMapWithLegend.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Visualize a Complex Map with a Color Legend — visualizeMapWithLegend","text":"layoutDf data frame containing node attributes layout coordinates, typically `computeMapTopology`. edgesDf data frame containing network edges. title main title plot. subtitle subtitle plot. bgColor background color plot. edgeColor color network edges. nodeSizeRange numeric vector length 2 specifying min max node size. unenrichedColor color nodes \"Unenriched\" category categorical mode. fontFamily base font family plot text. size.legend.title title node size legend. color.character string specifying name numeric column `layoutDf` use continuous node coloring. `NULL` (default), categorical `colorHex` column used. color.palette character string vector colors continuous gradient (e.g., \"viridis\", \"plasma\", `c(\"blue\", \"white\", \"red\")`). used `color.` specified. color.legend.title character string title continuous color legend. Defaults value `color.`. verbose logical value indicating whether print progress messages.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/visualizeMapWithLegend.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Visualize a Complex Map with a Color Legend — visualizeMapWithLegend","text":"`ggplot` object representing network visualization.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/visualizeMapWithLegend.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Visualize a Complex Map with a Color Legend — visualizeMapWithLegend","text":"function supports two coloring modes: 1.  **Categorical (default):** `color.= NULL`, nodes colored     `primaryFunctionalDomain`. discrete color legend shown. 2.  **Continuous:** `color.` set name numeric column     `layoutDf`, nodes colored along continuous gradient. color     bar legend shown.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/visualizeMapWithLegend.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Visualize a Complex Map with a Color Legend — visualizeMapWithLegend","text":"Qingzhou Zhang <zqzneptune@hotmail.com>","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/reference/visualizeMapWithLegend.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Visualize a Complex Map with a Color Legend — visualizeMapWithLegend","text":"","code":"# --- Sample Data --- nodes <- tibble::tibble(   complexId = c(\"C1\", \"C2\", \"C3\"), x = c(1, 2, 1.5), y = c(1, 1, 2),   primaryFunctionalDomain = c(\"DNA Repair\", \"DNA Repair\", \"Unenriched\"),   sizeMapping = c(3, 4, 3.5), colorHex = c(\"#FF0000\", \"#FF0000\", \"#CCCCCC\"),   purity = c(0.95, 0.87, 0.91) ) edges <- tibble::tibble(   source_complex_id = \"C1\", target_complex_id = \"C2\", weight = 0.8 )  # --- Usage 1: Default categorical coloring --- visualizeMapWithLegend(nodes, edges) #> Visualizing ComplexMap with a color legend...   # --- Usage 2: Continuous coloring --- visualizeMapWithLegend(nodes, edges, color.by = \"purity\") #> Visualizing ComplexMap with a color legend..."},{"path":[]},{"path":"https://zqzneptune.github.io/ComplexMap/news/index.html","id":"added-1-1-0","dir":"Changelog","previous_headings":"","what":"Added","title":"ComplexMap 1.1.0 - 2025-11-15","text":"Quantitative Data Visualization: three visualization functions (visualizeMapDirectLabels, visualizeMapWithLegend, visualizeMapInteractive) now support color.argument map continuous experimental data directly onto node colors. Robust Parameter Benchmarking: Added new benchmarkParameters() function systematically test optimize mergeThreshold values reference complex set. New Similarity Metrics: Added dice matching_score similarity options refineComplexList flexible complex merging. New Vignette: Added comprehensive vignette (04-quantitative-visualization.Rmd) demonstrate new quantitative data workflow.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/news/index.html","id":"changed-1-1-0","dir":"Changelog","previous_headings":"","what":"Changed","title":"ComplexMap 1.1.0 - 2025-11-15","text":"New Default Metric: default similarityMethod refineComplexList now \"matching_score\" better align refinement logic standard MMR evaluation metric. Enhanced Traceability: refineComplexList now returns mergeMap tibble, providing clear reproducible map original merged complex IDs. Improved QC Report: Overhauled output qcComplexList user-friendly, formatted report clear warnings visual cues, rather raw R output. Metric Renaming: Renamed \"overlap\" similarity metric \"simpson\" clarity correctness.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/news/index.html","id":"fixed-1-1-0","dir":"Changelog","previous_headings":"","what":"Fixed","title":"ComplexMap 1.1.0 - 2025-11-15","text":"Resolved R CMD check errors vignettes caused excessive parallel core usage examples (nCores now limited). Fixed data type mismatches vignettes occurred joining igraph membership objects dplyr tibbles.","code":""},{"path":"https://zqzneptune.github.io/ComplexMap/news/index.html","id":"complexmap-100","dir":"Changelog","previous_headings":"","what":"ComplexMap 1.0.0","title":"ComplexMap 1.0.0","text":"Initial stable release. Complete refactoring codebase adhere Bioconductor standards. Introduction ComplexMap S3 object structured workflow. Added high-level wrapper createComplexMap() end--end analysis. Added new functions analysis exploration: summarizeThemes(), queryMap(), exportNetwork(). Added three comprehensive vignettes. Numerous bug fixes improvements robustness.","code":""}]
