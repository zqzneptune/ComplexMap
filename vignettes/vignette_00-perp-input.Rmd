---
title: "Preparing Input Data"
author: "Qingzhou Zhang"
date: "`r Sys.Date()`"
output: html_document
vignette: >
  %\VignetteIndexEntry{Preparing Input Data for ComplexMap}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

# The ComplexMap Philosophy: Identifier Matching

The `ComplexMap` package was designed to be powerful, flexible, and **species-agnostic**. It does not contain any hard-coded assumptions about *Homo sapiens* or any other model organism.

The entire workflow depends on one simple principle: **the identifiers used in your input lists must match**. This means the package's functions can support any organism and any identifier type (e.g., Gene Symbols, Entrez IDs, Ensembl IDs, UniProt IDs), as long as they are consistent.

There are three key inputs where identifiers must be consistent:

1.  **Your Complex List**: The list of protein/gene members for each complex you want to analyze.
2.  **Your Functional Gene Sets (GMT)**: The database used for enrichment analysis.
3.  **Your Reference Complex List**: A "gold standard" list used for benchmarking with `evaluateComplexes()`. (**This is only required for benchmarking, not for functional analysis.**)

For example, if your complex list uses **Gene Symbols**, your GMT file must also use **Gene Symbols**. If your complex list uses **Entrez IDs**, your GMT must use **Entrez IDs**.

This vignette demonstrates how to prepare the functional gene sets (GMT) from various sources and, crucially, how to handle and convert identifiers to ensure they match your input data.

```{r setup, message=FALSE, warning=FALSE}
library(ComplexMap)
library(dplyr)

# For this tutorial, we will assume our input complex list uses Gene Symbols.
myComplexes <- list(
  CPLX1 = c("POLR2A", "POLR2B", "POLR2C"),
  CPLX2 = c("CDK1", "CCNB1", "CCNB2")
)
```

# Preparing Functional Gene Sets (GMT)

`ComplexMap` provides several helper functions to obtain GMT files. Let's explore each one, paying close attention to the identifier type it returns.

## Method 1: From a User-Provided Local File

This is the most direct method. If you have your own GMT file, you can load it with `getGmtFromFile()`.

First, get the path to the example GMT file included with the package. This file uses Gene Symbols.

```{r from-file-1}
gmtPath <- getExampleGmt()
```

Load the GMT from the file path

```{r from-file-2}
gmtFromFile <- getGmtFromFile(gmtPath)
```

Let's inspect the identifiers

```{r from-file-3}
# Name of the first gene set:
names(gmtFromFile)[1:5]
```

```{r from-file-4}
# First 5 genes in that set:
gmtFromFile[1]
```
**Identifier Match:** The example GMT file uses **Gene Symbols**. Since our hypothetical `myComplexes` list also uses Gene Symbols, these are directly compatible and ready for analysis.

## Method 2: From the Molecular Signatures Database (MSigDB)

The `msigdbr` package provides a powerful and up-to-date interface to the MSigDB collections. Our `getMsigdbGmt()` function simplifies this process.

```{r from-msigdb}
# Fetch the Hallmark gene sets for Human
# This requires the `msigdbr` package
if (requireNamespace("msigdbr", quietly = TRUE)) {
  h_gmt <- getMsigdbGmt(species = "Homo sapiens", collection = "H")

  # Inspect the identifiers
  h_gmt[1]
}
```
**Identifier Match:** By default, `msigdbr` also returns **Gene Symbols**. This is directly compatible with our `myComplexes` list.

## Method 3: From Gene Ontology (GO) via Bioconductor

Using official Bioconductor annotation packages is a highly reproducible way to get functional annotations. These databases, however, typically use stable database identifiers, not gene symbols.

```{r from-go}
# This requires an organism annotation package, e.g., org.Hs.eg.db for human
if (requireNamespace("org.Hs.eg.db", quietly = TRUE)) {
  suppressPackageStartupMessages(library(org.Hs.eg.db))
  # Fetch Biological Process (BP) terms
  goGmt <- getGoGmt(speciesDb = org.Hs.eg.db, ontology = "BP")

  # Inspect the identifiers
  goGmt[1]
}
```
**Identifier Mismatch!** The `getGoGmt` function returns a list where the genes are **Entrez IDs** (e.g., "5594", "5595"). These will **not match** the Gene Symbols in our `myComplexes` list (e.g., "POLR2A").

**Solution: Convert Your Complex List Identifiers**

The recommended approach is to convert your input complex identifiers to match the stable IDs from the annotation database. The `AnnotationDbi::mapIds` function is perfect for this.

```{r convert-ids}
if (requireNamespace("org.Hs.eg.db", quietly = TRUE)) {
  suppressPackageStartupMessages(library(org.Hs.eg.db))
  # Get all unique symbols from our complex list
  allSymbols <- unique(unlist(myComplexes))

  # Map symbols to Entrez IDs
  symbolToEntrez <- AnnotationDbi::mapIds(org.Hs.eg.db,
                                           keys = allSymbols,
                                           keytype = "SYMBOL",
                                           column = "ENTREZID",
                                           multiVals = "first")
  
  # Remove any symbols that could not be mapped
  symbolToEntrez <- symbolToEntrez[!is.na(symbolToEntrez)]

  # Now, create a new complex list with Entrez IDs
  myComplexesEntrez <- lapply(myComplexes, function(complex) {
    # Look up the Entrez ID for each symbol and keep only those that were mapped
    unname(symbolToEntrez[as.character(complex)])
  })
  
  # Clean out any NAs that resulted from unmapped symbols
  myComplexesEntrez <- lapply(myComplexesEntrez, function(x) x[!is.na(x)])

  # Inspect the result
  print(myComplexesEntrez)
}
```
Now, the `myComplexesEntrez` list is directly compatible with the `goGmt` generated from Bioconductor.

## Method 4: From Reactome Pathways via Bioconductor

Similarly, the `reactome.db` package provides pathway annotations, which also use Entrez IDs.

```{r from-reactome}
if (requireNamespace("reactome.db", quietly = TRUE) && 
    requireNamespace("org.Hs.eg.db", quietly = TRUE)) {
  suppressPackageStartupMessages(library(reactome.db))
  suppressPackageStartupMessages(library(org.Hs.eg.db))
  reactomeGmt <- getReactomeGmt(speciesDb = org.Hs.eg.db)

  # Inspect the identifiers
  reactomeGmt[1]
}
```
**Identifier Mismatch!** Like the GO example, `reactome.db` provides **Entrez IDs**.

**Solution:** The solution is the same as for Gene Ontology. You would use the `myComplexesEntrez` list that we created in the previous step, as its identifiers will match the identifiers in the `reactomeGmt`.

# Conclusion

This vignette has demonstrated the core philosophy of `ComplexMap`: flexibility through identifier consistency. By understanding the identifier types returned by different sources and knowing how to convert your own data to match, you can apply the `ComplexMap` workflow to virtually any organism for which you have complex and annotation data.

Always check your identifiers before running the main analysis functions to ensure a smooth and successful workflow.
